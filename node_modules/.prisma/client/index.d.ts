
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Client
 */

export type Client = {
  Id: number
  Name: string
  Address: string | null
  City: string | null
  PhoneNumber: string | null
  TaxIdentificationNumber: string | null
  IsDelete: boolean
  CreatedBy: number
  CreatedDate: Date
}

/**
 * Model ClientContact
 */

export type ClientContact = {
  Id: number
  Name: string
  Position: string
  PhoneNumber: string
  Email: string
  CreatedBy: number
  CreatedDate: Date
  ClientId: number
}

/**
 * Model CodeProject
 */

export type CodeProject = {
  Id: number
  Name: string
  ClientId: number
  CreatedBy: number
  CreatedDate: Date
  ConfirmedDate: Date | null
  ConfirmedBy: number | null
  Address: string
  DocumentName: string
  IsCompleted: boolean
  CompletedDate: Date | null
  CompletedBy: number | null
  IsDelete: boolean
}

/**
 * Model CodeProjectDocument
 */

export type CodeProjectDocument = {
  Id: number
  Name: string
  Url: string
  CodeProjectId: number
  CreatedBy: number
  CreatedDate: Date
}

/**
 * Model CodeProjectUser
 */

export type CodeProjectUser = {
  Id: number
  UserId: number
  CodeProjectId: number
}

/**
 * Model CodeReport
 */

export type CodeReport = {
  Id: number
  CreatedBy: number
  CreatedDate: Date
  Date: Date
  CodeProjectId: number
  Type: number
  IsDelete: boolean
  Note: string
}

/**
 * Model CodeReportApproval
 */

export type CodeReportApproval = {
  Id: number
  CodeReportId: number
  CreatedBy: number
  CreatedDate: Date
  Comment: string
  Approval: number
  IsDelete: boolean
}

/**
 * Model DailyReportImage
 */

export type DailyReportImage = {
  Id: number
  CodeReportId: number
  ImageUrl: string
  Name: string
  Caption: string
}

/**
 * Model DailyTask
 */

export type DailyTask = {
  Id: number
  Name: string
  Description: string
  Unit: string
  Quantity: number
  ParentId: number
  CodeReportId: number
  Note: string
}

/**
 * Model Material
 */

export type Material = {
  Id: number
  Name: string
  Quantity: number
  Status: number
  Description: string
  Unit: string
  CodeReportId: number
}

/**
 * Model Project
 */

export type Project = {
  Id: number
  Name: string
  BudgetPrice: number
  Quantity: number
  Done: number
  IsDelete: boolean
  CodeProjectId: number
  ParentId: number
  EstimatedDuration: number
  Timeline: number
  Price: number
  Description: string
  Unit: string
}

/**
 * Model ProjectTask
 */

export type ProjectTask = {
  Id: number
  Name: string
  Description: string
  ParentId: number
  CreatedBy: number
  CreatedDate: Date
}

/**
 * Model RequestForInformation
 */

export type RequestForInformation = {
  Id: number
  CodeReportId: number
  Description: string
  Header: string
  AddressedFor: string
  IsDelete: boolean
}

/**
 * Model RequestForInformationAnswer
 */

export type RequestForInformationAnswer = {
  Id: number
  Answer: string
  CreatedBy: number
  CreatedDate: Date
  RequestForInformationId: number
  IsDelete: boolean
}

/**
 * Model RequestForInformationDocument
 */

export type RequestForInformationDocument = {
  Id: number
  RequestForInformationId: number
  ImageUrl: string
  Name: string
}

/**
 * Model StatusReport
 */

export type StatusReport = {
  Id: number
  Status: string
  CodeReportId: number
}

/**
 * Model StatusReportImage
 */

export type StatusReportImage = {
  Id: number
  StatusReportId: number
  ImageUrl: string
  Name: string
}

/**
 * Model Tool
 */

export type Tool = {
  Id: number
  Name: string
  Description: string
  Quantity: number
  CodeReportId: number
}

/**
 * Model Weather
 */

export type Weather = {
  Id: number
  WeatherId: number
  CodeReportId: number
}

/**
 * Model Worker
 */

export type Worker = {
  Id: number
  Name: string
  CodeReportId: number
  Quantity: number
}

/**
 * Model UserContact
 */

export type UserContact = {
  Id: number
  PhoneNumber: string
  UserId: number
  WhatsappAvailable: boolean
}

/**
 * Model UserPosition
 */

export type UserPosition = {
  Id: number
  Position: number
  EffectiveDate: Date
  CreatedBy: number
  CreatedDate: Date
  UserId: number
}

/**
 * Model User
 */

export type User = {
  Id: number
  Email: string
  FirstName: string
  LastName: string
  IsActive: boolean
  Password: string | null
  ImageUrl: string | null
  ThumbnailUrl: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clients
 * const clients = await prisma.client.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clients
   * const clients = await prisma.client.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<GlobalReject>;

  /**
   * `prisma.clientContact`: Exposes CRUD operations for the **ClientContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContacts
    * const clientContacts = await prisma.clientContact.findMany()
    * ```
    */
  get clientContact(): Prisma.ClientContactDelegate<GlobalReject>;

  /**
   * `prisma.codeProject`: Exposes CRUD operations for the **CodeProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeProjects
    * const codeProjects = await prisma.codeProject.findMany()
    * ```
    */
  get codeProject(): Prisma.CodeProjectDelegate<GlobalReject>;

  /**
   * `prisma.codeProjectDocument`: Exposes CRUD operations for the **CodeProjectDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeProjectDocuments
    * const codeProjectDocuments = await prisma.codeProjectDocument.findMany()
    * ```
    */
  get codeProjectDocument(): Prisma.CodeProjectDocumentDelegate<GlobalReject>;

  /**
   * `prisma.codeProjectUser`: Exposes CRUD operations for the **CodeProjectUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeProjectUsers
    * const codeProjectUsers = await prisma.codeProjectUser.findMany()
    * ```
    */
  get codeProjectUser(): Prisma.CodeProjectUserDelegate<GlobalReject>;

  /**
   * `prisma.codeReport`: Exposes CRUD operations for the **CodeReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeReports
    * const codeReports = await prisma.codeReport.findMany()
    * ```
    */
  get codeReport(): Prisma.CodeReportDelegate<GlobalReject>;

  /**
   * `prisma.codeReportApproval`: Exposes CRUD operations for the **CodeReportApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeReportApprovals
    * const codeReportApprovals = await prisma.codeReportApproval.findMany()
    * ```
    */
  get codeReportApproval(): Prisma.CodeReportApprovalDelegate<GlobalReject>;

  /**
   * `prisma.dailyReportImage`: Exposes CRUD operations for the **DailyReportImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyReportImages
    * const dailyReportImages = await prisma.dailyReportImage.findMany()
    * ```
    */
  get dailyReportImage(): Prisma.DailyReportImageDelegate<GlobalReject>;

  /**
   * `prisma.dailyTask`: Exposes CRUD operations for the **DailyTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyTasks
    * const dailyTasks = await prisma.dailyTask.findMany()
    * ```
    */
  get dailyTask(): Prisma.DailyTaskDelegate<GlobalReject>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<GlobalReject>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<GlobalReject>;

  /**
   * `prisma.projectTask`: Exposes CRUD operations for the **ProjectTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTasks
    * const projectTasks = await prisma.projectTask.findMany()
    * ```
    */
  get projectTask(): Prisma.ProjectTaskDelegate<GlobalReject>;

  /**
   * `prisma.requestForInformation`: Exposes CRUD operations for the **RequestForInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestForInformations
    * const requestForInformations = await prisma.requestForInformation.findMany()
    * ```
    */
  get requestForInformation(): Prisma.RequestForInformationDelegate<GlobalReject>;

  /**
   * `prisma.requestForInformationAnswer`: Exposes CRUD operations for the **RequestForInformationAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestForInformationAnswers
    * const requestForInformationAnswers = await prisma.requestForInformationAnswer.findMany()
    * ```
    */
  get requestForInformationAnswer(): Prisma.RequestForInformationAnswerDelegate<GlobalReject>;

  /**
   * `prisma.requestForInformationDocument`: Exposes CRUD operations for the **RequestForInformationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestForInformationDocuments
    * const requestForInformationDocuments = await prisma.requestForInformationDocument.findMany()
    * ```
    */
  get requestForInformationDocument(): Prisma.RequestForInformationDocumentDelegate<GlobalReject>;

  /**
   * `prisma.statusReport`: Exposes CRUD operations for the **StatusReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusReports
    * const statusReports = await prisma.statusReport.findMany()
    * ```
    */
  get statusReport(): Prisma.StatusReportDelegate<GlobalReject>;

  /**
   * `prisma.statusReportImage`: Exposes CRUD operations for the **StatusReportImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusReportImages
    * const statusReportImages = await prisma.statusReportImage.findMany()
    * ```
    */
  get statusReportImage(): Prisma.StatusReportImageDelegate<GlobalReject>;

  /**
   * `prisma.tool`: Exposes CRUD operations for the **Tool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tools
    * const tools = await prisma.tool.findMany()
    * ```
    */
  get tool(): Prisma.ToolDelegate<GlobalReject>;

  /**
   * `prisma.weather`: Exposes CRUD operations for the **Weather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weathers
    * const weathers = await prisma.weather.findMany()
    * ```
    */
  get weather(): Prisma.WeatherDelegate<GlobalReject>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<GlobalReject>;

  /**
   * `prisma.userContact`: Exposes CRUD operations for the **UserContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserContacts
    * const userContacts = await prisma.userContact.findMany()
    * ```
    */
  get userContact(): Prisma.UserContactDelegate<GlobalReject>;

  /**
   * `prisma.userPosition`: Exposes CRUD operations for the **UserPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPositions
    * const userPositions = await prisma.userPosition.findMany()
    * ```
    */
  get userPosition(): Prisma.UserPositionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.26.0
   * Query Engine version: c838e79f39885bc8e1611849b1eb28b5bb5bc922
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Client: 'Client',
    ClientContact: 'ClientContact',
    CodeProject: 'CodeProject',
    CodeProjectDocument: 'CodeProjectDocument',
    CodeProjectUser: 'CodeProjectUser',
    CodeReport: 'CodeReport',
    CodeReportApproval: 'CodeReportApproval',
    DailyReportImage: 'DailyReportImage',
    DailyTask: 'DailyTask',
    Material: 'Material',
    Project: 'Project',
    ProjectTask: 'ProjectTask',
    RequestForInformation: 'RequestForInformation',
    RequestForInformationAnswer: 'RequestForInformationAnswer',
    RequestForInformationDocument: 'RequestForInformationDocument',
    StatusReport: 'StatusReport',
    StatusReportImage: 'StatusReportImage',
    Tool: 'Tool',
    Weather: 'Weather',
    Worker: 'Worker',
    UserContact: 'UserContact',
    UserPosition: 'UserPosition',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
    max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
  }

  export type ClientSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
  }

  export type ClientMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Address: string | null
    City: string | null
    PhoneNumber: string | null
    TaxIdentificationNumber: string | null
    IsDelete: boolean | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Address: string | null
    City: string | null
    PhoneNumber: string | null
    TaxIdentificationNumber: string | null
    IsDelete: boolean | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ClientCountAggregateOutputType = {
    Id: number
    Name: number
    Address: number
    City: number
    PhoneNumber: number
    TaxIdentificationNumber: number
    IsDelete: number
    CreatedBy: number
    CreatedDate: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
  }

  export type ClientSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
  }

  export type ClientMinAggregateInputType = {
    Id?: true
    Name?: true
    Address?: true
    City?: true
    PhoneNumber?: true
    TaxIdentificationNumber?: true
    IsDelete?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ClientMaxAggregateInputType = {
    Id?: true
    Name?: true
    Address?: true
    City?: true
    PhoneNumber?: true
    TaxIdentificationNumber?: true
    IsDelete?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ClientCountAggregateInputType = {
    Id?: true
    Name?: true
    Address?: true
    City?: true
    PhoneNumber?: true
    TaxIdentificationNumber?: true
    IsDelete?: true
    CreatedBy?: true
    CreatedDate?: true
    _all?: true
  }

  export type ClientAggregateArgs = {
    /**
     * Filter which Client to aggregate.
     * 
    **/
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }


    
    
  export type ClientGroupByArgs = {
    where?: ClientWhereInput
    orderBy?: Enumerable<ClientOrderByInput>
    by: Array<ClientScalarFieldEnum>
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    Id: number
    Name: string
    Address: string | null
    City: string | null
    PhoneNumber: string | null
    TaxIdentificationNumber: string | null
    IsDelete: boolean
    CreatedBy: number
    CreatedDate: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Promise<
    Array<
      PickArray<ClientGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ClientGroupByOutputType[P]> 
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      > 
    >


  export type ClientSelect = {
    Id?: boolean
    Name?: boolean
    Address?: boolean
    City?: boolean
    PhoneNumber?: boolean
    TaxIdentificationNumber?: boolean
    User?: boolean | UserArgs
    IsDelete?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Contact?: boolean | ClientContactFindManyArgs
    CodeProject?: boolean | CodeProjectFindManyArgs
  }

  export type ClientInclude = {
    User?: boolean | UserArgs
    Contact?: boolean | ClientContactFindManyArgs
    CodeProject?: boolean | CodeProjectFindManyArgs
  }

  export type ClientGetPayload<
    S extends boolean | null | undefined | ClientArgs,
    U = keyof S
      > = S extends true
        ? Client
    : S extends undefined
    ? never
    : S extends ClientArgs | ClientFindManyArgs
    ?'include' extends U
    ? Client  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> :
        P extends 'Contact'
        ? Array < ClientContactGetPayload<S['include'][P]>>  :
        P extends 'CodeProject'
        ? Array < CodeProjectGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Client ?Client [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> :
        P extends 'Contact'
        ? Array < ClientContactGetPayload<S['select'][P]>>  :
        P extends 'CodeProject'
        ? Array < CodeProjectGetPayload<S['select'][P]>>  : never
  } 
    : Client
  : Client


  type ClientCountArgs = Merge<
    Omit<ClientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }
  >

  export interface ClientDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Client'> extends True ? CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>> : CheckSelect<T, Prisma__ClientClient<Client | null >, Prisma__ClientClient<ClientGetPayload<T> | null >>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Client'> extends True ? CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>> : CheckSelect<T, Prisma__ClientClient<Client | null >, Prisma__ClientClient<ClientGetPayload<T> | null >>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs>(
      args?: SelectSubset<T, ClientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Client>>, PrismaPromise<Array<ClientGetPayload<T>>>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs>(
      args: SelectSubset<T, ClientCreateArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Create many Clients.
     *     @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientCreateManyArgs>(
      args?: SelectSubset<T, ClientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs>(
      args: SelectSubset<T, ClientDeleteArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs>(
      args: SelectSubset<T, ClientUpdateArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs>(
      args?: SelectSubset<T, ClientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs>(
      args: SelectSubset<T, ClientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs>(
      args: SelectSubset<T, ClientUpsertArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    Contact<T extends ClientContactFindManyArgs = {}>(args?: Subset<T, ClientContactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ClientContact>>, PrismaPromise<Array<ClientContactGetPayload<T>>>>;

    CodeProject<T extends CodeProjectFindManyArgs = {}>(args?: Subset<T, CodeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProject>>, PrismaPromise<Array<CodeProjectGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Throw an Error if a Client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Client to fetch.
     * 
    **/
    where: ClientWhereUniqueInput
  }


  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Throw an Error if a Client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Client to fetch.
     * 
    **/
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     * 
    **/
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     * 
    **/
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client findMany
   */
  export type ClientFindManyArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Filter, which Clients to fetch.
     * 
    **/
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     * 
    **/
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client create
   */
  export type ClientCreateArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * The data needed to create a Client.
     * 
    **/
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }


  /**
   * Client createMany
   */
  export type ClientCreateManyArgs = {
    data: Enumerable<ClientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Client update
   */
  export type ClientUpdateArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * The data needed to update a Client.
     * 
    **/
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     * 
    **/
    where: ClientWhereUniqueInput
  }


  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs = {
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    where?: ClientWhereInput
  }


  /**
   * Client upsert
   */
  export type ClientUpsertArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * The filter to search for the Client to update in case it exists.
     * 
    **/
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     * 
    **/
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }


  /**
   * Client delete
   */
  export type ClientDeleteArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Filter which Client to delete.
     * 
    **/
    where: ClientWhereUniqueInput
  }


  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs = {
    where?: ClientWhereInput
  }


  /**
   * Client without action
   */
  export type ClientArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
  }



  /**
   * Model ClientContact
   */


  export type AggregateClientContact = {
    _count: ClientContactCountAggregateOutputType | null
    count: ClientContactCountAggregateOutputType | null
    _avg: ClientContactAvgAggregateOutputType | null
    avg: ClientContactAvgAggregateOutputType | null
    _sum: ClientContactSumAggregateOutputType | null
    sum: ClientContactSumAggregateOutputType | null
    _min: ClientContactMinAggregateOutputType | null
    min: ClientContactMinAggregateOutputType | null
    _max: ClientContactMaxAggregateOutputType | null
    max: ClientContactMaxAggregateOutputType | null
  }

  export type ClientContactAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    ClientId: number | null
  }

  export type ClientContactSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    ClientId: number | null
  }

  export type ClientContactMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Position: string | null
    PhoneNumber: string | null
    Email: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ClientId: number | null
  }

  export type ClientContactMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Position: string | null
    PhoneNumber: string | null
    Email: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ClientId: number | null
  }

  export type ClientContactCountAggregateOutputType = {
    Id: number
    Name: number
    Position: number
    PhoneNumber: number
    Email: number
    CreatedBy: number
    CreatedDate: number
    ClientId: number
    _all: number
  }


  export type ClientContactAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
    ClientId?: true
  }

  export type ClientContactSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
    ClientId?: true
  }

  export type ClientContactMinAggregateInputType = {
    Id?: true
    Name?: true
    Position?: true
    PhoneNumber?: true
    Email?: true
    CreatedBy?: true
    CreatedDate?: true
    ClientId?: true
  }

  export type ClientContactMaxAggregateInputType = {
    Id?: true
    Name?: true
    Position?: true
    PhoneNumber?: true
    Email?: true
    CreatedBy?: true
    CreatedDate?: true
    ClientId?: true
  }

  export type ClientContactCountAggregateInputType = {
    Id?: true
    Name?: true
    Position?: true
    PhoneNumber?: true
    Email?: true
    CreatedBy?: true
    CreatedDate?: true
    ClientId?: true
    _all?: true
  }

  export type ClientContactAggregateArgs = {
    /**
     * Filter which ClientContact to aggregate.
     * 
    **/
    where?: ClientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContacts
    **/
    _count?: true | ClientContactCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ClientContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContactAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ClientContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContactSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ClientContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContactMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ClientContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContactMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ClientContactMaxAggregateInputType
  }

  export type GetClientContactAggregateType<T extends ClientContactAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContact[P]>
      : GetScalarType<T[P], AggregateClientContact[P]>
  }


    
    
  export type ClientContactGroupByArgs = {
    where?: ClientContactWhereInput
    orderBy?: Enumerable<ClientContactOrderByInput>
    by: Array<ClientContactScalarFieldEnum>
    having?: ClientContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContactCountAggregateInputType | true
    _avg?: ClientContactAvgAggregateInputType
    _sum?: ClientContactSumAggregateInputType
    _min?: ClientContactMinAggregateInputType
    _max?: ClientContactMaxAggregateInputType
  }


  export type ClientContactGroupByOutputType = {
    Id: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate: Date
    ClientId: number
    _count: ClientContactCountAggregateOutputType | null
    _avg: ClientContactAvgAggregateOutputType | null
    _sum: ClientContactSumAggregateOutputType | null
    _min: ClientContactMinAggregateOutputType | null
    _max: ClientContactMaxAggregateOutputType | null
  }

  type GetClientContactGroupByPayload<T extends ClientContactGroupByArgs> = Promise<
    Array<
      PickArray<ClientContactGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ClientContactGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ClientContactGroupByOutputType[P]> 
            : GetScalarType<T[P], ClientContactGroupByOutputType[P]>
        }
      > 
    >


  export type ClientContactSelect = {
    Id?: boolean
    Name?: boolean
    Position?: boolean
    PhoneNumber?: boolean
    Email?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Client?: boolean | ClientArgs
    ClientId?: boolean
    User?: boolean | UserArgs
  }

  export type ClientContactInclude = {
    Client?: boolean | ClientArgs
    User?: boolean | UserArgs
  }

  export type ClientContactGetPayload<
    S extends boolean | null | undefined | ClientContactArgs,
    U = keyof S
      > = S extends true
        ? ClientContact
    : S extends undefined
    ? never
    : S extends ClientContactArgs | ClientContactFindManyArgs
    ?'include' extends U
    ? ClientContact  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Client'
        ? ClientGetPayload<S['include'][P]> :
        P extends 'User'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ClientContact ?ClientContact [P]
  : 
          P extends 'Client'
        ? ClientGetPayload<S['select'][P]> :
        P extends 'User'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ClientContact
  : ClientContact


  type ClientContactCountArgs = Merge<
    Omit<ClientContactFindManyArgs, 'select' | 'include'> & {
      select?: ClientContactCountAggregateInputType | true
    }
  >

  export interface ClientContactDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ClientContact that matches the filter.
     * @param {ClientContactFindUniqueArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientContactFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClientContactFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClientContact'> extends True ? CheckSelect<T, Prisma__ClientContactClient<ClientContact>, Prisma__ClientContactClient<ClientContactGetPayload<T>>> : CheckSelect<T, Prisma__ClientContactClient<ClientContact | null >, Prisma__ClientContactClient<ClientContactGetPayload<T> | null >>

    /**
     * Find the first ClientContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindFirstArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientContactFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClientContactFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClientContact'> extends True ? CheckSelect<T, Prisma__ClientContactClient<ClientContact>, Prisma__ClientContactClient<ClientContactGetPayload<T>>> : CheckSelect<T, Prisma__ClientContactClient<ClientContact | null >, Prisma__ClientContactClient<ClientContactGetPayload<T> | null >>

    /**
     * Find zero or more ClientContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContacts
     * const clientContacts = await prisma.clientContact.findMany()
     * 
     * // Get first 10 ClientContacts
     * const clientContacts = await prisma.clientContact.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const clientContactWithIdOnly = await prisma.clientContact.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ClientContactFindManyArgs>(
      args?: SelectSubset<T, ClientContactFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ClientContact>>, PrismaPromise<Array<ClientContactGetPayload<T>>>>

    /**
     * Create a ClientContact.
     * @param {ClientContactCreateArgs} args - Arguments to create a ClientContact.
     * @example
     * // Create one ClientContact
     * const ClientContact = await prisma.clientContact.create({
     *   data: {
     *     // ... data to create a ClientContact
     *   }
     * })
     * 
    **/
    create<T extends ClientContactCreateArgs>(
      args: SelectSubset<T, ClientContactCreateArgs>
    ): CheckSelect<T, Prisma__ClientContactClient<ClientContact>, Prisma__ClientContactClient<ClientContactGetPayload<T>>>

    /**
     * Create many ClientContacts.
     *     @param {ClientContactCreateManyArgs} args - Arguments to create many ClientContacts.
     *     @example
     *     // Create many ClientContacts
     *     const clientContact = await prisma.clientContact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientContactCreateManyArgs>(
      args?: SelectSubset<T, ClientContactCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContact.
     * @param {ClientContactDeleteArgs} args - Arguments to delete one ClientContact.
     * @example
     * // Delete one ClientContact
     * const ClientContact = await prisma.clientContact.delete({
     *   where: {
     *     // ... filter to delete one ClientContact
     *   }
     * })
     * 
    **/
    delete<T extends ClientContactDeleteArgs>(
      args: SelectSubset<T, ClientContactDeleteArgs>
    ): CheckSelect<T, Prisma__ClientContactClient<ClientContact>, Prisma__ClientContactClient<ClientContactGetPayload<T>>>

    /**
     * Update one ClientContact.
     * @param {ClientContactUpdateArgs} args - Arguments to update one ClientContact.
     * @example
     * // Update one ClientContact
     * const clientContact = await prisma.clientContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientContactUpdateArgs>(
      args: SelectSubset<T, ClientContactUpdateArgs>
    ): CheckSelect<T, Prisma__ClientContactClient<ClientContact>, Prisma__ClientContactClient<ClientContactGetPayload<T>>>

    /**
     * Delete zero or more ClientContacts.
     * @param {ClientContactDeleteManyArgs} args - Arguments to filter ClientContacts to delete.
     * @example
     * // Delete a few ClientContacts
     * const { count } = await prisma.clientContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientContactDeleteManyArgs>(
      args?: SelectSubset<T, ClientContactDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContacts
     * const clientContact = await prisma.clientContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientContactUpdateManyArgs>(
      args: SelectSubset<T, ClientContactUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContact.
     * @param {ClientContactUpsertArgs} args - Arguments to update or create a ClientContact.
     * @example
     * // Update or create a ClientContact
     * const clientContact = await prisma.clientContact.upsert({
     *   create: {
     *     // ... data to create a ClientContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContact we want to update
     *   }
     * })
    **/
    upsert<T extends ClientContactUpsertArgs>(
      args: SelectSubset<T, ClientContactUpsertArgs>
    ): CheckSelect<T, Prisma__ClientContactClient<ClientContact>, Prisma__ClientContactClient<ClientContactGetPayload<T>>>

    /**
     * Count the number of ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactCountArgs} args - Arguments to filter ClientContacts to count.
     * @example
     * // Count the number of ClientContacts
     * const count = await prisma.clientContact.count({
     *   where: {
     *     // ... the filter for the ClientContacts we want to count
     *   }
     * })
    **/
    count<T extends ClientContactCountArgs>(
      args?: Subset<T, ClientContactCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContactAggregateArgs>(args: Subset<T, ClientContactAggregateArgs>): PrismaPromise<GetClientContactAggregateType<T>>

    /**
     * Group by ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContactGroupByArgs['orderBy'] }
        : { orderBy?: ClientContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContactGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientContactClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Client<T extends ClientArgs = {}>(args?: Subset<T, ClientArgs>): CheckSelect<T, Prisma__ClientClient<Client | null >, Prisma__ClientClient<ClientGetPayload<T> | null >>;

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ClientContact findUnique
   */
  export type ClientContactFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
    /**
     * Throw an Error if a ClientContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ClientContact to fetch.
     * 
    **/
    where: ClientContactWhereUniqueInput
  }


  /**
   * ClientContact findFirst
   */
  export type ClientContactFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
    /**
     * Throw an Error if a ClientContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ClientContact to fetch.
     * 
    **/
    where?: ClientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContacts.
     * 
    **/
    cursor?: ClientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContacts.
     * 
    **/
    distinct?: Enumerable<ClientContactScalarFieldEnum>
  }


  /**
   * ClientContact findMany
   */
  export type ClientContactFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
    /**
     * Filter, which ClientContacts to fetch.
     * 
    **/
    where?: ClientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContacts.
     * 
    **/
    cursor?: ClientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientContactScalarFieldEnum>
  }


  /**
   * ClientContact create
   */
  export type ClientContactCreateArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
    /**
     * The data needed to create a ClientContact.
     * 
    **/
    data: XOR<ClientContactCreateInput, ClientContactUncheckedCreateInput>
  }


  /**
   * ClientContact createMany
   */
  export type ClientContactCreateManyArgs = {
    data: Enumerable<ClientContactCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ClientContact update
   */
  export type ClientContactUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
    /**
     * The data needed to update a ClientContact.
     * 
    **/
    data: XOR<ClientContactUpdateInput, ClientContactUncheckedUpdateInput>
    /**
     * Choose, which ClientContact to update.
     * 
    **/
    where: ClientContactWhereUniqueInput
  }


  /**
   * ClientContact updateMany
   */
  export type ClientContactUpdateManyArgs = {
    data: XOR<ClientContactUpdateManyMutationInput, ClientContactUncheckedUpdateManyInput>
    where?: ClientContactWhereInput
  }


  /**
   * ClientContact upsert
   */
  export type ClientContactUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
    /**
     * The filter to search for the ClientContact to update in case it exists.
     * 
    **/
    where: ClientContactWhereUniqueInput
    /**
     * In case the ClientContact found by the `where` argument doesn't exist, create a new ClientContact with this data.
     * 
    **/
    create: XOR<ClientContactCreateInput, ClientContactUncheckedCreateInput>
    /**
     * In case the ClientContact was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClientContactUpdateInput, ClientContactUncheckedUpdateInput>
  }


  /**
   * ClientContact delete
   */
  export type ClientContactDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
    /**
     * Filter which ClientContact to delete.
     * 
    **/
    where: ClientContactWhereUniqueInput
  }


  /**
   * ClientContact deleteMany
   */
  export type ClientContactDeleteManyArgs = {
    where?: ClientContactWhereInput
  }


  /**
   * ClientContact without action
   */
  export type ClientContactArgs = {
    /**
     * Select specific fields to fetch from the ClientContact
     * 
    **/
    select?: ClientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientContactInclude | null
  }



  /**
   * Model CodeProject
   */


  export type AggregateCodeProject = {
    _count: CodeProjectCountAggregateOutputType | null
    count: CodeProjectCountAggregateOutputType | null
    _avg: CodeProjectAvgAggregateOutputType | null
    avg: CodeProjectAvgAggregateOutputType | null
    _sum: CodeProjectSumAggregateOutputType | null
    sum: CodeProjectSumAggregateOutputType | null
    _min: CodeProjectMinAggregateOutputType | null
    min: CodeProjectMinAggregateOutputType | null
    _max: CodeProjectMaxAggregateOutputType | null
    max: CodeProjectMaxAggregateOutputType | null
  }

  export type CodeProjectAvgAggregateOutputType = {
    Id: number | null
    ClientId: number | null
    CreatedBy: number | null
    ConfirmedBy: number | null
    CompletedBy: number | null
  }

  export type CodeProjectSumAggregateOutputType = {
    Id: number | null
    ClientId: number | null
    CreatedBy: number | null
    ConfirmedBy: number | null
    CompletedBy: number | null
  }

  export type CodeProjectMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    ClientId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ConfirmedDate: Date | null
    ConfirmedBy: number | null
    Address: string | null
    DocumentName: string | null
    IsCompleted: boolean | null
    CompletedDate: Date | null
    CompletedBy: number | null
    IsDelete: boolean | null
  }

  export type CodeProjectMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    ClientId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ConfirmedDate: Date | null
    ConfirmedBy: number | null
    Address: string | null
    DocumentName: string | null
    IsCompleted: boolean | null
    CompletedDate: Date | null
    CompletedBy: number | null
    IsDelete: boolean | null
  }

  export type CodeProjectCountAggregateOutputType = {
    Id: number
    Name: number
    ClientId: number
    CreatedBy: number
    CreatedDate: number
    ConfirmedDate: number
    ConfirmedBy: number
    Address: number
    DocumentName: number
    IsCompleted: number
    CompletedDate: number
    CompletedBy: number
    IsDelete: number
    _all: number
  }


  export type CodeProjectAvgAggregateInputType = {
    Id?: true
    ClientId?: true
    CreatedBy?: true
    ConfirmedBy?: true
    CompletedBy?: true
  }

  export type CodeProjectSumAggregateInputType = {
    Id?: true
    ClientId?: true
    CreatedBy?: true
    ConfirmedBy?: true
    CompletedBy?: true
  }

  export type CodeProjectMinAggregateInputType = {
    Id?: true
    Name?: true
    ClientId?: true
    CreatedBy?: true
    CreatedDate?: true
    ConfirmedDate?: true
    ConfirmedBy?: true
    Address?: true
    DocumentName?: true
    IsCompleted?: true
    CompletedDate?: true
    CompletedBy?: true
    IsDelete?: true
  }

  export type CodeProjectMaxAggregateInputType = {
    Id?: true
    Name?: true
    ClientId?: true
    CreatedBy?: true
    CreatedDate?: true
    ConfirmedDate?: true
    ConfirmedBy?: true
    Address?: true
    DocumentName?: true
    IsCompleted?: true
    CompletedDate?: true
    CompletedBy?: true
    IsDelete?: true
  }

  export type CodeProjectCountAggregateInputType = {
    Id?: true
    Name?: true
    ClientId?: true
    CreatedBy?: true
    CreatedDate?: true
    ConfirmedDate?: true
    ConfirmedBy?: true
    Address?: true
    DocumentName?: true
    IsCompleted?: true
    CompletedDate?: true
    CompletedBy?: true
    IsDelete?: true
    _all?: true
  }

  export type CodeProjectAggregateArgs = {
    /**
     * Filter which CodeProject to aggregate.
     * 
    **/
    where?: CodeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjects to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CodeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeProjects
    **/
    _count?: true | CodeProjectCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeProjectAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeProjectSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeProjectMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeProjectMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeProjectMaxAggregateInputType
  }

  export type GetCodeProjectAggregateType<T extends CodeProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeProject[P]>
      : GetScalarType<T[P], AggregateCodeProject[P]>
  }


    
    
  export type CodeProjectGroupByArgs = {
    where?: CodeProjectWhereInput
    orderBy?: Enumerable<CodeProjectOrderByInput>
    by: Array<CodeProjectScalarFieldEnum>
    having?: CodeProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeProjectCountAggregateInputType | true
    _avg?: CodeProjectAvgAggregateInputType
    _sum?: CodeProjectSumAggregateInputType
    _min?: CodeProjectMinAggregateInputType
    _max?: CodeProjectMaxAggregateInputType
  }


  export type CodeProjectGroupByOutputType = {
    Id: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate: Date
    ConfirmedDate: Date | null
    ConfirmedBy: number | null
    Address: string
    DocumentName: string
    IsCompleted: boolean
    CompletedDate: Date | null
    CompletedBy: number | null
    IsDelete: boolean
    _count: CodeProjectCountAggregateOutputType | null
    _avg: CodeProjectAvgAggregateOutputType | null
    _sum: CodeProjectSumAggregateOutputType | null
    _min: CodeProjectMinAggregateOutputType | null
    _max: CodeProjectMaxAggregateOutputType | null
  }

  type GetCodeProjectGroupByPayload<T extends CodeProjectGroupByArgs> = Promise<
    Array<
      PickArray<CodeProjectGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeProjectGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeProjectGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeProjectGroupByOutputType[P]>
        }
      > 
    >


  export type CodeProjectSelect = {
    Id?: boolean
    Name?: boolean
    ClientId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    ConfirmedDate?: boolean
    ConfirmedBy?: boolean
    Address?: boolean
    DocumentName?: boolean
    IsCompleted?: boolean
    CompletedDate?: boolean
    CompletedBy?: boolean
    IsDelete?: boolean
    Client?: boolean | ClientArgs
    User1?: boolean | UserArgs
    User2?: boolean | UserArgs
    User3?: boolean | UserArgs
    CodeProjectDocument?: boolean | CodeProjectDocumentFindManyArgs
    CodeProjectUser?: boolean | CodeProjectUserFindManyArgs
    CodeReport?: boolean | CodeReportFindManyArgs
    Project?: boolean | ProjectFindManyArgs
  }

  export type CodeProjectInclude = {
    Client?: boolean | ClientArgs
    User1?: boolean | UserArgs
    User2?: boolean | UserArgs
    User3?: boolean | UserArgs
    CodeProjectDocument?: boolean | CodeProjectDocumentFindManyArgs
    CodeProjectUser?: boolean | CodeProjectUserFindManyArgs
    CodeReport?: boolean | CodeReportFindManyArgs
    Project?: boolean | ProjectFindManyArgs
  }

  export type CodeProjectGetPayload<
    S extends boolean | null | undefined | CodeProjectArgs,
    U = keyof S
      > = S extends true
        ? CodeProject
    : S extends undefined
    ? never
    : S extends CodeProjectArgs | CodeProjectFindManyArgs
    ?'include' extends U
    ? CodeProject  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Client'
        ? ClientGetPayload<S['include'][P]> :
        P extends 'User1'
        ? UserGetPayload<S['include'][P]> :
        P extends 'User2'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'User3'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'CodeProjectDocument'
        ? Array < CodeProjectDocumentGetPayload<S['include'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < CodeProjectUserGetPayload<S['include'][P]>>  :
        P extends 'CodeReport'
        ? Array < CodeReportGetPayload<S['include'][P]>>  :
        P extends 'Project'
        ? Array < ProjectGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CodeProject ?CodeProject [P]
  : 
          P extends 'Client'
        ? ClientGetPayload<S['select'][P]> :
        P extends 'User1'
        ? UserGetPayload<S['select'][P]> :
        P extends 'User2'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'User3'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'CodeProjectDocument'
        ? Array < CodeProjectDocumentGetPayload<S['select'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < CodeProjectUserGetPayload<S['select'][P]>>  :
        P extends 'CodeReport'
        ? Array < CodeReportGetPayload<S['select'][P]>>  :
        P extends 'Project'
        ? Array < ProjectGetPayload<S['select'][P]>>  : never
  } 
    : CodeProject
  : CodeProject


  type CodeProjectCountArgs = Merge<
    Omit<CodeProjectFindManyArgs, 'select' | 'include'> & {
      select?: CodeProjectCountAggregateInputType | true
    }
  >

  export interface CodeProjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeProject that matches the filter.
     * @param {CodeProjectFindUniqueArgs} args - Arguments to find a CodeProject
     * @example
     * // Get one CodeProject
     * const codeProject = await prisma.codeProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeProject'> extends True ? CheckSelect<T, Prisma__CodeProjectClient<CodeProject>, Prisma__CodeProjectClient<CodeProjectGetPayload<T>>> : CheckSelect<T, Prisma__CodeProjectClient<CodeProject | null >, Prisma__CodeProjectClient<CodeProjectGetPayload<T> | null >>

    /**
     * Find the first CodeProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectFindFirstArgs} args - Arguments to find a CodeProject
     * @example
     * // Get one CodeProject
     * const codeProject = await prisma.codeProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeProject'> extends True ? CheckSelect<T, Prisma__CodeProjectClient<CodeProject>, Prisma__CodeProjectClient<CodeProjectGetPayload<T>>> : CheckSelect<T, Prisma__CodeProjectClient<CodeProject | null >, Prisma__CodeProjectClient<CodeProjectGetPayload<T> | null >>

    /**
     * Find zero or more CodeProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeProjects
     * const codeProjects = await prisma.codeProject.findMany()
     * 
     * // Get first 10 CodeProjects
     * const codeProjects = await prisma.codeProject.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeProjectWithIdOnly = await prisma.codeProject.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends CodeProjectFindManyArgs>(
      args?: SelectSubset<T, CodeProjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CodeProject>>, PrismaPromise<Array<CodeProjectGetPayload<T>>>>

    /**
     * Create a CodeProject.
     * @param {CodeProjectCreateArgs} args - Arguments to create a CodeProject.
     * @example
     * // Create one CodeProject
     * const CodeProject = await prisma.codeProject.create({
     *   data: {
     *     // ... data to create a CodeProject
     *   }
     * })
     * 
    **/
    create<T extends CodeProjectCreateArgs>(
      args: SelectSubset<T, CodeProjectCreateArgs>
    ): CheckSelect<T, Prisma__CodeProjectClient<CodeProject>, Prisma__CodeProjectClient<CodeProjectGetPayload<T>>>

    /**
     * Create many CodeProjects.
     *     @param {CodeProjectCreateManyArgs} args - Arguments to create many CodeProjects.
     *     @example
     *     // Create many CodeProjects
     *     const codeProject = await prisma.codeProject.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeProjectCreateManyArgs>(
      args?: SelectSubset<T, CodeProjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeProject.
     * @param {CodeProjectDeleteArgs} args - Arguments to delete one CodeProject.
     * @example
     * // Delete one CodeProject
     * const CodeProject = await prisma.codeProject.delete({
     *   where: {
     *     // ... filter to delete one CodeProject
     *   }
     * })
     * 
    **/
    delete<T extends CodeProjectDeleteArgs>(
      args: SelectSubset<T, CodeProjectDeleteArgs>
    ): CheckSelect<T, Prisma__CodeProjectClient<CodeProject>, Prisma__CodeProjectClient<CodeProjectGetPayload<T>>>

    /**
     * Update one CodeProject.
     * @param {CodeProjectUpdateArgs} args - Arguments to update one CodeProject.
     * @example
     * // Update one CodeProject
     * const codeProject = await prisma.codeProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeProjectUpdateArgs>(
      args: SelectSubset<T, CodeProjectUpdateArgs>
    ): CheckSelect<T, Prisma__CodeProjectClient<CodeProject>, Prisma__CodeProjectClient<CodeProjectGetPayload<T>>>

    /**
     * Delete zero or more CodeProjects.
     * @param {CodeProjectDeleteManyArgs} args - Arguments to filter CodeProjects to delete.
     * @example
     * // Delete a few CodeProjects
     * const { count } = await prisma.codeProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeProjectDeleteManyArgs>(
      args?: SelectSubset<T, CodeProjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeProjects
     * const codeProject = await prisma.codeProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeProjectUpdateManyArgs>(
      args: SelectSubset<T, CodeProjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeProject.
     * @param {CodeProjectUpsertArgs} args - Arguments to update or create a CodeProject.
     * @example
     * // Update or create a CodeProject
     * const codeProject = await prisma.codeProject.upsert({
     *   create: {
     *     // ... data to create a CodeProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeProject we want to update
     *   }
     * })
    **/
    upsert<T extends CodeProjectUpsertArgs>(
      args: SelectSubset<T, CodeProjectUpsertArgs>
    ): CheckSelect<T, Prisma__CodeProjectClient<CodeProject>, Prisma__CodeProjectClient<CodeProjectGetPayload<T>>>

    /**
     * Count the number of CodeProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectCountArgs} args - Arguments to filter CodeProjects to count.
     * @example
     * // Count the number of CodeProjects
     * const count = await prisma.codeProject.count({
     *   where: {
     *     // ... the filter for the CodeProjects we want to count
     *   }
     * })
    **/
    count<T extends CodeProjectCountArgs>(
      args?: Subset<T, CodeProjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeProjectAggregateArgs>(args: Subset<T, CodeProjectAggregateArgs>): PrismaPromise<GetCodeProjectAggregateType<T>>

    /**
     * Group by CodeProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeProjectGroupByArgs['orderBy'] }
        : { orderBy?: CodeProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeProjectGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeProjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Client<T extends ClientArgs = {}>(args?: Subset<T, ClientArgs>): CheckSelect<T, Prisma__ClientClient<Client | null >, Prisma__ClientClient<ClientGetPayload<T> | null >>;

    User1<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    User2<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    User3<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    CodeProjectDocument<T extends CodeProjectDocumentFindManyArgs = {}>(args?: Subset<T, CodeProjectDocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProjectDocument>>, PrismaPromise<Array<CodeProjectDocumentGetPayload<T>>>>;

    CodeProjectUser<T extends CodeProjectUserFindManyArgs = {}>(args?: Subset<T, CodeProjectUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProjectUser>>, PrismaPromise<Array<CodeProjectUserGetPayload<T>>>>;

    CodeReport<T extends CodeReportFindManyArgs = {}>(args?: Subset<T, CodeReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeReport>>, PrismaPromise<Array<CodeReportGetPayload<T>>>>;

    Project<T extends ProjectFindManyArgs = {}>(args?: Subset<T, ProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Project>>, PrismaPromise<Array<ProjectGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CodeProject findUnique
   */
  export type CodeProjectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
    /**
     * Throw an Error if a CodeProject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeProject to fetch.
     * 
    **/
    where: CodeProjectWhereUniqueInput
  }


  /**
   * CodeProject findFirst
   */
  export type CodeProjectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
    /**
     * Throw an Error if a CodeProject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeProject to fetch.
     * 
    **/
    where?: CodeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjects to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeProjects.
     * 
    **/
    cursor?: CodeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeProjects.
     * 
    **/
    distinct?: Enumerable<CodeProjectScalarFieldEnum>
  }


  /**
   * CodeProject findMany
   */
  export type CodeProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
    /**
     * Filter, which CodeProjects to fetch.
     * 
    **/
    where?: CodeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjects to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeProjects.
     * 
    **/
    cursor?: CodeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeProjectScalarFieldEnum>
  }


  /**
   * CodeProject create
   */
  export type CodeProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
    /**
     * The data needed to create a CodeProject.
     * 
    **/
    data: XOR<CodeProjectCreateInput, CodeProjectUncheckedCreateInput>
  }


  /**
   * CodeProject createMany
   */
  export type CodeProjectCreateManyArgs = {
    data: Enumerable<CodeProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodeProject update
   */
  export type CodeProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
    /**
     * The data needed to update a CodeProject.
     * 
    **/
    data: XOR<CodeProjectUpdateInput, CodeProjectUncheckedUpdateInput>
    /**
     * Choose, which CodeProject to update.
     * 
    **/
    where: CodeProjectWhereUniqueInput
  }


  /**
   * CodeProject updateMany
   */
  export type CodeProjectUpdateManyArgs = {
    data: XOR<CodeProjectUpdateManyMutationInput, CodeProjectUncheckedUpdateManyInput>
    where?: CodeProjectWhereInput
  }


  /**
   * CodeProject upsert
   */
  export type CodeProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
    /**
     * The filter to search for the CodeProject to update in case it exists.
     * 
    **/
    where: CodeProjectWhereUniqueInput
    /**
     * In case the CodeProject found by the `where` argument doesn't exist, create a new CodeProject with this data.
     * 
    **/
    create: XOR<CodeProjectCreateInput, CodeProjectUncheckedCreateInput>
    /**
     * In case the CodeProject was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CodeProjectUpdateInput, CodeProjectUncheckedUpdateInput>
  }


  /**
   * CodeProject delete
   */
  export type CodeProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
    /**
     * Filter which CodeProject to delete.
     * 
    **/
    where: CodeProjectWhereUniqueInput
  }


  /**
   * CodeProject deleteMany
   */
  export type CodeProjectDeleteManyArgs = {
    where?: CodeProjectWhereInput
  }


  /**
   * CodeProject without action
   */
  export type CodeProjectArgs = {
    /**
     * Select specific fields to fetch from the CodeProject
     * 
    **/
    select?: CodeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectInclude | null
  }



  /**
   * Model CodeProjectDocument
   */


  export type AggregateCodeProjectDocument = {
    _count: CodeProjectDocumentCountAggregateOutputType | null
    count: CodeProjectDocumentCountAggregateOutputType | null
    _avg: CodeProjectDocumentAvgAggregateOutputType | null
    avg: CodeProjectDocumentAvgAggregateOutputType | null
    _sum: CodeProjectDocumentSumAggregateOutputType | null
    sum: CodeProjectDocumentSumAggregateOutputType | null
    _min: CodeProjectDocumentMinAggregateOutputType | null
    min: CodeProjectDocumentMinAggregateOutputType | null
    _max: CodeProjectDocumentMaxAggregateOutputType | null
    max: CodeProjectDocumentMaxAggregateOutputType | null
  }

  export type CodeProjectDocumentAvgAggregateOutputType = {
    Id: number | null
    CodeProjectId: number | null
    CreatedBy: number | null
  }

  export type CodeProjectDocumentSumAggregateOutputType = {
    Id: number | null
    CodeProjectId: number | null
    CreatedBy: number | null
  }

  export type CodeProjectDocumentMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Url: string | null
    CodeProjectId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type CodeProjectDocumentMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Url: string | null
    CodeProjectId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type CodeProjectDocumentCountAggregateOutputType = {
    Id: number
    Name: number
    Url: number
    CodeProjectId: number
    CreatedBy: number
    CreatedDate: number
    _all: number
  }


  export type CodeProjectDocumentAvgAggregateInputType = {
    Id?: true
    CodeProjectId?: true
    CreatedBy?: true
  }

  export type CodeProjectDocumentSumAggregateInputType = {
    Id?: true
    CodeProjectId?: true
    CreatedBy?: true
  }

  export type CodeProjectDocumentMinAggregateInputType = {
    Id?: true
    Name?: true
    Url?: true
    CodeProjectId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type CodeProjectDocumentMaxAggregateInputType = {
    Id?: true
    Name?: true
    Url?: true
    CodeProjectId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type CodeProjectDocumentCountAggregateInputType = {
    Id?: true
    Name?: true
    Url?: true
    CodeProjectId?: true
    CreatedBy?: true
    CreatedDate?: true
    _all?: true
  }

  export type CodeProjectDocumentAggregateArgs = {
    /**
     * Filter which CodeProjectDocument to aggregate.
     * 
    **/
    where?: CodeProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjectDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CodeProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjectDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjectDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeProjectDocuments
    **/
    _count?: true | CodeProjectDocumentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeProjectDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeProjectDocumentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeProjectDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeProjectDocumentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeProjectDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeProjectDocumentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeProjectDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeProjectDocumentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeProjectDocumentMaxAggregateInputType
  }

  export type GetCodeProjectDocumentAggregateType<T extends CodeProjectDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeProjectDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeProjectDocument[P]>
      : GetScalarType<T[P], AggregateCodeProjectDocument[P]>
  }


    
    
  export type CodeProjectDocumentGroupByArgs = {
    where?: CodeProjectDocumentWhereInput
    orderBy?: Enumerable<CodeProjectDocumentOrderByInput>
    by: Array<CodeProjectDocumentScalarFieldEnum>
    having?: CodeProjectDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeProjectDocumentCountAggregateInputType | true
    _avg?: CodeProjectDocumentAvgAggregateInputType
    _sum?: CodeProjectDocumentSumAggregateInputType
    _min?: CodeProjectDocumentMinAggregateInputType
    _max?: CodeProjectDocumentMaxAggregateInputType
  }


  export type CodeProjectDocumentGroupByOutputType = {
    Id: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedBy: number
    CreatedDate: Date
    _count: CodeProjectDocumentCountAggregateOutputType | null
    _avg: CodeProjectDocumentAvgAggregateOutputType | null
    _sum: CodeProjectDocumentSumAggregateOutputType | null
    _min: CodeProjectDocumentMinAggregateOutputType | null
    _max: CodeProjectDocumentMaxAggregateOutputType | null
  }

  type GetCodeProjectDocumentGroupByPayload<T extends CodeProjectDocumentGroupByArgs> = Promise<
    Array<
      PickArray<CodeProjectDocumentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeProjectDocumentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeProjectDocumentGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeProjectDocumentGroupByOutputType[P]>
        }
      > 
    >


  export type CodeProjectDocumentSelect = {
    Id?: boolean
    Name?: boolean
    Url?: boolean
    CodeProjectId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    User?: boolean | UserArgs
    CodeProject?: boolean | CodeProjectArgs
  }

  export type CodeProjectDocumentInclude = {
    User?: boolean | UserArgs
    CodeProject?: boolean | CodeProjectArgs
  }

  export type CodeProjectDocumentGetPayload<
    S extends boolean | null | undefined | CodeProjectDocumentArgs,
    U = keyof S
      > = S extends true
        ? CodeProjectDocument
    : S extends undefined
    ? never
    : S extends CodeProjectDocumentArgs | CodeProjectDocumentFindManyArgs
    ?'include' extends U
    ? CodeProjectDocument  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> :
        P extends 'CodeProject'
        ? CodeProjectGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CodeProjectDocument ?CodeProjectDocument [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> :
        P extends 'CodeProject'
        ? CodeProjectGetPayload<S['select'][P]> : never
  } 
    : CodeProjectDocument
  : CodeProjectDocument


  type CodeProjectDocumentCountArgs = Merge<
    Omit<CodeProjectDocumentFindManyArgs, 'select' | 'include'> & {
      select?: CodeProjectDocumentCountAggregateInputType | true
    }
  >

  export interface CodeProjectDocumentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeProjectDocument that matches the filter.
     * @param {CodeProjectDocumentFindUniqueArgs} args - Arguments to find a CodeProjectDocument
     * @example
     * // Get one CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeProjectDocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeProjectDocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeProjectDocument'> extends True ? CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument>, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T>>> : CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument | null >, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T> | null >>

    /**
     * Find the first CodeProjectDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentFindFirstArgs} args - Arguments to find a CodeProjectDocument
     * @example
     * // Get one CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeProjectDocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeProjectDocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeProjectDocument'> extends True ? CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument>, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T>>> : CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument | null >, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T> | null >>

    /**
     * Find zero or more CodeProjectDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeProjectDocuments
     * const codeProjectDocuments = await prisma.codeProjectDocument.findMany()
     * 
     * // Get first 10 CodeProjectDocuments
     * const codeProjectDocuments = await prisma.codeProjectDocument.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeProjectDocumentWithIdOnly = await prisma.codeProjectDocument.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends CodeProjectDocumentFindManyArgs>(
      args?: SelectSubset<T, CodeProjectDocumentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CodeProjectDocument>>, PrismaPromise<Array<CodeProjectDocumentGetPayload<T>>>>

    /**
     * Create a CodeProjectDocument.
     * @param {CodeProjectDocumentCreateArgs} args - Arguments to create a CodeProjectDocument.
     * @example
     * // Create one CodeProjectDocument
     * const CodeProjectDocument = await prisma.codeProjectDocument.create({
     *   data: {
     *     // ... data to create a CodeProjectDocument
     *   }
     * })
     * 
    **/
    create<T extends CodeProjectDocumentCreateArgs>(
      args: SelectSubset<T, CodeProjectDocumentCreateArgs>
    ): CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument>, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T>>>

    /**
     * Create many CodeProjectDocuments.
     *     @param {CodeProjectDocumentCreateManyArgs} args - Arguments to create many CodeProjectDocuments.
     *     @example
     *     // Create many CodeProjectDocuments
     *     const codeProjectDocument = await prisma.codeProjectDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeProjectDocumentCreateManyArgs>(
      args?: SelectSubset<T, CodeProjectDocumentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeProjectDocument.
     * @param {CodeProjectDocumentDeleteArgs} args - Arguments to delete one CodeProjectDocument.
     * @example
     * // Delete one CodeProjectDocument
     * const CodeProjectDocument = await prisma.codeProjectDocument.delete({
     *   where: {
     *     // ... filter to delete one CodeProjectDocument
     *   }
     * })
     * 
    **/
    delete<T extends CodeProjectDocumentDeleteArgs>(
      args: SelectSubset<T, CodeProjectDocumentDeleteArgs>
    ): CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument>, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T>>>

    /**
     * Update one CodeProjectDocument.
     * @param {CodeProjectDocumentUpdateArgs} args - Arguments to update one CodeProjectDocument.
     * @example
     * // Update one CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeProjectDocumentUpdateArgs>(
      args: SelectSubset<T, CodeProjectDocumentUpdateArgs>
    ): CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument>, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T>>>

    /**
     * Delete zero or more CodeProjectDocuments.
     * @param {CodeProjectDocumentDeleteManyArgs} args - Arguments to filter CodeProjectDocuments to delete.
     * @example
     * // Delete a few CodeProjectDocuments
     * const { count } = await prisma.codeProjectDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeProjectDocumentDeleteManyArgs>(
      args?: SelectSubset<T, CodeProjectDocumentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeProjectDocuments
     * const codeProjectDocument = await prisma.codeProjectDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeProjectDocumentUpdateManyArgs>(
      args: SelectSubset<T, CodeProjectDocumentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeProjectDocument.
     * @param {CodeProjectDocumentUpsertArgs} args - Arguments to update or create a CodeProjectDocument.
     * @example
     * // Update or create a CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.upsert({
     *   create: {
     *     // ... data to create a CodeProjectDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeProjectDocument we want to update
     *   }
     * })
    **/
    upsert<T extends CodeProjectDocumentUpsertArgs>(
      args: SelectSubset<T, CodeProjectDocumentUpsertArgs>
    ): CheckSelect<T, Prisma__CodeProjectDocumentClient<CodeProjectDocument>, Prisma__CodeProjectDocumentClient<CodeProjectDocumentGetPayload<T>>>

    /**
     * Count the number of CodeProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentCountArgs} args - Arguments to filter CodeProjectDocuments to count.
     * @example
     * // Count the number of CodeProjectDocuments
     * const count = await prisma.codeProjectDocument.count({
     *   where: {
     *     // ... the filter for the CodeProjectDocuments we want to count
     *   }
     * })
    **/
    count<T extends CodeProjectDocumentCountArgs>(
      args?: Subset<T, CodeProjectDocumentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeProjectDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeProjectDocumentAggregateArgs>(args: Subset<T, CodeProjectDocumentAggregateArgs>): PrismaPromise<GetCodeProjectDocumentAggregateType<T>>

    /**
     * Group by CodeProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeProjectDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeProjectDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CodeProjectDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeProjectDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeProjectDocumentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeProjectDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeProjectDocumentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    CodeProject<T extends CodeProjectArgs = {}>(args?: Subset<T, CodeProjectArgs>): CheckSelect<T, Prisma__CodeProjectClient<CodeProject | null >, Prisma__CodeProjectClient<CodeProjectGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CodeProjectDocument findUnique
   */
  export type CodeProjectDocumentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
    /**
     * Throw an Error if a CodeProjectDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeProjectDocument to fetch.
     * 
    **/
    where: CodeProjectDocumentWhereUniqueInput
  }


  /**
   * CodeProjectDocument findFirst
   */
  export type CodeProjectDocumentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
    /**
     * Throw an Error if a CodeProjectDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeProjectDocument to fetch.
     * 
    **/
    where?: CodeProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjectDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeProjectDocuments.
     * 
    **/
    cursor?: CodeProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjectDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjectDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeProjectDocuments.
     * 
    **/
    distinct?: Enumerable<CodeProjectDocumentScalarFieldEnum>
  }


  /**
   * CodeProjectDocument findMany
   */
  export type CodeProjectDocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
    /**
     * Filter, which CodeProjectDocuments to fetch.
     * 
    **/
    where?: CodeProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjectDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeProjectDocuments.
     * 
    **/
    cursor?: CodeProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjectDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjectDocuments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeProjectDocumentScalarFieldEnum>
  }


  /**
   * CodeProjectDocument create
   */
  export type CodeProjectDocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
    /**
     * The data needed to create a CodeProjectDocument.
     * 
    **/
    data: XOR<CodeProjectDocumentCreateInput, CodeProjectDocumentUncheckedCreateInput>
  }


  /**
   * CodeProjectDocument createMany
   */
  export type CodeProjectDocumentCreateManyArgs = {
    data: Enumerable<CodeProjectDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodeProjectDocument update
   */
  export type CodeProjectDocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
    /**
     * The data needed to update a CodeProjectDocument.
     * 
    **/
    data: XOR<CodeProjectDocumentUpdateInput, CodeProjectDocumentUncheckedUpdateInput>
    /**
     * Choose, which CodeProjectDocument to update.
     * 
    **/
    where: CodeProjectDocumentWhereUniqueInput
  }


  /**
   * CodeProjectDocument updateMany
   */
  export type CodeProjectDocumentUpdateManyArgs = {
    data: XOR<CodeProjectDocumentUpdateManyMutationInput, CodeProjectDocumentUncheckedUpdateManyInput>
    where?: CodeProjectDocumentWhereInput
  }


  /**
   * CodeProjectDocument upsert
   */
  export type CodeProjectDocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
    /**
     * The filter to search for the CodeProjectDocument to update in case it exists.
     * 
    **/
    where: CodeProjectDocumentWhereUniqueInput
    /**
     * In case the CodeProjectDocument found by the `where` argument doesn't exist, create a new CodeProjectDocument with this data.
     * 
    **/
    create: XOR<CodeProjectDocumentCreateInput, CodeProjectDocumentUncheckedCreateInput>
    /**
     * In case the CodeProjectDocument was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CodeProjectDocumentUpdateInput, CodeProjectDocumentUncheckedUpdateInput>
  }


  /**
   * CodeProjectDocument delete
   */
  export type CodeProjectDocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
    /**
     * Filter which CodeProjectDocument to delete.
     * 
    **/
    where: CodeProjectDocumentWhereUniqueInput
  }


  /**
   * CodeProjectDocument deleteMany
   */
  export type CodeProjectDocumentDeleteManyArgs = {
    where?: CodeProjectDocumentWhereInput
  }


  /**
   * CodeProjectDocument without action
   */
  export type CodeProjectDocumentArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectDocument
     * 
    **/
    select?: CodeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectDocumentInclude | null
  }



  /**
   * Model CodeProjectUser
   */


  export type AggregateCodeProjectUser = {
    _count: CodeProjectUserCountAggregateOutputType | null
    count: CodeProjectUserCountAggregateOutputType | null
    _avg: CodeProjectUserAvgAggregateOutputType | null
    avg: CodeProjectUserAvgAggregateOutputType | null
    _sum: CodeProjectUserSumAggregateOutputType | null
    sum: CodeProjectUserSumAggregateOutputType | null
    _min: CodeProjectUserMinAggregateOutputType | null
    min: CodeProjectUserMinAggregateOutputType | null
    _max: CodeProjectUserMaxAggregateOutputType | null
    max: CodeProjectUserMaxAggregateOutputType | null
  }

  export type CodeProjectUserAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserMinAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserMaxAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserCountAggregateOutputType = {
    Id: number
    UserId: number
    CodeProjectId: number
    _all: number
  }


  export type CodeProjectUserAvgAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserSumAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserMinAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserMaxAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserCountAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
    _all?: true
  }

  export type CodeProjectUserAggregateArgs = {
    /**
     * Filter which CodeProjectUser to aggregate.
     * 
    **/
    where?: CodeProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjectUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CodeProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjectUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjectUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeProjectUsers
    **/
    _count?: true | CodeProjectUserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeProjectUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeProjectUserAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeProjectUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeProjectUserSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeProjectUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeProjectUserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeProjectUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeProjectUserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeProjectUserMaxAggregateInputType
  }

  export type GetCodeProjectUserAggregateType<T extends CodeProjectUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeProjectUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeProjectUser[P]>
      : GetScalarType<T[P], AggregateCodeProjectUser[P]>
  }


    
    
  export type CodeProjectUserGroupByArgs = {
    where?: CodeProjectUserWhereInput
    orderBy?: Enumerable<CodeProjectUserOrderByInput>
    by: Array<CodeProjectUserScalarFieldEnum>
    having?: CodeProjectUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeProjectUserCountAggregateInputType | true
    _avg?: CodeProjectUserAvgAggregateInputType
    _sum?: CodeProjectUserSumAggregateInputType
    _min?: CodeProjectUserMinAggregateInputType
    _max?: CodeProjectUserMaxAggregateInputType
  }


  export type CodeProjectUserGroupByOutputType = {
    Id: number
    UserId: number
    CodeProjectId: number
    _count: CodeProjectUserCountAggregateOutputType | null
    _avg: CodeProjectUserAvgAggregateOutputType | null
    _sum: CodeProjectUserSumAggregateOutputType | null
    _min: CodeProjectUserMinAggregateOutputType | null
    _max: CodeProjectUserMaxAggregateOutputType | null
  }

  type GetCodeProjectUserGroupByPayload<T extends CodeProjectUserGroupByArgs> = Promise<
    Array<
      PickArray<CodeProjectUserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeProjectUserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeProjectUserGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeProjectUserGroupByOutputType[P]>
        }
      > 
    >


  export type CodeProjectUserSelect = {
    Id?: boolean
    UserId?: boolean
    CodeProjectId?: boolean
    User?: boolean | UserArgs
    CodeProject?: boolean | CodeProjectArgs
  }

  export type CodeProjectUserInclude = {
    User?: boolean | UserArgs
    CodeProject?: boolean | CodeProjectArgs
  }

  export type CodeProjectUserGetPayload<
    S extends boolean | null | undefined | CodeProjectUserArgs,
    U = keyof S
      > = S extends true
        ? CodeProjectUser
    : S extends undefined
    ? never
    : S extends CodeProjectUserArgs | CodeProjectUserFindManyArgs
    ?'include' extends U
    ? CodeProjectUser  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> :
        P extends 'CodeProject'
        ? CodeProjectGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CodeProjectUser ?CodeProjectUser [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> :
        P extends 'CodeProject'
        ? CodeProjectGetPayload<S['select'][P]> : never
  } 
    : CodeProjectUser
  : CodeProjectUser


  type CodeProjectUserCountArgs = Merge<
    Omit<CodeProjectUserFindManyArgs, 'select' | 'include'> & {
      select?: CodeProjectUserCountAggregateInputType | true
    }
  >

  export interface CodeProjectUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeProjectUser that matches the filter.
     * @param {CodeProjectUserFindUniqueArgs} args - Arguments to find a CodeProjectUser
     * @example
     * // Get one CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeProjectUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeProjectUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeProjectUser'> extends True ? CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser>, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T>>> : CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser | null >, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T> | null >>

    /**
     * Find the first CodeProjectUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserFindFirstArgs} args - Arguments to find a CodeProjectUser
     * @example
     * // Get one CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeProjectUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeProjectUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeProjectUser'> extends True ? CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser>, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T>>> : CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser | null >, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T> | null >>

    /**
     * Find zero or more CodeProjectUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeProjectUsers
     * const codeProjectUsers = await prisma.codeProjectUser.findMany()
     * 
     * // Get first 10 CodeProjectUsers
     * const codeProjectUsers = await prisma.codeProjectUser.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeProjectUserWithIdOnly = await prisma.codeProjectUser.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends CodeProjectUserFindManyArgs>(
      args?: SelectSubset<T, CodeProjectUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CodeProjectUser>>, PrismaPromise<Array<CodeProjectUserGetPayload<T>>>>

    /**
     * Create a CodeProjectUser.
     * @param {CodeProjectUserCreateArgs} args - Arguments to create a CodeProjectUser.
     * @example
     * // Create one CodeProjectUser
     * const CodeProjectUser = await prisma.codeProjectUser.create({
     *   data: {
     *     // ... data to create a CodeProjectUser
     *   }
     * })
     * 
    **/
    create<T extends CodeProjectUserCreateArgs>(
      args: SelectSubset<T, CodeProjectUserCreateArgs>
    ): CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser>, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T>>>

    /**
     * Create many CodeProjectUsers.
     *     @param {CodeProjectUserCreateManyArgs} args - Arguments to create many CodeProjectUsers.
     *     @example
     *     // Create many CodeProjectUsers
     *     const codeProjectUser = await prisma.codeProjectUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeProjectUserCreateManyArgs>(
      args?: SelectSubset<T, CodeProjectUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeProjectUser.
     * @param {CodeProjectUserDeleteArgs} args - Arguments to delete one CodeProjectUser.
     * @example
     * // Delete one CodeProjectUser
     * const CodeProjectUser = await prisma.codeProjectUser.delete({
     *   where: {
     *     // ... filter to delete one CodeProjectUser
     *   }
     * })
     * 
    **/
    delete<T extends CodeProjectUserDeleteArgs>(
      args: SelectSubset<T, CodeProjectUserDeleteArgs>
    ): CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser>, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T>>>

    /**
     * Update one CodeProjectUser.
     * @param {CodeProjectUserUpdateArgs} args - Arguments to update one CodeProjectUser.
     * @example
     * // Update one CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeProjectUserUpdateArgs>(
      args: SelectSubset<T, CodeProjectUserUpdateArgs>
    ): CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser>, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T>>>

    /**
     * Delete zero or more CodeProjectUsers.
     * @param {CodeProjectUserDeleteManyArgs} args - Arguments to filter CodeProjectUsers to delete.
     * @example
     * // Delete a few CodeProjectUsers
     * const { count } = await prisma.codeProjectUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeProjectUserDeleteManyArgs>(
      args?: SelectSubset<T, CodeProjectUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeProjectUsers
     * const codeProjectUser = await prisma.codeProjectUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeProjectUserUpdateManyArgs>(
      args: SelectSubset<T, CodeProjectUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeProjectUser.
     * @param {CodeProjectUserUpsertArgs} args - Arguments to update or create a CodeProjectUser.
     * @example
     * // Update or create a CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.upsert({
     *   create: {
     *     // ... data to create a CodeProjectUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeProjectUser we want to update
     *   }
     * })
    **/
    upsert<T extends CodeProjectUserUpsertArgs>(
      args: SelectSubset<T, CodeProjectUserUpsertArgs>
    ): CheckSelect<T, Prisma__CodeProjectUserClient<CodeProjectUser>, Prisma__CodeProjectUserClient<CodeProjectUserGetPayload<T>>>

    /**
     * Count the number of CodeProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserCountArgs} args - Arguments to filter CodeProjectUsers to count.
     * @example
     * // Count the number of CodeProjectUsers
     * const count = await prisma.codeProjectUser.count({
     *   where: {
     *     // ... the filter for the CodeProjectUsers we want to count
     *   }
     * })
    **/
    count<T extends CodeProjectUserCountArgs>(
      args?: Subset<T, CodeProjectUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeProjectUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeProjectUserAggregateArgs>(args: Subset<T, CodeProjectUserAggregateArgs>): PrismaPromise<GetCodeProjectUserAggregateType<T>>

    /**
     * Group by CodeProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeProjectUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeProjectUserGroupByArgs['orderBy'] }
        : { orderBy?: CodeProjectUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeProjectUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeProjectUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeProjectUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeProjectUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    CodeProject<T extends CodeProjectArgs = {}>(args?: Subset<T, CodeProjectArgs>): CheckSelect<T, Prisma__CodeProjectClient<CodeProject | null >, Prisma__CodeProjectClient<CodeProjectGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CodeProjectUser findUnique
   */
  export type CodeProjectUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
    /**
     * Throw an Error if a CodeProjectUser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeProjectUser to fetch.
     * 
    **/
    where: CodeProjectUserWhereUniqueInput
  }


  /**
   * CodeProjectUser findFirst
   */
  export type CodeProjectUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
    /**
     * Throw an Error if a CodeProjectUser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeProjectUser to fetch.
     * 
    **/
    where?: CodeProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjectUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeProjectUsers.
     * 
    **/
    cursor?: CodeProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjectUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjectUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeProjectUsers.
     * 
    **/
    distinct?: Enumerable<CodeProjectUserScalarFieldEnum>
  }


  /**
   * CodeProjectUser findMany
   */
  export type CodeProjectUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
    /**
     * Filter, which CodeProjectUsers to fetch.
     * 
    **/
    where?: CodeProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeProjectUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeProjectUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeProjectUsers.
     * 
    **/
    cursor?: CodeProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeProjectUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeProjectUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeProjectUserScalarFieldEnum>
  }


  /**
   * CodeProjectUser create
   */
  export type CodeProjectUserCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
    /**
     * The data needed to create a CodeProjectUser.
     * 
    **/
    data: XOR<CodeProjectUserCreateInput, CodeProjectUserUncheckedCreateInput>
  }


  /**
   * CodeProjectUser createMany
   */
  export type CodeProjectUserCreateManyArgs = {
    data: Enumerable<CodeProjectUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodeProjectUser update
   */
  export type CodeProjectUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
    /**
     * The data needed to update a CodeProjectUser.
     * 
    **/
    data: XOR<CodeProjectUserUpdateInput, CodeProjectUserUncheckedUpdateInput>
    /**
     * Choose, which CodeProjectUser to update.
     * 
    **/
    where: CodeProjectUserWhereUniqueInput
  }


  /**
   * CodeProjectUser updateMany
   */
  export type CodeProjectUserUpdateManyArgs = {
    data: XOR<CodeProjectUserUpdateManyMutationInput, CodeProjectUserUncheckedUpdateManyInput>
    where?: CodeProjectUserWhereInput
  }


  /**
   * CodeProjectUser upsert
   */
  export type CodeProjectUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
    /**
     * The filter to search for the CodeProjectUser to update in case it exists.
     * 
    **/
    where: CodeProjectUserWhereUniqueInput
    /**
     * In case the CodeProjectUser found by the `where` argument doesn't exist, create a new CodeProjectUser with this data.
     * 
    **/
    create: XOR<CodeProjectUserCreateInput, CodeProjectUserUncheckedCreateInput>
    /**
     * In case the CodeProjectUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CodeProjectUserUpdateInput, CodeProjectUserUncheckedUpdateInput>
  }


  /**
   * CodeProjectUser delete
   */
  export type CodeProjectUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
    /**
     * Filter which CodeProjectUser to delete.
     * 
    **/
    where: CodeProjectUserWhereUniqueInput
  }


  /**
   * CodeProjectUser deleteMany
   */
  export type CodeProjectUserDeleteManyArgs = {
    where?: CodeProjectUserWhereInput
  }


  /**
   * CodeProjectUser without action
   */
  export type CodeProjectUserArgs = {
    /**
     * Select specific fields to fetch from the CodeProjectUser
     * 
    **/
    select?: CodeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeProjectUserInclude | null
  }



  /**
   * Model CodeReport
   */


  export type AggregateCodeReport = {
    _count: CodeReportCountAggregateOutputType | null
    count: CodeReportCountAggregateOutputType | null
    _avg: CodeReportAvgAggregateOutputType | null
    avg: CodeReportAvgAggregateOutputType | null
    _sum: CodeReportSumAggregateOutputType | null
    sum: CodeReportSumAggregateOutputType | null
    _min: CodeReportMinAggregateOutputType | null
    min: CodeReportMinAggregateOutputType | null
    _max: CodeReportMaxAggregateOutputType | null
    max: CodeReportMaxAggregateOutputType | null
  }

  export type CodeReportAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CodeProjectId: number | null
    Type: number | null
  }

  export type CodeReportSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CodeProjectId: number | null
    Type: number | null
  }

  export type CodeReportMinAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Date: Date | null
    CodeProjectId: number | null
    Type: number | null
    IsDelete: boolean | null
    Note: string | null
  }

  export type CodeReportMaxAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Date: Date | null
    CodeProjectId: number | null
    Type: number | null
    IsDelete: boolean | null
    Note: string | null
  }

  export type CodeReportCountAggregateOutputType = {
    Id: number
    CreatedBy: number
    CreatedDate: number
    Date: number
    CodeProjectId: number
    Type: number
    IsDelete: number
    Note: number
    _all: number
  }


  export type CodeReportAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CodeProjectId?: true
    Type?: true
  }

  export type CodeReportSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CodeProjectId?: true
    Type?: true
  }

  export type CodeReportMinAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CreatedDate?: true
    Date?: true
    CodeProjectId?: true
    Type?: true
    IsDelete?: true
    Note?: true
  }

  export type CodeReportMaxAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CreatedDate?: true
    Date?: true
    CodeProjectId?: true
    Type?: true
    IsDelete?: true
    Note?: true
  }

  export type CodeReportCountAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CreatedDate?: true
    Date?: true
    CodeProjectId?: true
    Type?: true
    IsDelete?: true
    Note?: true
    _all?: true
  }

  export type CodeReportAggregateArgs = {
    /**
     * Filter which CodeReport to aggregate.
     * 
    **/
    where?: CodeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeReports to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CodeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeReports
    **/
    _count?: true | CodeReportCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeReportAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeReportSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeReportMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeReportMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeReportMaxAggregateInputType
  }

  export type GetCodeReportAggregateType<T extends CodeReportAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeReport[P]>
      : GetScalarType<T[P], AggregateCodeReport[P]>
  }


    
    
  export type CodeReportGroupByArgs = {
    where?: CodeReportWhereInput
    orderBy?: Enumerable<CodeReportOrderByInput>
    by: Array<CodeReportScalarFieldEnum>
    having?: CodeReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeReportCountAggregateInputType | true
    _avg?: CodeReportAvgAggregateInputType
    _sum?: CodeReportSumAggregateInputType
    _min?: CodeReportMinAggregateInputType
    _max?: CodeReportMaxAggregateInputType
  }


  export type CodeReportGroupByOutputType = {
    Id: number
    CreatedBy: number
    CreatedDate: Date
    Date: Date
    CodeProjectId: number
    Type: number
    IsDelete: boolean
    Note: string
    _count: CodeReportCountAggregateOutputType | null
    _avg: CodeReportAvgAggregateOutputType | null
    _sum: CodeReportSumAggregateOutputType | null
    _min: CodeReportMinAggregateOutputType | null
    _max: CodeReportMaxAggregateOutputType | null
  }

  type GetCodeReportGroupByPayload<T extends CodeReportGroupByArgs> = Promise<
    Array<
      PickArray<CodeReportGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeReportGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeReportGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeReportGroupByOutputType[P]>
        }
      > 
    >


  export type CodeReportSelect = {
    Id?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Date?: boolean
    CodeProjectId?: boolean
    Type?: boolean
    IsDelete?: boolean
    Note?: boolean
    User?: boolean | UserArgs
    CodeProject?: boolean | CodeProjectArgs
    CodeReportApproval?: boolean | CodeReportApprovalFindManyArgs
    CodeReportApprovalComment?: boolean | CodeReportApprovalFindManyArgs
    DailyReportImage?: boolean | DailyReportImageFindManyArgs
    DailyTask?: boolean | DailyTaskFindManyArgs
    StatusReport?: boolean | StatusReportArgs
    Tool?: boolean | ToolFindManyArgs
    Weather?: boolean | WeatherArgs
    Material?: boolean | MaterialFindManyArgs
    Worker?: boolean | WorkerFindManyArgs
    RequestForInformation?: boolean | RequestForInformationArgs
  }

  export type CodeReportInclude = {
    User?: boolean | UserArgs
    CodeProject?: boolean | CodeProjectArgs
    CodeReportApproval?: boolean | CodeReportApprovalFindManyArgs
    CodeReportApprovalComment?: boolean | CodeReportApprovalFindManyArgs
    DailyReportImage?: boolean | DailyReportImageFindManyArgs
    DailyTask?: boolean | DailyTaskFindManyArgs
    StatusReport?: boolean | StatusReportArgs
    Tool?: boolean | ToolFindManyArgs
    Weather?: boolean | WeatherArgs
    Material?: boolean | MaterialFindManyArgs
    Worker?: boolean | WorkerFindManyArgs
    RequestForInformation?: boolean | RequestForInformationArgs
  }

  export type CodeReportGetPayload<
    S extends boolean | null | undefined | CodeReportArgs,
    U = keyof S
      > = S extends true
        ? CodeReport
    : S extends undefined
    ? never
    : S extends CodeReportArgs | CodeReportFindManyArgs
    ?'include' extends U
    ? CodeReport  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> :
        P extends 'CodeProject'
        ? CodeProjectGetPayload<S['include'][P]> :
        P extends 'CodeReportApproval'
        ? Array < CodeReportApprovalGetPayload<S['include'][P]>>  :
        P extends 'CodeReportApprovalComment'
        ? Array < CodeReportApprovalGetPayload<S['include'][P]>>  :
        P extends 'DailyReportImage'
        ? Array < DailyReportImageGetPayload<S['include'][P]>>  :
        P extends 'DailyTask'
        ? Array < DailyTaskGetPayload<S['include'][P]>>  :
        P extends 'StatusReport'
        ? StatusReportGetPayload<S['include'][P]> | null :
        P extends 'Tool'
        ? Array < ToolGetPayload<S['include'][P]>>  :
        P extends 'Weather'
        ? WeatherGetPayload<S['include'][P]> | null :
        P extends 'Material'
        ? Array < MaterialGetPayload<S['include'][P]>>  :
        P extends 'Worker'
        ? Array < WorkerGetPayload<S['include'][P]>>  :
        P extends 'RequestForInformation'
        ? RequestForInformationGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CodeReport ?CodeReport [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> :
        P extends 'CodeProject'
        ? CodeProjectGetPayload<S['select'][P]> :
        P extends 'CodeReportApproval'
        ? Array < CodeReportApprovalGetPayload<S['select'][P]>>  :
        P extends 'CodeReportApprovalComment'
        ? Array < CodeReportApprovalGetPayload<S['select'][P]>>  :
        P extends 'DailyReportImage'
        ? Array < DailyReportImageGetPayload<S['select'][P]>>  :
        P extends 'DailyTask'
        ? Array < DailyTaskGetPayload<S['select'][P]>>  :
        P extends 'StatusReport'
        ? StatusReportGetPayload<S['select'][P]> | null :
        P extends 'Tool'
        ? Array < ToolGetPayload<S['select'][P]>>  :
        P extends 'Weather'
        ? WeatherGetPayload<S['select'][P]> | null :
        P extends 'Material'
        ? Array < MaterialGetPayload<S['select'][P]>>  :
        P extends 'Worker'
        ? Array < WorkerGetPayload<S['select'][P]>>  :
        P extends 'RequestForInformation'
        ? RequestForInformationGetPayload<S['select'][P]> | null : never
  } 
    : CodeReport
  : CodeReport


  type CodeReportCountArgs = Merge<
    Omit<CodeReportFindManyArgs, 'select' | 'include'> & {
      select?: CodeReportCountAggregateInputType | true
    }
  >

  export interface CodeReportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeReport that matches the filter.
     * @param {CodeReportFindUniqueArgs} args - Arguments to find a CodeReport
     * @example
     * // Get one CodeReport
     * const codeReport = await prisma.codeReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeReport'> extends True ? CheckSelect<T, Prisma__CodeReportClient<CodeReport>, Prisma__CodeReportClient<CodeReportGetPayload<T>>> : CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>

    /**
     * Find the first CodeReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportFindFirstArgs} args - Arguments to find a CodeReport
     * @example
     * // Get one CodeReport
     * const codeReport = await prisma.codeReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeReport'> extends True ? CheckSelect<T, Prisma__CodeReportClient<CodeReport>, Prisma__CodeReportClient<CodeReportGetPayload<T>>> : CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>

    /**
     * Find zero or more CodeReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeReports
     * const codeReports = await prisma.codeReport.findMany()
     * 
     * // Get first 10 CodeReports
     * const codeReports = await prisma.codeReport.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeReportWithIdOnly = await prisma.codeReport.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends CodeReportFindManyArgs>(
      args?: SelectSubset<T, CodeReportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CodeReport>>, PrismaPromise<Array<CodeReportGetPayload<T>>>>

    /**
     * Create a CodeReport.
     * @param {CodeReportCreateArgs} args - Arguments to create a CodeReport.
     * @example
     * // Create one CodeReport
     * const CodeReport = await prisma.codeReport.create({
     *   data: {
     *     // ... data to create a CodeReport
     *   }
     * })
     * 
    **/
    create<T extends CodeReportCreateArgs>(
      args: SelectSubset<T, CodeReportCreateArgs>
    ): CheckSelect<T, Prisma__CodeReportClient<CodeReport>, Prisma__CodeReportClient<CodeReportGetPayload<T>>>

    /**
     * Create many CodeReports.
     *     @param {CodeReportCreateManyArgs} args - Arguments to create many CodeReports.
     *     @example
     *     // Create many CodeReports
     *     const codeReport = await prisma.codeReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeReportCreateManyArgs>(
      args?: SelectSubset<T, CodeReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeReport.
     * @param {CodeReportDeleteArgs} args - Arguments to delete one CodeReport.
     * @example
     * // Delete one CodeReport
     * const CodeReport = await prisma.codeReport.delete({
     *   where: {
     *     // ... filter to delete one CodeReport
     *   }
     * })
     * 
    **/
    delete<T extends CodeReportDeleteArgs>(
      args: SelectSubset<T, CodeReportDeleteArgs>
    ): CheckSelect<T, Prisma__CodeReportClient<CodeReport>, Prisma__CodeReportClient<CodeReportGetPayload<T>>>

    /**
     * Update one CodeReport.
     * @param {CodeReportUpdateArgs} args - Arguments to update one CodeReport.
     * @example
     * // Update one CodeReport
     * const codeReport = await prisma.codeReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeReportUpdateArgs>(
      args: SelectSubset<T, CodeReportUpdateArgs>
    ): CheckSelect<T, Prisma__CodeReportClient<CodeReport>, Prisma__CodeReportClient<CodeReportGetPayload<T>>>

    /**
     * Delete zero or more CodeReports.
     * @param {CodeReportDeleteManyArgs} args - Arguments to filter CodeReports to delete.
     * @example
     * // Delete a few CodeReports
     * const { count } = await prisma.codeReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeReportDeleteManyArgs>(
      args?: SelectSubset<T, CodeReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeReports
     * const codeReport = await prisma.codeReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeReportUpdateManyArgs>(
      args: SelectSubset<T, CodeReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeReport.
     * @param {CodeReportUpsertArgs} args - Arguments to update or create a CodeReport.
     * @example
     * // Update or create a CodeReport
     * const codeReport = await prisma.codeReport.upsert({
     *   create: {
     *     // ... data to create a CodeReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeReport we want to update
     *   }
     * })
    **/
    upsert<T extends CodeReportUpsertArgs>(
      args: SelectSubset<T, CodeReportUpsertArgs>
    ): CheckSelect<T, Prisma__CodeReportClient<CodeReport>, Prisma__CodeReportClient<CodeReportGetPayload<T>>>

    /**
     * Count the number of CodeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportCountArgs} args - Arguments to filter CodeReports to count.
     * @example
     * // Count the number of CodeReports
     * const count = await prisma.codeReport.count({
     *   where: {
     *     // ... the filter for the CodeReports we want to count
     *   }
     * })
    **/
    count<T extends CodeReportCountArgs>(
      args?: Subset<T, CodeReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeReportAggregateArgs>(args: Subset<T, CodeReportAggregateArgs>): PrismaPromise<GetCodeReportAggregateType<T>>

    /**
     * Group by CodeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeReportGroupByArgs['orderBy'] }
        : { orderBy?: CodeReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeReportGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeReportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    CodeProject<T extends CodeProjectArgs = {}>(args?: Subset<T, CodeProjectArgs>): CheckSelect<T, Prisma__CodeProjectClient<CodeProject | null >, Prisma__CodeProjectClient<CodeProjectGetPayload<T> | null >>;

    CodeReportApproval<T extends CodeReportApprovalFindManyArgs = {}>(args?: Subset<T, CodeReportApprovalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeReportApproval>>, PrismaPromise<Array<CodeReportApprovalGetPayload<T>>>>;

    CodeReportApprovalComment<T extends CodeReportApprovalFindManyArgs = {}>(args?: Subset<T, CodeReportApprovalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeReportApproval>>, PrismaPromise<Array<CodeReportApprovalGetPayload<T>>>>;

    DailyReportImage<T extends DailyReportImageFindManyArgs = {}>(args?: Subset<T, DailyReportImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DailyReportImage>>, PrismaPromise<Array<DailyReportImageGetPayload<T>>>>;

    DailyTask<T extends DailyTaskFindManyArgs = {}>(args?: Subset<T, DailyTaskFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DailyTask>>, PrismaPromise<Array<DailyTaskGetPayload<T>>>>;

    StatusReport<T extends StatusReportArgs = {}>(args?: Subset<T, StatusReportArgs>): CheckSelect<T, Prisma__StatusReportClient<StatusReport | null >, Prisma__StatusReportClient<StatusReportGetPayload<T> | null >>;

    Tool<T extends ToolFindManyArgs = {}>(args?: Subset<T, ToolFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tool>>, PrismaPromise<Array<ToolGetPayload<T>>>>;

    Weather<T extends WeatherArgs = {}>(args?: Subset<T, WeatherArgs>): CheckSelect<T, Prisma__WeatherClient<Weather | null >, Prisma__WeatherClient<WeatherGetPayload<T> | null >>;

    Material<T extends MaterialFindManyArgs = {}>(args?: Subset<T, MaterialFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Material>>, PrismaPromise<Array<MaterialGetPayload<T>>>>;

    Worker<T extends WorkerFindManyArgs = {}>(args?: Subset<T, WorkerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Worker>>, PrismaPromise<Array<WorkerGetPayload<T>>>>;

    RequestForInformation<T extends RequestForInformationArgs = {}>(args?: Subset<T, RequestForInformationArgs>): CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation | null >, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CodeReport findUnique
   */
  export type CodeReportFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
    /**
     * Throw an Error if a CodeReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeReport to fetch.
     * 
    **/
    where: CodeReportWhereUniqueInput
  }


  /**
   * CodeReport findFirst
   */
  export type CodeReportFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
    /**
     * Throw an Error if a CodeReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeReport to fetch.
     * 
    **/
    where?: CodeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeReports to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeReports.
     * 
    **/
    cursor?: CodeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeReports.
     * 
    **/
    distinct?: Enumerable<CodeReportScalarFieldEnum>
  }


  /**
   * CodeReport findMany
   */
  export type CodeReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
    /**
     * Filter, which CodeReports to fetch.
     * 
    **/
    where?: CodeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeReports to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeReports.
     * 
    **/
    cursor?: CodeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeReports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeReportScalarFieldEnum>
  }


  /**
   * CodeReport create
   */
  export type CodeReportCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
    /**
     * The data needed to create a CodeReport.
     * 
    **/
    data: XOR<CodeReportCreateInput, CodeReportUncheckedCreateInput>
  }


  /**
   * CodeReport createMany
   */
  export type CodeReportCreateManyArgs = {
    data: Enumerable<CodeReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodeReport update
   */
  export type CodeReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
    /**
     * The data needed to update a CodeReport.
     * 
    **/
    data: XOR<CodeReportUpdateInput, CodeReportUncheckedUpdateInput>
    /**
     * Choose, which CodeReport to update.
     * 
    **/
    where: CodeReportWhereUniqueInput
  }


  /**
   * CodeReport updateMany
   */
  export type CodeReportUpdateManyArgs = {
    data: XOR<CodeReportUpdateManyMutationInput, CodeReportUncheckedUpdateManyInput>
    where?: CodeReportWhereInput
  }


  /**
   * CodeReport upsert
   */
  export type CodeReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
    /**
     * The filter to search for the CodeReport to update in case it exists.
     * 
    **/
    where: CodeReportWhereUniqueInput
    /**
     * In case the CodeReport found by the `where` argument doesn't exist, create a new CodeReport with this data.
     * 
    **/
    create: XOR<CodeReportCreateInput, CodeReportUncheckedCreateInput>
    /**
     * In case the CodeReport was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CodeReportUpdateInput, CodeReportUncheckedUpdateInput>
  }


  /**
   * CodeReport delete
   */
  export type CodeReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
    /**
     * Filter which CodeReport to delete.
     * 
    **/
    where: CodeReportWhereUniqueInput
  }


  /**
   * CodeReport deleteMany
   */
  export type CodeReportDeleteManyArgs = {
    where?: CodeReportWhereInput
  }


  /**
   * CodeReport without action
   */
  export type CodeReportArgs = {
    /**
     * Select specific fields to fetch from the CodeReport
     * 
    **/
    select?: CodeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportInclude | null
  }



  /**
   * Model CodeReportApproval
   */


  export type AggregateCodeReportApproval = {
    _count: CodeReportApprovalCountAggregateOutputType | null
    count: CodeReportApprovalCountAggregateOutputType | null
    _avg: CodeReportApprovalAvgAggregateOutputType | null
    avg: CodeReportApprovalAvgAggregateOutputType | null
    _sum: CodeReportApprovalSumAggregateOutputType | null
    sum: CodeReportApprovalSumAggregateOutputType | null
    _min: CodeReportApprovalMinAggregateOutputType | null
    min: CodeReportApprovalMinAggregateOutputType | null
    _max: CodeReportApprovalMaxAggregateOutputType | null
    max: CodeReportApprovalMaxAggregateOutputType | null
  }

  export type CodeReportApprovalAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    Approval: number | null
  }

  export type CodeReportApprovalSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    Approval: number | null
  }

  export type CodeReportApprovalMinAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Comment: string | null
    Approval: number | null
    IsDelete: boolean | null
  }

  export type CodeReportApprovalMaxAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Comment: string | null
    Approval: number | null
    IsDelete: boolean | null
  }

  export type CodeReportApprovalCountAggregateOutputType = {
    Id: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate: number
    Comment: number
    Approval: number
    IsDelete: number
    _all: number
  }


  export type CodeReportApprovalAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    Approval?: true
  }

  export type CodeReportApprovalSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    Approval?: true
  }

  export type CodeReportApprovalMinAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    CreatedDate?: true
    Comment?: true
    Approval?: true
    IsDelete?: true
  }

  export type CodeReportApprovalMaxAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    CreatedDate?: true
    Comment?: true
    Approval?: true
    IsDelete?: true
  }

  export type CodeReportApprovalCountAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    CreatedDate?: true
    Comment?: true
    Approval?: true
    IsDelete?: true
    _all?: true
  }

  export type CodeReportApprovalAggregateArgs = {
    /**
     * Filter which CodeReportApproval to aggregate.
     * 
    **/
    where?: CodeReportApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeReportApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeReportApprovalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CodeReportApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeReportApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeReportApprovals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeReportApprovals
    **/
    _count?: true | CodeReportApprovalCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeReportApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeReportApprovalAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeReportApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeReportApprovalSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeReportApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeReportApprovalMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeReportApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeReportApprovalMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeReportApprovalMaxAggregateInputType
  }

  export type GetCodeReportApprovalAggregateType<T extends CodeReportApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeReportApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeReportApproval[P]>
      : GetScalarType<T[P], AggregateCodeReportApproval[P]>
  }


    
    
  export type CodeReportApprovalGroupByArgs = {
    where?: CodeReportApprovalWhereInput
    orderBy?: Enumerable<CodeReportApprovalOrderByInput>
    by: Array<CodeReportApprovalScalarFieldEnum>
    having?: CodeReportApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeReportApprovalCountAggregateInputType | true
    _avg?: CodeReportApprovalAvgAggregateInputType
    _sum?: CodeReportApprovalSumAggregateInputType
    _min?: CodeReportApprovalMinAggregateInputType
    _max?: CodeReportApprovalMaxAggregateInputType
  }


  export type CodeReportApprovalGroupByOutputType = {
    Id: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate: Date
    Comment: string
    Approval: number
    IsDelete: boolean
    _count: CodeReportApprovalCountAggregateOutputType | null
    _avg: CodeReportApprovalAvgAggregateOutputType | null
    _sum: CodeReportApprovalSumAggregateOutputType | null
    _min: CodeReportApprovalMinAggregateOutputType | null
    _max: CodeReportApprovalMaxAggregateOutputType | null
  }

  type GetCodeReportApprovalGroupByPayload<T extends CodeReportApprovalGroupByArgs> = Promise<
    Array<
      PickArray<CodeReportApprovalGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeReportApprovalGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeReportApprovalGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeReportApprovalGroupByOutputType[P]>
        }
      > 
    >


  export type CodeReportApprovalSelect = {
    Id?: boolean
    CodeReportId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Comment?: boolean
    Approval?: boolean
    IsDelete?: boolean
    CodeReport?: boolean | CodeReportArgs
    CodeReportComment?: boolean | CodeReportArgs
    User?: boolean | UserArgs
  }

  export type CodeReportApprovalInclude = {
    CodeReport?: boolean | CodeReportArgs
    CodeReportComment?: boolean | CodeReportArgs
    User?: boolean | UserArgs
  }

  export type CodeReportApprovalGetPayload<
    S extends boolean | null | undefined | CodeReportApprovalArgs,
    U = keyof S
      > = S extends true
        ? CodeReportApproval
    : S extends undefined
    ? never
    : S extends CodeReportApprovalArgs | CodeReportApprovalFindManyArgs
    ?'include' extends U
    ? CodeReportApproval  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> :
        P extends 'CodeReportComment'
        ? CodeReportGetPayload<S['include'][P]> :
        P extends 'User'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CodeReportApproval ?CodeReportApproval [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> :
        P extends 'CodeReportComment'
        ? CodeReportGetPayload<S['select'][P]> :
        P extends 'User'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CodeReportApproval
  : CodeReportApproval


  type CodeReportApprovalCountArgs = Merge<
    Omit<CodeReportApprovalFindManyArgs, 'select' | 'include'> & {
      select?: CodeReportApprovalCountAggregateInputType | true
    }
  >

  export interface CodeReportApprovalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeReportApproval that matches the filter.
     * @param {CodeReportApprovalFindUniqueArgs} args - Arguments to find a CodeReportApproval
     * @example
     * // Get one CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeReportApprovalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeReportApprovalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeReportApproval'> extends True ? CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval>, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T>>> : CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval | null >, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T> | null >>

    /**
     * Find the first CodeReportApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalFindFirstArgs} args - Arguments to find a CodeReportApproval
     * @example
     * // Get one CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeReportApprovalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeReportApprovalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeReportApproval'> extends True ? CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval>, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T>>> : CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval | null >, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T> | null >>

    /**
     * Find zero or more CodeReportApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeReportApprovals
     * const codeReportApprovals = await prisma.codeReportApproval.findMany()
     * 
     * // Get first 10 CodeReportApprovals
     * const codeReportApprovals = await prisma.codeReportApproval.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeReportApprovalWithIdOnly = await prisma.codeReportApproval.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends CodeReportApprovalFindManyArgs>(
      args?: SelectSubset<T, CodeReportApprovalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CodeReportApproval>>, PrismaPromise<Array<CodeReportApprovalGetPayload<T>>>>

    /**
     * Create a CodeReportApproval.
     * @param {CodeReportApprovalCreateArgs} args - Arguments to create a CodeReportApproval.
     * @example
     * // Create one CodeReportApproval
     * const CodeReportApproval = await prisma.codeReportApproval.create({
     *   data: {
     *     // ... data to create a CodeReportApproval
     *   }
     * })
     * 
    **/
    create<T extends CodeReportApprovalCreateArgs>(
      args: SelectSubset<T, CodeReportApprovalCreateArgs>
    ): CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval>, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T>>>

    /**
     * Create many CodeReportApprovals.
     *     @param {CodeReportApprovalCreateManyArgs} args - Arguments to create many CodeReportApprovals.
     *     @example
     *     // Create many CodeReportApprovals
     *     const codeReportApproval = await prisma.codeReportApproval.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeReportApprovalCreateManyArgs>(
      args?: SelectSubset<T, CodeReportApprovalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeReportApproval.
     * @param {CodeReportApprovalDeleteArgs} args - Arguments to delete one CodeReportApproval.
     * @example
     * // Delete one CodeReportApproval
     * const CodeReportApproval = await prisma.codeReportApproval.delete({
     *   where: {
     *     // ... filter to delete one CodeReportApproval
     *   }
     * })
     * 
    **/
    delete<T extends CodeReportApprovalDeleteArgs>(
      args: SelectSubset<T, CodeReportApprovalDeleteArgs>
    ): CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval>, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T>>>

    /**
     * Update one CodeReportApproval.
     * @param {CodeReportApprovalUpdateArgs} args - Arguments to update one CodeReportApproval.
     * @example
     * // Update one CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeReportApprovalUpdateArgs>(
      args: SelectSubset<T, CodeReportApprovalUpdateArgs>
    ): CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval>, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T>>>

    /**
     * Delete zero or more CodeReportApprovals.
     * @param {CodeReportApprovalDeleteManyArgs} args - Arguments to filter CodeReportApprovals to delete.
     * @example
     * // Delete a few CodeReportApprovals
     * const { count } = await prisma.codeReportApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeReportApprovalDeleteManyArgs>(
      args?: SelectSubset<T, CodeReportApprovalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeReportApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeReportApprovals
     * const codeReportApproval = await prisma.codeReportApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeReportApprovalUpdateManyArgs>(
      args: SelectSubset<T, CodeReportApprovalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeReportApproval.
     * @param {CodeReportApprovalUpsertArgs} args - Arguments to update or create a CodeReportApproval.
     * @example
     * // Update or create a CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.upsert({
     *   create: {
     *     // ... data to create a CodeReportApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeReportApproval we want to update
     *   }
     * })
    **/
    upsert<T extends CodeReportApprovalUpsertArgs>(
      args: SelectSubset<T, CodeReportApprovalUpsertArgs>
    ): CheckSelect<T, Prisma__CodeReportApprovalClient<CodeReportApproval>, Prisma__CodeReportApprovalClient<CodeReportApprovalGetPayload<T>>>

    /**
     * Count the number of CodeReportApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalCountArgs} args - Arguments to filter CodeReportApprovals to count.
     * @example
     * // Count the number of CodeReportApprovals
     * const count = await prisma.codeReportApproval.count({
     *   where: {
     *     // ... the filter for the CodeReportApprovals we want to count
     *   }
     * })
    **/
    count<T extends CodeReportApprovalCountArgs>(
      args?: Subset<T, CodeReportApprovalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeReportApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeReportApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeReportApprovalAggregateArgs>(args: Subset<T, CodeReportApprovalAggregateArgs>): PrismaPromise<GetCodeReportApprovalAggregateType<T>>

    /**
     * Group by CodeReportApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeReportApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeReportApprovalGroupByArgs['orderBy'] }
        : { orderBy?: CodeReportApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeReportApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeReportApprovalGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeReportApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeReportApprovalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    CodeReportComment<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CodeReportApproval findUnique
   */
  export type CodeReportApprovalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
    /**
     * Throw an Error if a CodeReportApproval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeReportApproval to fetch.
     * 
    **/
    where: CodeReportApprovalWhereUniqueInput
  }


  /**
   * CodeReportApproval findFirst
   */
  export type CodeReportApprovalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
    /**
     * Throw an Error if a CodeReportApproval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CodeReportApproval to fetch.
     * 
    **/
    where?: CodeReportApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeReportApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeReportApprovalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeReportApprovals.
     * 
    **/
    cursor?: CodeReportApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeReportApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeReportApprovals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeReportApprovals.
     * 
    **/
    distinct?: Enumerable<CodeReportApprovalScalarFieldEnum>
  }


  /**
   * CodeReportApproval findMany
   */
  export type CodeReportApprovalFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
    /**
     * Filter, which CodeReportApprovals to fetch.
     * 
    **/
    where?: CodeReportApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeReportApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<CodeReportApprovalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeReportApprovals.
     * 
    **/
    cursor?: CodeReportApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeReportApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeReportApprovals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeReportApprovalScalarFieldEnum>
  }


  /**
   * CodeReportApproval create
   */
  export type CodeReportApprovalCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
    /**
     * The data needed to create a CodeReportApproval.
     * 
    **/
    data: XOR<CodeReportApprovalCreateInput, CodeReportApprovalUncheckedCreateInput>
  }


  /**
   * CodeReportApproval createMany
   */
  export type CodeReportApprovalCreateManyArgs = {
    data: Enumerable<CodeReportApprovalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodeReportApproval update
   */
  export type CodeReportApprovalUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
    /**
     * The data needed to update a CodeReportApproval.
     * 
    **/
    data: XOR<CodeReportApprovalUpdateInput, CodeReportApprovalUncheckedUpdateInput>
    /**
     * Choose, which CodeReportApproval to update.
     * 
    **/
    where: CodeReportApprovalWhereUniqueInput
  }


  /**
   * CodeReportApproval updateMany
   */
  export type CodeReportApprovalUpdateManyArgs = {
    data: XOR<CodeReportApprovalUpdateManyMutationInput, CodeReportApprovalUncheckedUpdateManyInput>
    where?: CodeReportApprovalWhereInput
  }


  /**
   * CodeReportApproval upsert
   */
  export type CodeReportApprovalUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
    /**
     * The filter to search for the CodeReportApproval to update in case it exists.
     * 
    **/
    where: CodeReportApprovalWhereUniqueInput
    /**
     * In case the CodeReportApproval found by the `where` argument doesn't exist, create a new CodeReportApproval with this data.
     * 
    **/
    create: XOR<CodeReportApprovalCreateInput, CodeReportApprovalUncheckedCreateInput>
    /**
     * In case the CodeReportApproval was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CodeReportApprovalUpdateInput, CodeReportApprovalUncheckedUpdateInput>
  }


  /**
   * CodeReportApproval delete
   */
  export type CodeReportApprovalDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
    /**
     * Filter which CodeReportApproval to delete.
     * 
    **/
    where: CodeReportApprovalWhereUniqueInput
  }


  /**
   * CodeReportApproval deleteMany
   */
  export type CodeReportApprovalDeleteManyArgs = {
    where?: CodeReportApprovalWhereInput
  }


  /**
   * CodeReportApproval without action
   */
  export type CodeReportApprovalArgs = {
    /**
     * Select specific fields to fetch from the CodeReportApproval
     * 
    **/
    select?: CodeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CodeReportApprovalInclude | null
  }



  /**
   * Model DailyReportImage
   */


  export type AggregateDailyReportImage = {
    _count: DailyReportImageCountAggregateOutputType | null
    count: DailyReportImageCountAggregateOutputType | null
    _avg: DailyReportImageAvgAggregateOutputType | null
    avg: DailyReportImageAvgAggregateOutputType | null
    _sum: DailyReportImageSumAggregateOutputType | null
    sum: DailyReportImageSumAggregateOutputType | null
    _min: DailyReportImageMinAggregateOutputType | null
    min: DailyReportImageMinAggregateOutputType | null
    _max: DailyReportImageMaxAggregateOutputType | null
    max: DailyReportImageMaxAggregateOutputType | null
  }

  export type DailyReportImageAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type DailyReportImageSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type DailyReportImageMinAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    ImageUrl: string | null
    Name: string | null
    Caption: string | null
  }

  export type DailyReportImageMaxAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    ImageUrl: string | null
    Name: string | null
    Caption: string | null
  }

  export type DailyReportImageCountAggregateOutputType = {
    Id: number
    CodeReportId: number
    ImageUrl: number
    Name: number
    Caption: number
    _all: number
  }


  export type DailyReportImageAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type DailyReportImageSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type DailyReportImageMinAggregateInputType = {
    Id?: true
    CodeReportId?: true
    ImageUrl?: true
    Name?: true
    Caption?: true
  }

  export type DailyReportImageMaxAggregateInputType = {
    Id?: true
    CodeReportId?: true
    ImageUrl?: true
    Name?: true
    Caption?: true
  }

  export type DailyReportImageCountAggregateInputType = {
    Id?: true
    CodeReportId?: true
    ImageUrl?: true
    Name?: true
    Caption?: true
    _all?: true
  }

  export type DailyReportImageAggregateArgs = {
    /**
     * Filter which DailyReportImage to aggregate.
     * 
    **/
    where?: DailyReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<DailyReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DailyReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyReportImages
    **/
    _count?: true | DailyReportImageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | DailyReportImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyReportImageAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: DailyReportImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyReportImageSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: DailyReportImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyReportImageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: DailyReportImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyReportImageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: DailyReportImageMaxAggregateInputType
  }

  export type GetDailyReportImageAggregateType<T extends DailyReportImageAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyReportImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyReportImage[P]>
      : GetScalarType<T[P], AggregateDailyReportImage[P]>
  }


    
    
  export type DailyReportImageGroupByArgs = {
    where?: DailyReportImageWhereInput
    orderBy?: Enumerable<DailyReportImageOrderByInput>
    by: Array<DailyReportImageScalarFieldEnum>
    having?: DailyReportImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyReportImageCountAggregateInputType | true
    _avg?: DailyReportImageAvgAggregateInputType
    _sum?: DailyReportImageSumAggregateInputType
    _min?: DailyReportImageMinAggregateInputType
    _max?: DailyReportImageMaxAggregateInputType
  }


  export type DailyReportImageGroupByOutputType = {
    Id: number
    CodeReportId: number
    ImageUrl: string
    Name: string
    Caption: string
    _count: DailyReportImageCountAggregateOutputType | null
    _avg: DailyReportImageAvgAggregateOutputType | null
    _sum: DailyReportImageSumAggregateOutputType | null
    _min: DailyReportImageMinAggregateOutputType | null
    _max: DailyReportImageMaxAggregateOutputType | null
  }

  type GetDailyReportImageGroupByPayload<T extends DailyReportImageGroupByArgs> = Promise<
    Array<
      PickArray<DailyReportImageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof DailyReportImageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], DailyReportImageGroupByOutputType[P]> 
            : GetScalarType<T[P], DailyReportImageGroupByOutputType[P]>
        }
      > 
    >


  export type DailyReportImageSelect = {
    Id?: boolean
    CodeReportId?: boolean
    ImageUrl?: boolean
    Name?: boolean
    Caption?: boolean
    CodeReport?: boolean | CodeReportArgs
  }

  export type DailyReportImageInclude = {
    CodeReport?: boolean | CodeReportArgs
  }

  export type DailyReportImageGetPayload<
    S extends boolean | null | undefined | DailyReportImageArgs,
    U = keyof S
      > = S extends true
        ? DailyReportImage
    : S extends undefined
    ? never
    : S extends DailyReportImageArgs | DailyReportImageFindManyArgs
    ?'include' extends U
    ? DailyReportImage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DailyReportImage ?DailyReportImage [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> : never
  } 
    : DailyReportImage
  : DailyReportImage


  type DailyReportImageCountArgs = Merge<
    Omit<DailyReportImageFindManyArgs, 'select' | 'include'> & {
      select?: DailyReportImageCountAggregateInputType | true
    }
  >

  export interface DailyReportImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DailyReportImage that matches the filter.
     * @param {DailyReportImageFindUniqueArgs} args - Arguments to find a DailyReportImage
     * @example
     * // Get one DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyReportImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyReportImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyReportImage'> extends True ? CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage>, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T>>> : CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage | null >, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T> | null >>

    /**
     * Find the first DailyReportImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageFindFirstArgs} args - Arguments to find a DailyReportImage
     * @example
     * // Get one DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyReportImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyReportImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyReportImage'> extends True ? CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage>, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T>>> : CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage | null >, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T> | null >>

    /**
     * Find zero or more DailyReportImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyReportImages
     * const dailyReportImages = await prisma.dailyReportImage.findMany()
     * 
     * // Get first 10 DailyReportImages
     * const dailyReportImages = await prisma.dailyReportImage.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dailyReportImageWithIdOnly = await prisma.dailyReportImage.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DailyReportImageFindManyArgs>(
      args?: SelectSubset<T, DailyReportImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DailyReportImage>>, PrismaPromise<Array<DailyReportImageGetPayload<T>>>>

    /**
     * Create a DailyReportImage.
     * @param {DailyReportImageCreateArgs} args - Arguments to create a DailyReportImage.
     * @example
     * // Create one DailyReportImage
     * const DailyReportImage = await prisma.dailyReportImage.create({
     *   data: {
     *     // ... data to create a DailyReportImage
     *   }
     * })
     * 
    **/
    create<T extends DailyReportImageCreateArgs>(
      args: SelectSubset<T, DailyReportImageCreateArgs>
    ): CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage>, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T>>>

    /**
     * Create many DailyReportImages.
     *     @param {DailyReportImageCreateManyArgs} args - Arguments to create many DailyReportImages.
     *     @example
     *     // Create many DailyReportImages
     *     const dailyReportImage = await prisma.dailyReportImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyReportImageCreateManyArgs>(
      args?: SelectSubset<T, DailyReportImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DailyReportImage.
     * @param {DailyReportImageDeleteArgs} args - Arguments to delete one DailyReportImage.
     * @example
     * // Delete one DailyReportImage
     * const DailyReportImage = await prisma.dailyReportImage.delete({
     *   where: {
     *     // ... filter to delete one DailyReportImage
     *   }
     * })
     * 
    **/
    delete<T extends DailyReportImageDeleteArgs>(
      args: SelectSubset<T, DailyReportImageDeleteArgs>
    ): CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage>, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T>>>

    /**
     * Update one DailyReportImage.
     * @param {DailyReportImageUpdateArgs} args - Arguments to update one DailyReportImage.
     * @example
     * // Update one DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyReportImageUpdateArgs>(
      args: SelectSubset<T, DailyReportImageUpdateArgs>
    ): CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage>, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T>>>

    /**
     * Delete zero or more DailyReportImages.
     * @param {DailyReportImageDeleteManyArgs} args - Arguments to filter DailyReportImages to delete.
     * @example
     * // Delete a few DailyReportImages
     * const { count } = await prisma.dailyReportImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyReportImageDeleteManyArgs>(
      args?: SelectSubset<T, DailyReportImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyReportImages
     * const dailyReportImage = await prisma.dailyReportImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyReportImageUpdateManyArgs>(
      args: SelectSubset<T, DailyReportImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyReportImage.
     * @param {DailyReportImageUpsertArgs} args - Arguments to update or create a DailyReportImage.
     * @example
     * // Update or create a DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.upsert({
     *   create: {
     *     // ... data to create a DailyReportImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyReportImage we want to update
     *   }
     * })
    **/
    upsert<T extends DailyReportImageUpsertArgs>(
      args: SelectSubset<T, DailyReportImageUpsertArgs>
    ): CheckSelect<T, Prisma__DailyReportImageClient<DailyReportImage>, Prisma__DailyReportImageClient<DailyReportImageGetPayload<T>>>

    /**
     * Count the number of DailyReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageCountArgs} args - Arguments to filter DailyReportImages to count.
     * @example
     * // Count the number of DailyReportImages
     * const count = await prisma.dailyReportImage.count({
     *   where: {
     *     // ... the filter for the DailyReportImages we want to count
     *   }
     * })
    **/
    count<T extends DailyReportImageCountArgs>(
      args?: Subset<T, DailyReportImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyReportImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyReportImageAggregateArgs>(args: Subset<T, DailyReportImageAggregateArgs>): PrismaPromise<GetDailyReportImageAggregateType<T>>

    /**
     * Group by DailyReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyReportImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyReportImageGroupByArgs['orderBy'] }
        : { orderBy?: DailyReportImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyReportImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyReportImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyReportImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyReportImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DailyReportImage findUnique
   */
  export type DailyReportImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
    /**
     * Throw an Error if a DailyReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DailyReportImage to fetch.
     * 
    **/
    where: DailyReportImageWhereUniqueInput
  }


  /**
   * DailyReportImage findFirst
   */
  export type DailyReportImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
    /**
     * Throw an Error if a DailyReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DailyReportImage to fetch.
     * 
    **/
    where?: DailyReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<DailyReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyReportImages.
     * 
    **/
    cursor?: DailyReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyReportImages.
     * 
    **/
    distinct?: Enumerable<DailyReportImageScalarFieldEnum>
  }


  /**
   * DailyReportImage findMany
   */
  export type DailyReportImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
    /**
     * Filter, which DailyReportImages to fetch.
     * 
    **/
    where?: DailyReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<DailyReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyReportImages.
     * 
    **/
    cursor?: DailyReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyReportImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DailyReportImageScalarFieldEnum>
  }


  /**
   * DailyReportImage create
   */
  export type DailyReportImageCreateArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
    /**
     * The data needed to create a DailyReportImage.
     * 
    **/
    data: XOR<DailyReportImageCreateInput, DailyReportImageUncheckedCreateInput>
  }


  /**
   * DailyReportImage createMany
   */
  export type DailyReportImageCreateManyArgs = {
    data: Enumerable<DailyReportImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DailyReportImage update
   */
  export type DailyReportImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
    /**
     * The data needed to update a DailyReportImage.
     * 
    **/
    data: XOR<DailyReportImageUpdateInput, DailyReportImageUncheckedUpdateInput>
    /**
     * Choose, which DailyReportImage to update.
     * 
    **/
    where: DailyReportImageWhereUniqueInput
  }


  /**
   * DailyReportImage updateMany
   */
  export type DailyReportImageUpdateManyArgs = {
    data: XOR<DailyReportImageUpdateManyMutationInput, DailyReportImageUncheckedUpdateManyInput>
    where?: DailyReportImageWhereInput
  }


  /**
   * DailyReportImage upsert
   */
  export type DailyReportImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
    /**
     * The filter to search for the DailyReportImage to update in case it exists.
     * 
    **/
    where: DailyReportImageWhereUniqueInput
    /**
     * In case the DailyReportImage found by the `where` argument doesn't exist, create a new DailyReportImage with this data.
     * 
    **/
    create: XOR<DailyReportImageCreateInput, DailyReportImageUncheckedCreateInput>
    /**
     * In case the DailyReportImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DailyReportImageUpdateInput, DailyReportImageUncheckedUpdateInput>
  }


  /**
   * DailyReportImage delete
   */
  export type DailyReportImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
    /**
     * Filter which DailyReportImage to delete.
     * 
    **/
    where: DailyReportImageWhereUniqueInput
  }


  /**
   * DailyReportImage deleteMany
   */
  export type DailyReportImageDeleteManyArgs = {
    where?: DailyReportImageWhereInput
  }


  /**
   * DailyReportImage without action
   */
  export type DailyReportImageArgs = {
    /**
     * Select specific fields to fetch from the DailyReportImage
     * 
    **/
    select?: DailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyReportImageInclude | null
  }



  /**
   * Model DailyTask
   */


  export type AggregateDailyTask = {
    _count: DailyTaskCountAggregateOutputType | null
    count: DailyTaskCountAggregateOutputType | null
    _avg: DailyTaskAvgAggregateOutputType | null
    avg: DailyTaskAvgAggregateOutputType | null
    _sum: DailyTaskSumAggregateOutputType | null
    sum: DailyTaskSumAggregateOutputType | null
    _min: DailyTaskMinAggregateOutputType | null
    min: DailyTaskMinAggregateOutputType | null
    _max: DailyTaskMaxAggregateOutputType | null
    max: DailyTaskMaxAggregateOutputType | null
  }

  export type DailyTaskAvgAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
  }

  export type DailyTaskSumAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
  }

  export type DailyTaskMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Unit: string | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
    Note: string | null
  }

  export type DailyTaskMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Unit: string | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
    Note: string | null
  }

  export type DailyTaskCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    Unit: number
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: number
    _all: number
  }


  export type DailyTaskAvgAggregateInputType = {
    Id?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
  }

  export type DailyTaskSumAggregateInputType = {
    Id?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
  }

  export type DailyTaskMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Unit?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
    Note?: true
  }

  export type DailyTaskMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Unit?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
    Note?: true
  }

  export type DailyTaskCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Unit?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
    Note?: true
    _all?: true
  }

  export type DailyTaskAggregateArgs = {
    /**
     * Filter which DailyTask to aggregate.
     * 
    **/
    where?: DailyTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<DailyTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DailyTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyTasks
    **/
    _count?: true | DailyTaskCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | DailyTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyTaskAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: DailyTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyTaskSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: DailyTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyTaskMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: DailyTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyTaskMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: DailyTaskMaxAggregateInputType
  }

  export type GetDailyTaskAggregateType<T extends DailyTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyTask[P]>
      : GetScalarType<T[P], AggregateDailyTask[P]>
  }


    
    
  export type DailyTaskGroupByArgs = {
    where?: DailyTaskWhereInput
    orderBy?: Enumerable<DailyTaskOrderByInput>
    by: Array<DailyTaskScalarFieldEnum>
    having?: DailyTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyTaskCountAggregateInputType | true
    _avg?: DailyTaskAvgAggregateInputType
    _sum?: DailyTaskSumAggregateInputType
    _min?: DailyTaskMinAggregateInputType
    _max?: DailyTaskMaxAggregateInputType
  }


  export type DailyTaskGroupByOutputType = {
    Id: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: string
    _count: DailyTaskCountAggregateOutputType | null
    _avg: DailyTaskAvgAggregateOutputType | null
    _sum: DailyTaskSumAggregateOutputType | null
    _min: DailyTaskMinAggregateOutputType | null
    _max: DailyTaskMaxAggregateOutputType | null
  }

  type GetDailyTaskGroupByPayload<T extends DailyTaskGroupByArgs> = Promise<
    Array<
      PickArray<DailyTaskGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof DailyTaskGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], DailyTaskGroupByOutputType[P]> 
            : GetScalarType<T[P], DailyTaskGroupByOutputType[P]>
        }
      > 
    >


  export type DailyTaskSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    Unit?: boolean
    Quantity?: boolean
    ParentId?: boolean
    CodeReportId?: boolean
    Note?: boolean
    CodeReport?: boolean | CodeReportArgs
  }

  export type DailyTaskInclude = {
    CodeReport?: boolean | CodeReportArgs
  }

  export type DailyTaskGetPayload<
    S extends boolean | null | undefined | DailyTaskArgs,
    U = keyof S
      > = S extends true
        ? DailyTask
    : S extends undefined
    ? never
    : S extends DailyTaskArgs | DailyTaskFindManyArgs
    ?'include' extends U
    ? DailyTask  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DailyTask ?DailyTask [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> : never
  } 
    : DailyTask
  : DailyTask


  type DailyTaskCountArgs = Merge<
    Omit<DailyTaskFindManyArgs, 'select' | 'include'> & {
      select?: DailyTaskCountAggregateInputType | true
    }
  >

  export interface DailyTaskDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DailyTask that matches the filter.
     * @param {DailyTaskFindUniqueArgs} args - Arguments to find a DailyTask
     * @example
     * // Get one DailyTask
     * const dailyTask = await prisma.dailyTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyTaskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyTaskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyTask'> extends True ? CheckSelect<T, Prisma__DailyTaskClient<DailyTask>, Prisma__DailyTaskClient<DailyTaskGetPayload<T>>> : CheckSelect<T, Prisma__DailyTaskClient<DailyTask | null >, Prisma__DailyTaskClient<DailyTaskGetPayload<T> | null >>

    /**
     * Find the first DailyTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskFindFirstArgs} args - Arguments to find a DailyTask
     * @example
     * // Get one DailyTask
     * const dailyTask = await prisma.dailyTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyTaskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyTaskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyTask'> extends True ? CheckSelect<T, Prisma__DailyTaskClient<DailyTask>, Prisma__DailyTaskClient<DailyTaskGetPayload<T>>> : CheckSelect<T, Prisma__DailyTaskClient<DailyTask | null >, Prisma__DailyTaskClient<DailyTaskGetPayload<T> | null >>

    /**
     * Find zero or more DailyTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyTasks
     * const dailyTasks = await prisma.dailyTask.findMany()
     * 
     * // Get first 10 DailyTasks
     * const dailyTasks = await prisma.dailyTask.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dailyTaskWithIdOnly = await prisma.dailyTask.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends DailyTaskFindManyArgs>(
      args?: SelectSubset<T, DailyTaskFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DailyTask>>, PrismaPromise<Array<DailyTaskGetPayload<T>>>>

    /**
     * Create a DailyTask.
     * @param {DailyTaskCreateArgs} args - Arguments to create a DailyTask.
     * @example
     * // Create one DailyTask
     * const DailyTask = await prisma.dailyTask.create({
     *   data: {
     *     // ... data to create a DailyTask
     *   }
     * })
     * 
    **/
    create<T extends DailyTaskCreateArgs>(
      args: SelectSubset<T, DailyTaskCreateArgs>
    ): CheckSelect<T, Prisma__DailyTaskClient<DailyTask>, Prisma__DailyTaskClient<DailyTaskGetPayload<T>>>

    /**
     * Create many DailyTasks.
     *     @param {DailyTaskCreateManyArgs} args - Arguments to create many DailyTasks.
     *     @example
     *     // Create many DailyTasks
     *     const dailyTask = await prisma.dailyTask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyTaskCreateManyArgs>(
      args?: SelectSubset<T, DailyTaskCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DailyTask.
     * @param {DailyTaskDeleteArgs} args - Arguments to delete one DailyTask.
     * @example
     * // Delete one DailyTask
     * const DailyTask = await prisma.dailyTask.delete({
     *   where: {
     *     // ... filter to delete one DailyTask
     *   }
     * })
     * 
    **/
    delete<T extends DailyTaskDeleteArgs>(
      args: SelectSubset<T, DailyTaskDeleteArgs>
    ): CheckSelect<T, Prisma__DailyTaskClient<DailyTask>, Prisma__DailyTaskClient<DailyTaskGetPayload<T>>>

    /**
     * Update one DailyTask.
     * @param {DailyTaskUpdateArgs} args - Arguments to update one DailyTask.
     * @example
     * // Update one DailyTask
     * const dailyTask = await prisma.dailyTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyTaskUpdateArgs>(
      args: SelectSubset<T, DailyTaskUpdateArgs>
    ): CheckSelect<T, Prisma__DailyTaskClient<DailyTask>, Prisma__DailyTaskClient<DailyTaskGetPayload<T>>>

    /**
     * Delete zero or more DailyTasks.
     * @param {DailyTaskDeleteManyArgs} args - Arguments to filter DailyTasks to delete.
     * @example
     * // Delete a few DailyTasks
     * const { count } = await prisma.dailyTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyTaskDeleteManyArgs>(
      args?: SelectSubset<T, DailyTaskDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyTasks
     * const dailyTask = await prisma.dailyTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyTaskUpdateManyArgs>(
      args: SelectSubset<T, DailyTaskUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyTask.
     * @param {DailyTaskUpsertArgs} args - Arguments to update or create a DailyTask.
     * @example
     * // Update or create a DailyTask
     * const dailyTask = await prisma.dailyTask.upsert({
     *   create: {
     *     // ... data to create a DailyTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyTask we want to update
     *   }
     * })
    **/
    upsert<T extends DailyTaskUpsertArgs>(
      args: SelectSubset<T, DailyTaskUpsertArgs>
    ): CheckSelect<T, Prisma__DailyTaskClient<DailyTask>, Prisma__DailyTaskClient<DailyTaskGetPayload<T>>>

    /**
     * Count the number of DailyTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskCountArgs} args - Arguments to filter DailyTasks to count.
     * @example
     * // Count the number of DailyTasks
     * const count = await prisma.dailyTask.count({
     *   where: {
     *     // ... the filter for the DailyTasks we want to count
     *   }
     * })
    **/
    count<T extends DailyTaskCountArgs>(
      args?: Subset<T, DailyTaskCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyTaskAggregateArgs>(args: Subset<T, DailyTaskAggregateArgs>): PrismaPromise<GetDailyTaskAggregateType<T>>

    /**
     * Group by DailyTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyTaskGroupByArgs['orderBy'] }
        : { orderBy?: DailyTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyTaskGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyTaskClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DailyTask findUnique
   */
  export type DailyTaskFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
    /**
     * Throw an Error if a DailyTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DailyTask to fetch.
     * 
    **/
    where: DailyTaskWhereUniqueInput
  }


  /**
   * DailyTask findFirst
   */
  export type DailyTaskFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
    /**
     * Throw an Error if a DailyTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DailyTask to fetch.
     * 
    **/
    where?: DailyTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<DailyTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyTasks.
     * 
    **/
    cursor?: DailyTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyTasks.
     * 
    **/
    distinct?: Enumerable<DailyTaskScalarFieldEnum>
  }


  /**
   * DailyTask findMany
   */
  export type DailyTaskFindManyArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
    /**
     * Filter, which DailyTasks to fetch.
     * 
    **/
    where?: DailyTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<DailyTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyTasks.
     * 
    **/
    cursor?: DailyTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTasks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DailyTaskScalarFieldEnum>
  }


  /**
   * DailyTask create
   */
  export type DailyTaskCreateArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
    /**
     * The data needed to create a DailyTask.
     * 
    **/
    data: XOR<DailyTaskCreateInput, DailyTaskUncheckedCreateInput>
  }


  /**
   * DailyTask createMany
   */
  export type DailyTaskCreateManyArgs = {
    data: Enumerable<DailyTaskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DailyTask update
   */
  export type DailyTaskUpdateArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
    /**
     * The data needed to update a DailyTask.
     * 
    **/
    data: XOR<DailyTaskUpdateInput, DailyTaskUncheckedUpdateInput>
    /**
     * Choose, which DailyTask to update.
     * 
    **/
    where: DailyTaskWhereUniqueInput
  }


  /**
   * DailyTask updateMany
   */
  export type DailyTaskUpdateManyArgs = {
    data: XOR<DailyTaskUpdateManyMutationInput, DailyTaskUncheckedUpdateManyInput>
    where?: DailyTaskWhereInput
  }


  /**
   * DailyTask upsert
   */
  export type DailyTaskUpsertArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
    /**
     * The filter to search for the DailyTask to update in case it exists.
     * 
    **/
    where: DailyTaskWhereUniqueInput
    /**
     * In case the DailyTask found by the `where` argument doesn't exist, create a new DailyTask with this data.
     * 
    **/
    create: XOR<DailyTaskCreateInput, DailyTaskUncheckedCreateInput>
    /**
     * In case the DailyTask was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DailyTaskUpdateInput, DailyTaskUncheckedUpdateInput>
  }


  /**
   * DailyTask delete
   */
  export type DailyTaskDeleteArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
    /**
     * Filter which DailyTask to delete.
     * 
    **/
    where: DailyTaskWhereUniqueInput
  }


  /**
   * DailyTask deleteMany
   */
  export type DailyTaskDeleteManyArgs = {
    where?: DailyTaskWhereInput
  }


  /**
   * DailyTask without action
   */
  export type DailyTaskArgs = {
    /**
     * Select specific fields to fetch from the DailyTask
     * 
    **/
    select?: DailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DailyTaskInclude | null
  }



  /**
   * Model Material
   */


  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
    max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    Status: number | null
    CodeReportId: number | null
  }

  export type MaterialSumAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    Status: number | null
    CodeReportId: number | null
  }

  export type MaterialMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Quantity: number | null
    Status: number | null
    Description: string | null
    Unit: string | null
    CodeReportId: number | null
  }

  export type MaterialMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Quantity: number | null
    Status: number | null
    Description: string | null
    Unit: string | null
    CodeReportId: number | null
  }

  export type MaterialCountAggregateOutputType = {
    Id: number
    Name: number
    Quantity: number
    Status: number
    Description: number
    Unit: number
    CodeReportId: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    Id?: true
    Quantity?: true
    Status?: true
    CodeReportId?: true
  }

  export type MaterialSumAggregateInputType = {
    Id?: true
    Quantity?: true
    Status?: true
    CodeReportId?: true
  }

  export type MaterialMinAggregateInputType = {
    Id?: true
    Name?: true
    Quantity?: true
    Status?: true
    Description?: true
    Unit?: true
    CodeReportId?: true
  }

  export type MaterialMaxAggregateInputType = {
    Id?: true
    Name?: true
    Quantity?: true
    Status?: true
    Description?: true
    Unit?: true
    CodeReportId?: true
  }

  export type MaterialCountAggregateInputType = {
    Id?: true
    Name?: true
    Quantity?: true
    Status?: true
    Description?: true
    Unit?: true
    CodeReportId?: true
    _all?: true
  }

  export type MaterialAggregateArgs = {
    /**
     * Filter which Material to aggregate.
     * 
    **/
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     * 
    **/
    orderBy?: Enumerable<MaterialOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }


    
    
  export type MaterialGroupByArgs = {
    where?: MaterialWhereInput
    orderBy?: Enumerable<MaterialOrderByInput>
    by: Array<MaterialScalarFieldEnum>
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }


  export type MaterialGroupByOutputType = {
    Id: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReportId: number
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Promise<
    Array<
      PickArray<MaterialGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MaterialGroupByOutputType[P]> 
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      > 
    >


  export type MaterialSelect = {
    Id?: boolean
    Name?: boolean
    Quantity?: boolean
    Status?: boolean
    Description?: boolean
    Unit?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | CodeReportArgs
  }

  export type MaterialInclude = {
    CodeReport?: boolean | CodeReportArgs
  }

  export type MaterialGetPayload<
    S extends boolean | null | undefined | MaterialArgs,
    U = keyof S
      > = S extends true
        ? Material
    : S extends undefined
    ? never
    : S extends MaterialArgs | MaterialFindManyArgs
    ?'include' extends U
    ? Material  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Material ?Material [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> : never
  } 
    : Material
  : Material


  type MaterialCountArgs = Merge<
    Omit<MaterialFindManyArgs, 'select' | 'include'> & {
      select?: MaterialCountAggregateInputType | true
    }
  >

  export interface MaterialDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaterialFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MaterialFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Material'> extends True ? CheckSelect<T, Prisma__MaterialClient<Material>, Prisma__MaterialClient<MaterialGetPayload<T>>> : CheckSelect<T, Prisma__MaterialClient<Material | null >, Prisma__MaterialClient<MaterialGetPayload<T> | null >>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaterialFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MaterialFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Material'> extends True ? CheckSelect<T, Prisma__MaterialClient<Material>, Prisma__MaterialClient<MaterialGetPayload<T>>> : CheckSelect<T, Prisma__MaterialClient<Material | null >, Prisma__MaterialClient<MaterialGetPayload<T> | null >>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends MaterialFindManyArgs>(
      args?: SelectSubset<T, MaterialFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Material>>, PrismaPromise<Array<MaterialGetPayload<T>>>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
    **/
    create<T extends MaterialCreateArgs>(
      args: SelectSubset<T, MaterialCreateArgs>
    ): CheckSelect<T, Prisma__MaterialClient<Material>, Prisma__MaterialClient<MaterialGetPayload<T>>>

    /**
     * Create many Materials.
     *     @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     *     @example
     *     // Create many Materials
     *     const material = await prisma.material.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaterialCreateManyArgs>(
      args?: SelectSubset<T, MaterialCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
    **/
    delete<T extends MaterialDeleteArgs>(
      args: SelectSubset<T, MaterialDeleteArgs>
    ): CheckSelect<T, Prisma__MaterialClient<Material>, Prisma__MaterialClient<MaterialGetPayload<T>>>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaterialUpdateArgs>(
      args: SelectSubset<T, MaterialUpdateArgs>
    ): CheckSelect<T, Prisma__MaterialClient<Material>, Prisma__MaterialClient<MaterialGetPayload<T>>>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaterialDeleteManyArgs>(
      args?: SelectSubset<T, MaterialDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaterialUpdateManyArgs>(
      args: SelectSubset<T, MaterialUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
    **/
    upsert<T extends MaterialUpsertArgs>(
      args: SelectSubset<T, MaterialUpsertArgs>
    ): CheckSelect<T, Prisma__MaterialClient<Material>, Prisma__MaterialClient<MaterialGetPayload<T>>>

    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MaterialClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
    /**
     * Throw an Error if a Material can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Material to fetch.
     * 
    **/
    where: MaterialWhereUniqueInput
  }


  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
    /**
     * Throw an Error if a Material can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Material to fetch.
     * 
    **/
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     * 
    **/
    orderBy?: Enumerable<MaterialOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     * 
    **/
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     * 
    **/
    distinct?: Enumerable<MaterialScalarFieldEnum>
  }


  /**
   * Material findMany
   */
  export type MaterialFindManyArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
    /**
     * Filter, which Materials to fetch.
     * 
    **/
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     * 
    **/
    orderBy?: Enumerable<MaterialOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     * 
    **/
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MaterialScalarFieldEnum>
  }


  /**
   * Material create
   */
  export type MaterialCreateArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
    /**
     * The data needed to create a Material.
     * 
    **/
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }


  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs = {
    data: Enumerable<MaterialCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Material update
   */
  export type MaterialUpdateArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
    /**
     * The data needed to update a Material.
     * 
    **/
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     * 
    **/
    where: MaterialWhereUniqueInput
  }


  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs = {
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    where?: MaterialWhereInput
  }


  /**
   * Material upsert
   */
  export type MaterialUpsertArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
    /**
     * The filter to search for the Material to update in case it exists.
     * 
    **/
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     * 
    **/
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }


  /**
   * Material delete
   */
  export type MaterialDeleteArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
    /**
     * Filter which Material to delete.
     * 
    **/
    where: MaterialWhereUniqueInput
  }


  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs = {
    where?: MaterialWhereInput
  }


  /**
   * Material without action
   */
  export type MaterialArgs = {
    /**
     * Select specific fields to fetch from the Material
     * 
    **/
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MaterialInclude | null
  }



  /**
   * Model Project
   */


  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
    max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    Id: number | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
  }

  export type ProjectSumAggregateOutputType = {
    Id: number | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
  }

  export type ProjectMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    IsDelete: boolean | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
    Description: string | null
    Unit: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    IsDelete: boolean | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
    Description: string | null
    Unit: string | null
  }

  export type ProjectCountAggregateOutputType = {
    Id: number
    Name: number
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete: number
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: number
    Unit: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    Id?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
  }

  export type ProjectSumAggregateInputType = {
    Id?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
  }

  export type ProjectMinAggregateInputType = {
    Id?: true
    Name?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    IsDelete?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
    Description?: true
    Unit?: true
  }

  export type ProjectMaxAggregateInputType = {
    Id?: true
    Name?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    IsDelete?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
    Description?: true
    Unit?: true
  }

  export type ProjectCountAggregateInputType = {
    Id?: true
    Name?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    IsDelete?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
    Description?: true
    Unit?: true
    _all?: true
  }

  export type ProjectAggregateArgs = {
    /**
     * Filter which Project to aggregate.
     * 
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }


    
    
  export type ProjectGroupByArgs = {
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByInput>
    by: Array<ProjectScalarFieldEnum>
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    Id: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete: boolean
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Promise<
    Array<
      PickArray<ProjectGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProjectGroupByOutputType[P]> 
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      > 
    >


  export type ProjectSelect = {
    Id?: boolean
    Name?: boolean
    BudgetPrice?: boolean
    Quantity?: boolean
    Done?: boolean
    IsDelete?: boolean
    CodeProjectId?: boolean
    ParentId?: boolean
    EstimatedDuration?: boolean
    Timeline?: boolean
    Price?: boolean
    Description?: boolean
    Unit?: boolean
    CodeProject?: boolean | CodeProjectArgs
  }

  export type ProjectInclude = {
    CodeProject?: boolean | CodeProjectArgs
  }

  export type ProjectGetPayload<
    S extends boolean | null | undefined | ProjectArgs,
    U = keyof S
      > = S extends true
        ? Project
    : S extends undefined
    ? never
    : S extends ProjectArgs | ProjectFindManyArgs
    ?'include' extends U
    ? Project  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeProject'
        ? CodeProjectGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Project ?Project [P]
  : 
          P extends 'CodeProject'
        ? CodeProjectGetPayload<S['select'][P]> : never
  } 
    : Project
  : Project


  type ProjectCountArgs = Merge<
    Omit<ProjectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }
  >

  export interface ProjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs>(
      args?: SelectSubset<T, ProjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Project>>, PrismaPromise<Array<ProjectGetPayload<T>>>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs>(
      args: SelectSubset<T, ProjectCreateArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Create many Projects.
     *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs>(
      args?: SelectSubset<T, ProjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs>(
      args: SelectSubset<T, ProjectDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs>(
      args: SelectSubset<T, ProjectUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs>(
      args?: SelectSubset<T, ProjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs>(
      args: SelectSubset<T, ProjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs>(
      args: SelectSubset<T, ProjectUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeProject<T extends CodeProjectArgs = {}>(args?: Subset<T, CodeProjectArgs>): CheckSelect<T, Prisma__CodeProjectClient<CodeProject | null >, Prisma__CodeProjectClient<CodeProjectGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Throw an Error if a Project can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Project to fetch.
     * 
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Throw an Error if a Project can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Project to fetch.
     * 
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     * 
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     * 
    **/
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project findMany
   */
  export type ProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Filter, which Projects to fetch.
     * 
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     * 
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * The data needed to create a Project.
     * 
    **/
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs = {
    data: Enumerable<ProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * The data needed to update a Project.
     * 
    **/
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     * 
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs = {
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * The filter to search for the Project to update in case it exists.
     * 
    **/
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     * 
    **/
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
    /**
     * Filter which Project to delete.
     * 
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs = {
    where?: ProjectWhereInput
  }


  /**
   * Project without action
   */
  export type ProjectArgs = {
    /**
     * Select specific fields to fetch from the Project
     * 
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectInclude | null
  }



  /**
   * Model ProjectTask
   */


  export type AggregateProjectTask = {
    _count: ProjectTaskCountAggregateOutputType | null
    count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
    max: ProjectTaskMaxAggregateOutputType | null
  }

  export type ProjectTaskAvgAggregateOutputType = {
    Id: number | null
    ParentId: number | null
    CreatedBy: number | null
  }

  export type ProjectTaskSumAggregateOutputType = {
    Id: number | null
    ParentId: number | null
    CreatedBy: number | null
  }

  export type ProjectTaskMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    ParentId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ProjectTaskMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    ParentId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ProjectTaskCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    ParentId: number
    CreatedBy: number
    CreatedDate: number
    _all: number
  }


  export type ProjectTaskAvgAggregateInputType = {
    Id?: true
    ParentId?: true
    CreatedBy?: true
  }

  export type ProjectTaskSumAggregateInputType = {
    Id?: true
    ParentId?: true
    CreatedBy?: true
  }

  export type ProjectTaskMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    ParentId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ProjectTaskMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    ParentId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ProjectTaskCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    ParentId?: true
    CreatedBy?: true
    CreatedDate?: true
    _all?: true
  }

  export type ProjectTaskAggregateArgs = {
    /**
     * Filter which ProjectTask to aggregate.
     * 
    **/
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTasks
    **/
    _count?: true | ProjectTaskCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ProjectTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTaskAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ProjectTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTaskSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ProjectTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTaskMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ProjectTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTaskMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ProjectTaskMaxAggregateInputType
  }

  export type GetProjectTaskAggregateType<T extends ProjectTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTask[P]>
      : GetScalarType<T[P], AggregateProjectTask[P]>
  }


    
    
  export type ProjectTaskGroupByArgs = {
    where?: ProjectTaskWhereInput
    orderBy?: Enumerable<ProjectTaskOrderByInput>
    by: Array<ProjectTaskScalarFieldEnum>
    having?: ProjectTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTaskCountAggregateInputType | true
    _avg?: ProjectTaskAvgAggregateInputType
    _sum?: ProjectTaskSumAggregateInputType
    _min?: ProjectTaskMinAggregateInputType
    _max?: ProjectTaskMaxAggregateInputType
  }


  export type ProjectTaskGroupByOutputType = {
    Id: number
    Name: string
    Description: string
    ParentId: number
    CreatedBy: number
    CreatedDate: Date
    _count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  type GetProjectTaskGroupByPayload<T extends ProjectTaskGroupByArgs> = Promise<
    Array<
      PickArray<ProjectTaskGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProjectTaskGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]> 
            : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
        }
      > 
    >


  export type ProjectTaskSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    ParentId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    User?: boolean | UserArgs
  }

  export type ProjectTaskInclude = {
    User?: boolean | UserArgs
  }

  export type ProjectTaskGetPayload<
    S extends boolean | null | undefined | ProjectTaskArgs,
    U = keyof S
      > = S extends true
        ? ProjectTask
    : S extends undefined
    ? never
    : S extends ProjectTaskArgs | ProjectTaskFindManyArgs
    ?'include' extends U
    ? ProjectTask  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProjectTask ?ProjectTask [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ProjectTask
  : ProjectTask


  type ProjectTaskCountArgs = Merge<
    Omit<ProjectTaskFindManyArgs, 'select' | 'include'> & {
      select?: ProjectTaskCountAggregateInputType | true
    }
  >

  export interface ProjectTaskDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProjectTask that matches the filter.
     * @param {ProjectTaskFindUniqueArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectTaskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectTaskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectTask'> extends True ? CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask>, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T>>> : CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask | null >, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T> | null >>

    /**
     * Find the first ProjectTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindFirstArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectTaskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectTaskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectTask'> extends True ? CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask>, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T>>> : CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask | null >, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T> | null >>

    /**
     * Find zero or more ProjectTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany()
     * 
     * // Get first 10 ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const projectTaskWithIdOnly = await prisma.projectTask.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ProjectTaskFindManyArgs>(
      args?: SelectSubset<T, ProjectTaskFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProjectTask>>, PrismaPromise<Array<ProjectTaskGetPayload<T>>>>

    /**
     * Create a ProjectTask.
     * @param {ProjectTaskCreateArgs} args - Arguments to create a ProjectTask.
     * @example
     * // Create one ProjectTask
     * const ProjectTask = await prisma.projectTask.create({
     *   data: {
     *     // ... data to create a ProjectTask
     *   }
     * })
     * 
    **/
    create<T extends ProjectTaskCreateArgs>(
      args: SelectSubset<T, ProjectTaskCreateArgs>
    ): CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask>, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T>>>

    /**
     * Create many ProjectTasks.
     *     @param {ProjectTaskCreateManyArgs} args - Arguments to create many ProjectTasks.
     *     @example
     *     // Create many ProjectTasks
     *     const projectTask = await prisma.projectTask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectTaskCreateManyArgs>(
      args?: SelectSubset<T, ProjectTaskCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectTask.
     * @param {ProjectTaskDeleteArgs} args - Arguments to delete one ProjectTask.
     * @example
     * // Delete one ProjectTask
     * const ProjectTask = await prisma.projectTask.delete({
     *   where: {
     *     // ... filter to delete one ProjectTask
     *   }
     * })
     * 
    **/
    delete<T extends ProjectTaskDeleteArgs>(
      args: SelectSubset<T, ProjectTaskDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask>, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T>>>

    /**
     * Update one ProjectTask.
     * @param {ProjectTaskUpdateArgs} args - Arguments to update one ProjectTask.
     * @example
     * // Update one ProjectTask
     * const projectTask = await prisma.projectTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectTaskUpdateArgs>(
      args: SelectSubset<T, ProjectTaskUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask>, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T>>>

    /**
     * Delete zero or more ProjectTasks.
     * @param {ProjectTaskDeleteManyArgs} args - Arguments to filter ProjectTasks to delete.
     * @example
     * // Delete a few ProjectTasks
     * const { count } = await prisma.projectTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectTaskDeleteManyArgs>(
      args?: SelectSubset<T, ProjectTaskDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTasks
     * const projectTask = await prisma.projectTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectTaskUpdateManyArgs>(
      args: SelectSubset<T, ProjectTaskUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTask.
     * @param {ProjectTaskUpsertArgs} args - Arguments to update or create a ProjectTask.
     * @example
     * // Update or create a ProjectTask
     * const projectTask = await prisma.projectTask.upsert({
     *   create: {
     *     // ... data to create a ProjectTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTask we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectTaskUpsertArgs>(
      args: SelectSubset<T, ProjectTaskUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectTaskClient<ProjectTask>, Prisma__ProjectTaskClient<ProjectTaskGetPayload<T>>>

    /**
     * Count the number of ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskCountArgs} args - Arguments to filter ProjectTasks to count.
     * @example
     * // Count the number of ProjectTasks
     * const count = await prisma.projectTask.count({
     *   where: {
     *     // ... the filter for the ProjectTasks we want to count
     *   }
     * })
    **/
    count<T extends ProjectTaskCountArgs>(
      args?: Subset<T, ProjectTaskCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTaskAggregateArgs>(args: Subset<T, ProjectTaskAggregateArgs>): PrismaPromise<GetProjectTaskAggregateType<T>>

    /**
     * Group by ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTaskGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTaskGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectTaskClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProjectTask findUnique
   */
  export type ProjectTaskFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
    /**
     * Throw an Error if a ProjectTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectTask to fetch.
     * 
    **/
    where: ProjectTaskWhereUniqueInput
  }


  /**
   * ProjectTask findFirst
   */
  export type ProjectTaskFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
    /**
     * Throw an Error if a ProjectTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectTask to fetch.
     * 
    **/
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTasks.
     * 
    **/
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTasks.
     * 
    **/
    distinct?: Enumerable<ProjectTaskScalarFieldEnum>
  }


  /**
   * ProjectTask findMany
   */
  export type ProjectTaskFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
    /**
     * Filter, which ProjectTasks to fetch.
     * 
    **/
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<ProjectTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTasks.
     * 
    **/
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProjectTaskScalarFieldEnum>
  }


  /**
   * ProjectTask create
   */
  export type ProjectTaskCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
    /**
     * The data needed to create a ProjectTask.
     * 
    **/
    data: XOR<ProjectTaskCreateInput, ProjectTaskUncheckedCreateInput>
  }


  /**
   * ProjectTask createMany
   */
  export type ProjectTaskCreateManyArgs = {
    data: Enumerable<ProjectTaskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProjectTask update
   */
  export type ProjectTaskUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
    /**
     * The data needed to update a ProjectTask.
     * 
    **/
    data: XOR<ProjectTaskUpdateInput, ProjectTaskUncheckedUpdateInput>
    /**
     * Choose, which ProjectTask to update.
     * 
    **/
    where: ProjectTaskWhereUniqueInput
  }


  /**
   * ProjectTask updateMany
   */
  export type ProjectTaskUpdateManyArgs = {
    data: XOR<ProjectTaskUpdateManyMutationInput, ProjectTaskUncheckedUpdateManyInput>
    where?: ProjectTaskWhereInput
  }


  /**
   * ProjectTask upsert
   */
  export type ProjectTaskUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
    /**
     * The filter to search for the ProjectTask to update in case it exists.
     * 
    **/
    where: ProjectTaskWhereUniqueInput
    /**
     * In case the ProjectTask found by the `where` argument doesn't exist, create a new ProjectTask with this data.
     * 
    **/
    create: XOR<ProjectTaskCreateInput, ProjectTaskUncheckedCreateInput>
    /**
     * In case the ProjectTask was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProjectTaskUpdateInput, ProjectTaskUncheckedUpdateInput>
  }


  /**
   * ProjectTask delete
   */
  export type ProjectTaskDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
    /**
     * Filter which ProjectTask to delete.
     * 
    **/
    where: ProjectTaskWhereUniqueInput
  }


  /**
   * ProjectTask deleteMany
   */
  export type ProjectTaskDeleteManyArgs = {
    where?: ProjectTaskWhereInput
  }


  /**
   * ProjectTask without action
   */
  export type ProjectTaskArgs = {
    /**
     * Select specific fields to fetch from the ProjectTask
     * 
    **/
    select?: ProjectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProjectTaskInclude | null
  }



  /**
   * Model RequestForInformation
   */


  export type AggregateRequestForInformation = {
    _count: RequestForInformationCountAggregateOutputType | null
    count: RequestForInformationCountAggregateOutputType | null
    _avg: RequestForInformationAvgAggregateOutputType | null
    avg: RequestForInformationAvgAggregateOutputType | null
    _sum: RequestForInformationSumAggregateOutputType | null
    sum: RequestForInformationSumAggregateOutputType | null
    _min: RequestForInformationMinAggregateOutputType | null
    min: RequestForInformationMinAggregateOutputType | null
    _max: RequestForInformationMaxAggregateOutputType | null
    max: RequestForInformationMaxAggregateOutputType | null
  }

  export type RequestForInformationAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type RequestForInformationSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type RequestForInformationMinAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Description: string | null
    Header: string | null
    AddressedFor: string | null
    IsDelete: boolean | null
  }

  export type RequestForInformationMaxAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Description: string | null
    Header: string | null
    AddressedFor: string | null
    IsDelete: boolean | null
  }

  export type RequestForInformationCountAggregateOutputType = {
    Id: number
    CodeReportId: number
    Description: number
    Header: number
    AddressedFor: number
    IsDelete: number
    _all: number
  }


  export type RequestForInformationAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type RequestForInformationSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type RequestForInformationMinAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Description?: true
    Header?: true
    AddressedFor?: true
    IsDelete?: true
  }

  export type RequestForInformationMaxAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Description?: true
    Header?: true
    AddressedFor?: true
    IsDelete?: true
  }

  export type RequestForInformationCountAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Description?: true
    Header?: true
    AddressedFor?: true
    IsDelete?: true
    _all?: true
  }

  export type RequestForInformationAggregateArgs = {
    /**
     * Filter which RequestForInformation to aggregate.
     * 
    **/
    where?: RequestForInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestForInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestForInformations
    **/
    _count?: true | RequestForInformationCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | RequestForInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestForInformationAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: RequestForInformationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestForInformationSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: RequestForInformationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestForInformationMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: RequestForInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestForInformationMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: RequestForInformationMaxAggregateInputType
  }

  export type GetRequestForInformationAggregateType<T extends RequestForInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestForInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestForInformation[P]>
      : GetScalarType<T[P], AggregateRequestForInformation[P]>
  }


    
    
  export type RequestForInformationGroupByArgs = {
    where?: RequestForInformationWhereInput
    orderBy?: Enumerable<RequestForInformationOrderByInput>
    by: Array<RequestForInformationScalarFieldEnum>
    having?: RequestForInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestForInformationCountAggregateInputType | true
    _avg?: RequestForInformationAvgAggregateInputType
    _sum?: RequestForInformationSumAggregateInputType
    _min?: RequestForInformationMinAggregateInputType
    _max?: RequestForInformationMaxAggregateInputType
  }


  export type RequestForInformationGroupByOutputType = {
    Id: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete: boolean
    _count: RequestForInformationCountAggregateOutputType | null
    _avg: RequestForInformationAvgAggregateOutputType | null
    _sum: RequestForInformationSumAggregateOutputType | null
    _min: RequestForInformationMinAggregateOutputType | null
    _max: RequestForInformationMaxAggregateOutputType | null
  }

  type GetRequestForInformationGroupByPayload<T extends RequestForInformationGroupByArgs> = Promise<
    Array<
      PickArray<RequestForInformationGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RequestForInformationGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RequestForInformationGroupByOutputType[P]> 
            : GetScalarType<T[P], RequestForInformationGroupByOutputType[P]>
        }
      > 
    >


  export type RequestForInformationSelect = {
    Id?: boolean
    CodeReportId?: boolean
    Description?: boolean
    Header?: boolean
    AddressedFor?: boolean
    IsDelete?: boolean
    CodeReport?: boolean | CodeReportArgs
    RequestForInformationAnswer?: boolean | RequestForInformationAnswerFindManyArgs
    RequestForInformationDocument?: boolean | RequestForInformationDocumentFindManyArgs
  }

  export type RequestForInformationInclude = {
    CodeReport?: boolean | CodeReportArgs
    RequestForInformationAnswer?: boolean | RequestForInformationAnswerFindManyArgs
    RequestForInformationDocument?: boolean | RequestForInformationDocumentFindManyArgs
  }

  export type RequestForInformationGetPayload<
    S extends boolean | null | undefined | RequestForInformationArgs,
    U = keyof S
      > = S extends true
        ? RequestForInformation
    : S extends undefined
    ? never
    : S extends RequestForInformationArgs | RequestForInformationFindManyArgs
    ?'include' extends U
    ? RequestForInformation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> :
        P extends 'RequestForInformationAnswer'
        ? Array < RequestForInformationAnswerGetPayload<S['include'][P]>>  :
        P extends 'RequestForInformationDocument'
        ? Array < RequestForInformationDocumentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RequestForInformation ?RequestForInformation [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> :
        P extends 'RequestForInformationAnswer'
        ? Array < RequestForInformationAnswerGetPayload<S['select'][P]>>  :
        P extends 'RequestForInformationDocument'
        ? Array < RequestForInformationDocumentGetPayload<S['select'][P]>>  : never
  } 
    : RequestForInformation
  : RequestForInformation


  type RequestForInformationCountArgs = Merge<
    Omit<RequestForInformationFindManyArgs, 'select' | 'include'> & {
      select?: RequestForInformationCountAggregateInputType | true
    }
  >

  export interface RequestForInformationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestForInformation that matches the filter.
     * @param {RequestForInformationFindUniqueArgs} args - Arguments to find a RequestForInformation
     * @example
     * // Get one RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestForInformationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestForInformationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestForInformation'> extends True ? CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation>, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T>>> : CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation | null >, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T> | null >>

    /**
     * Find the first RequestForInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationFindFirstArgs} args - Arguments to find a RequestForInformation
     * @example
     * // Get one RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestForInformationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestForInformationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestForInformation'> extends True ? CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation>, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T>>> : CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation | null >, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T> | null >>

    /**
     * Find zero or more RequestForInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestForInformations
     * const requestForInformations = await prisma.requestForInformation.findMany()
     * 
     * // Get first 10 RequestForInformations
     * const requestForInformations = await prisma.requestForInformation.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const requestForInformationWithIdOnly = await prisma.requestForInformation.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends RequestForInformationFindManyArgs>(
      args?: SelectSubset<T, RequestForInformationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestForInformation>>, PrismaPromise<Array<RequestForInformationGetPayload<T>>>>

    /**
     * Create a RequestForInformation.
     * @param {RequestForInformationCreateArgs} args - Arguments to create a RequestForInformation.
     * @example
     * // Create one RequestForInformation
     * const RequestForInformation = await prisma.requestForInformation.create({
     *   data: {
     *     // ... data to create a RequestForInformation
     *   }
     * })
     * 
    **/
    create<T extends RequestForInformationCreateArgs>(
      args: SelectSubset<T, RequestForInformationCreateArgs>
    ): CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation>, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T>>>

    /**
     * Create many RequestForInformations.
     *     @param {RequestForInformationCreateManyArgs} args - Arguments to create many RequestForInformations.
     *     @example
     *     // Create many RequestForInformations
     *     const requestForInformation = await prisma.requestForInformation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestForInformationCreateManyArgs>(
      args?: SelectSubset<T, RequestForInformationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestForInformation.
     * @param {RequestForInformationDeleteArgs} args - Arguments to delete one RequestForInformation.
     * @example
     * // Delete one RequestForInformation
     * const RequestForInformation = await prisma.requestForInformation.delete({
     *   where: {
     *     // ... filter to delete one RequestForInformation
     *   }
     * })
     * 
    **/
    delete<T extends RequestForInformationDeleteArgs>(
      args: SelectSubset<T, RequestForInformationDeleteArgs>
    ): CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation>, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T>>>

    /**
     * Update one RequestForInformation.
     * @param {RequestForInformationUpdateArgs} args - Arguments to update one RequestForInformation.
     * @example
     * // Update one RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestForInformationUpdateArgs>(
      args: SelectSubset<T, RequestForInformationUpdateArgs>
    ): CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation>, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T>>>

    /**
     * Delete zero or more RequestForInformations.
     * @param {RequestForInformationDeleteManyArgs} args - Arguments to filter RequestForInformations to delete.
     * @example
     * // Delete a few RequestForInformations
     * const { count } = await prisma.requestForInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestForInformationDeleteManyArgs>(
      args?: SelectSubset<T, RequestForInformationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestForInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestForInformations
     * const requestForInformation = await prisma.requestForInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestForInformationUpdateManyArgs>(
      args: SelectSubset<T, RequestForInformationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestForInformation.
     * @param {RequestForInformationUpsertArgs} args - Arguments to update or create a RequestForInformation.
     * @example
     * // Update or create a RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.upsert({
     *   create: {
     *     // ... data to create a RequestForInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestForInformation we want to update
     *   }
     * })
    **/
    upsert<T extends RequestForInformationUpsertArgs>(
      args: SelectSubset<T, RequestForInformationUpsertArgs>
    ): CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation>, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T>>>

    /**
     * Count the number of RequestForInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationCountArgs} args - Arguments to filter RequestForInformations to count.
     * @example
     * // Count the number of RequestForInformations
     * const count = await prisma.requestForInformation.count({
     *   where: {
     *     // ... the filter for the RequestForInformations we want to count
     *   }
     * })
    **/
    count<T extends RequestForInformationCountArgs>(
      args?: Subset<T, RequestForInformationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestForInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestForInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestForInformationAggregateArgs>(args: Subset<T, RequestForInformationAggregateArgs>): PrismaPromise<GetRequestForInformationAggregateType<T>>

    /**
     * Group by RequestForInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestForInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestForInformationGroupByArgs['orderBy'] }
        : { orderBy?: RequestForInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestForInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestForInformationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestForInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestForInformationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    RequestForInformationAnswer<T extends RequestForInformationAnswerFindManyArgs = {}>(args?: Subset<T, RequestForInformationAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestForInformationAnswer>>, PrismaPromise<Array<RequestForInformationAnswerGetPayload<T>>>>;

    RequestForInformationDocument<T extends RequestForInformationDocumentFindManyArgs = {}>(args?: Subset<T, RequestForInformationDocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestForInformationDocument>>, PrismaPromise<Array<RequestForInformationDocumentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RequestForInformation findUnique
   */
  export type RequestForInformationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
    /**
     * Throw an Error if a RequestForInformation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestForInformation to fetch.
     * 
    **/
    where: RequestForInformationWhereUniqueInput
  }


  /**
   * RequestForInformation findFirst
   */
  export type RequestForInformationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
    /**
     * Throw an Error if a RequestForInformation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestForInformation to fetch.
     * 
    **/
    where?: RequestForInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestForInformations.
     * 
    **/
    cursor?: RequestForInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestForInformations.
     * 
    **/
    distinct?: Enumerable<RequestForInformationScalarFieldEnum>
  }


  /**
   * RequestForInformation findMany
   */
  export type RequestForInformationFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
    /**
     * Filter, which RequestForInformations to fetch.
     * 
    **/
    where?: RequestForInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestForInformations.
     * 
    **/
    cursor?: RequestForInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestForInformationScalarFieldEnum>
  }


  /**
   * RequestForInformation create
   */
  export type RequestForInformationCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
    /**
     * The data needed to create a RequestForInformation.
     * 
    **/
    data: XOR<RequestForInformationCreateInput, RequestForInformationUncheckedCreateInput>
  }


  /**
   * RequestForInformation createMany
   */
  export type RequestForInformationCreateManyArgs = {
    data: Enumerable<RequestForInformationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestForInformation update
   */
  export type RequestForInformationUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
    /**
     * The data needed to update a RequestForInformation.
     * 
    **/
    data: XOR<RequestForInformationUpdateInput, RequestForInformationUncheckedUpdateInput>
    /**
     * Choose, which RequestForInformation to update.
     * 
    **/
    where: RequestForInformationWhereUniqueInput
  }


  /**
   * RequestForInformation updateMany
   */
  export type RequestForInformationUpdateManyArgs = {
    data: XOR<RequestForInformationUpdateManyMutationInput, RequestForInformationUncheckedUpdateManyInput>
    where?: RequestForInformationWhereInput
  }


  /**
   * RequestForInformation upsert
   */
  export type RequestForInformationUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
    /**
     * The filter to search for the RequestForInformation to update in case it exists.
     * 
    **/
    where: RequestForInformationWhereUniqueInput
    /**
     * In case the RequestForInformation found by the `where` argument doesn't exist, create a new RequestForInformation with this data.
     * 
    **/
    create: XOR<RequestForInformationCreateInput, RequestForInformationUncheckedCreateInput>
    /**
     * In case the RequestForInformation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestForInformationUpdateInput, RequestForInformationUncheckedUpdateInput>
  }


  /**
   * RequestForInformation delete
   */
  export type RequestForInformationDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
    /**
     * Filter which RequestForInformation to delete.
     * 
    **/
    where: RequestForInformationWhereUniqueInput
  }


  /**
   * RequestForInformation deleteMany
   */
  export type RequestForInformationDeleteManyArgs = {
    where?: RequestForInformationWhereInput
  }


  /**
   * RequestForInformation without action
   */
  export type RequestForInformationArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformation
     * 
    **/
    select?: RequestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationInclude | null
  }



  /**
   * Model RequestForInformationAnswer
   */


  export type AggregateRequestForInformationAnswer = {
    _count: RequestForInformationAnswerCountAggregateOutputType | null
    count: RequestForInformationAnswerCountAggregateOutputType | null
    _avg: RequestForInformationAnswerAvgAggregateOutputType | null
    avg: RequestForInformationAnswerAvgAggregateOutputType | null
    _sum: RequestForInformationAnswerSumAggregateOutputType | null
    sum: RequestForInformationAnswerSumAggregateOutputType | null
    _min: RequestForInformationAnswerMinAggregateOutputType | null
    min: RequestForInformationAnswerMinAggregateOutputType | null
    _max: RequestForInformationAnswerMaxAggregateOutputType | null
    max: RequestForInformationAnswerMaxAggregateOutputType | null
  }

  export type RequestForInformationAnswerAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationAnswerSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationAnswerMinAggregateOutputType = {
    Id: number | null
    Answer: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    RequestForInformationId: number | null
    IsDelete: boolean | null
  }

  export type RequestForInformationAnswerMaxAggregateOutputType = {
    Id: number | null
    Answer: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    RequestForInformationId: number | null
    IsDelete: boolean | null
  }

  export type RequestForInformationAnswerCountAggregateOutputType = {
    Id: number
    Answer: number
    CreatedBy: number
    CreatedDate: number
    RequestForInformationId: number
    IsDelete: number
    _all: number
  }


  export type RequestForInformationAnswerAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationAnswerSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationAnswerMinAggregateInputType = {
    Id?: true
    Answer?: true
    CreatedBy?: true
    CreatedDate?: true
    RequestForInformationId?: true
    IsDelete?: true
  }

  export type RequestForInformationAnswerMaxAggregateInputType = {
    Id?: true
    Answer?: true
    CreatedBy?: true
    CreatedDate?: true
    RequestForInformationId?: true
    IsDelete?: true
  }

  export type RequestForInformationAnswerCountAggregateInputType = {
    Id?: true
    Answer?: true
    CreatedBy?: true
    CreatedDate?: true
    RequestForInformationId?: true
    IsDelete?: true
    _all?: true
  }

  export type RequestForInformationAnswerAggregateArgs = {
    /**
     * Filter which RequestForInformationAnswer to aggregate.
     * 
    **/
    where?: RequestForInformationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformationAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationAnswerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestForInformationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformationAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformationAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestForInformationAnswers
    **/
    _count?: true | RequestForInformationAnswerCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | RequestForInformationAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestForInformationAnswerAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: RequestForInformationAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestForInformationAnswerSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: RequestForInformationAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestForInformationAnswerMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: RequestForInformationAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestForInformationAnswerMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: RequestForInformationAnswerMaxAggregateInputType
  }

  export type GetRequestForInformationAnswerAggregateType<T extends RequestForInformationAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestForInformationAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestForInformationAnswer[P]>
      : GetScalarType<T[P], AggregateRequestForInformationAnswer[P]>
  }


    
    
  export type RequestForInformationAnswerGroupByArgs = {
    where?: RequestForInformationAnswerWhereInput
    orderBy?: Enumerable<RequestForInformationAnswerOrderByInput>
    by: Array<RequestForInformationAnswerScalarFieldEnum>
    having?: RequestForInformationAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestForInformationAnswerCountAggregateInputType | true
    _avg?: RequestForInformationAnswerAvgAggregateInputType
    _sum?: RequestForInformationAnswerSumAggregateInputType
    _min?: RequestForInformationAnswerMinAggregateInputType
    _max?: RequestForInformationAnswerMaxAggregateInputType
  }


  export type RequestForInformationAnswerGroupByOutputType = {
    Id: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date
    RequestForInformationId: number
    IsDelete: boolean
    _count: RequestForInformationAnswerCountAggregateOutputType | null
    _avg: RequestForInformationAnswerAvgAggregateOutputType | null
    _sum: RequestForInformationAnswerSumAggregateOutputType | null
    _min: RequestForInformationAnswerMinAggregateOutputType | null
    _max: RequestForInformationAnswerMaxAggregateOutputType | null
  }

  type GetRequestForInformationAnswerGroupByPayload<T extends RequestForInformationAnswerGroupByArgs> = Promise<
    Array<
      PickArray<RequestForInformationAnswerGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RequestForInformationAnswerGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RequestForInformationAnswerGroupByOutputType[P]> 
            : GetScalarType<T[P], RequestForInformationAnswerGroupByOutputType[P]>
        }
      > 
    >


  export type RequestForInformationAnswerSelect = {
    Id?: boolean
    Answer?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    RequestForInformationId?: boolean
    IsDelete?: boolean
    User?: boolean | UserArgs
    RequestForInformation?: boolean | RequestForInformationArgs
  }

  export type RequestForInformationAnswerInclude = {
    User?: boolean | UserArgs
    RequestForInformation?: boolean | RequestForInformationArgs
  }

  export type RequestForInformationAnswerGetPayload<
    S extends boolean | null | undefined | RequestForInformationAnswerArgs,
    U = keyof S
      > = S extends true
        ? RequestForInformationAnswer
    : S extends undefined
    ? never
    : S extends RequestForInformationAnswerArgs | RequestForInformationAnswerFindManyArgs
    ?'include' extends U
    ? RequestForInformationAnswer  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> :
        P extends 'RequestForInformation'
        ? RequestForInformationGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RequestForInformationAnswer ?RequestForInformationAnswer [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> :
        P extends 'RequestForInformation'
        ? RequestForInformationGetPayload<S['select'][P]> : never
  } 
    : RequestForInformationAnswer
  : RequestForInformationAnswer


  type RequestForInformationAnswerCountArgs = Merge<
    Omit<RequestForInformationAnswerFindManyArgs, 'select' | 'include'> & {
      select?: RequestForInformationAnswerCountAggregateInputType | true
    }
  >

  export interface RequestForInformationAnswerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestForInformationAnswer that matches the filter.
     * @param {RequestForInformationAnswerFindUniqueArgs} args - Arguments to find a RequestForInformationAnswer
     * @example
     * // Get one RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestForInformationAnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestForInformationAnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestForInformationAnswer'> extends True ? CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer>, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T>>> : CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer | null >, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T> | null >>

    /**
     * Find the first RequestForInformationAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerFindFirstArgs} args - Arguments to find a RequestForInformationAnswer
     * @example
     * // Get one RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestForInformationAnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestForInformationAnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestForInformationAnswer'> extends True ? CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer>, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T>>> : CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer | null >, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T> | null >>

    /**
     * Find zero or more RequestForInformationAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestForInformationAnswers
     * const requestForInformationAnswers = await prisma.requestForInformationAnswer.findMany()
     * 
     * // Get first 10 RequestForInformationAnswers
     * const requestForInformationAnswers = await prisma.requestForInformationAnswer.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const requestForInformationAnswerWithIdOnly = await prisma.requestForInformationAnswer.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends RequestForInformationAnswerFindManyArgs>(
      args?: SelectSubset<T, RequestForInformationAnswerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestForInformationAnswer>>, PrismaPromise<Array<RequestForInformationAnswerGetPayload<T>>>>

    /**
     * Create a RequestForInformationAnswer.
     * @param {RequestForInformationAnswerCreateArgs} args - Arguments to create a RequestForInformationAnswer.
     * @example
     * // Create one RequestForInformationAnswer
     * const RequestForInformationAnswer = await prisma.requestForInformationAnswer.create({
     *   data: {
     *     // ... data to create a RequestForInformationAnswer
     *   }
     * })
     * 
    **/
    create<T extends RequestForInformationAnswerCreateArgs>(
      args: SelectSubset<T, RequestForInformationAnswerCreateArgs>
    ): CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer>, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T>>>

    /**
     * Create many RequestForInformationAnswers.
     *     @param {RequestForInformationAnswerCreateManyArgs} args - Arguments to create many RequestForInformationAnswers.
     *     @example
     *     // Create many RequestForInformationAnswers
     *     const requestForInformationAnswer = await prisma.requestForInformationAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestForInformationAnswerCreateManyArgs>(
      args?: SelectSubset<T, RequestForInformationAnswerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestForInformationAnswer.
     * @param {RequestForInformationAnswerDeleteArgs} args - Arguments to delete one RequestForInformationAnswer.
     * @example
     * // Delete one RequestForInformationAnswer
     * const RequestForInformationAnswer = await prisma.requestForInformationAnswer.delete({
     *   where: {
     *     // ... filter to delete one RequestForInformationAnswer
     *   }
     * })
     * 
    **/
    delete<T extends RequestForInformationAnswerDeleteArgs>(
      args: SelectSubset<T, RequestForInformationAnswerDeleteArgs>
    ): CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer>, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T>>>

    /**
     * Update one RequestForInformationAnswer.
     * @param {RequestForInformationAnswerUpdateArgs} args - Arguments to update one RequestForInformationAnswer.
     * @example
     * // Update one RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestForInformationAnswerUpdateArgs>(
      args: SelectSubset<T, RequestForInformationAnswerUpdateArgs>
    ): CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer>, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T>>>

    /**
     * Delete zero or more RequestForInformationAnswers.
     * @param {RequestForInformationAnswerDeleteManyArgs} args - Arguments to filter RequestForInformationAnswers to delete.
     * @example
     * // Delete a few RequestForInformationAnswers
     * const { count } = await prisma.requestForInformationAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestForInformationAnswerDeleteManyArgs>(
      args?: SelectSubset<T, RequestForInformationAnswerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestForInformationAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestForInformationAnswers
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestForInformationAnswerUpdateManyArgs>(
      args: SelectSubset<T, RequestForInformationAnswerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestForInformationAnswer.
     * @param {RequestForInformationAnswerUpsertArgs} args - Arguments to update or create a RequestForInformationAnswer.
     * @example
     * // Update or create a RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.upsert({
     *   create: {
     *     // ... data to create a RequestForInformationAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestForInformationAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends RequestForInformationAnswerUpsertArgs>(
      args: SelectSubset<T, RequestForInformationAnswerUpsertArgs>
    ): CheckSelect<T, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswer>, Prisma__RequestForInformationAnswerClient<RequestForInformationAnswerGetPayload<T>>>

    /**
     * Count the number of RequestForInformationAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerCountArgs} args - Arguments to filter RequestForInformationAnswers to count.
     * @example
     * // Count the number of RequestForInformationAnswers
     * const count = await prisma.requestForInformationAnswer.count({
     *   where: {
     *     // ... the filter for the RequestForInformationAnswers we want to count
     *   }
     * })
    **/
    count<T extends RequestForInformationAnswerCountArgs>(
      args?: Subset<T, RequestForInformationAnswerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestForInformationAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestForInformationAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestForInformationAnswerAggregateArgs>(args: Subset<T, RequestForInformationAnswerAggregateArgs>): PrismaPromise<GetRequestForInformationAnswerAggregateType<T>>

    /**
     * Group by RequestForInformationAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestForInformationAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestForInformationAnswerGroupByArgs['orderBy'] }
        : { orderBy?: RequestForInformationAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestForInformationAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestForInformationAnswerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestForInformationAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestForInformationAnswerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    RequestForInformation<T extends RequestForInformationArgs = {}>(args?: Subset<T, RequestForInformationArgs>): CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation | null >, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RequestForInformationAnswer findUnique
   */
  export type RequestForInformationAnswerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
    /**
     * Throw an Error if a RequestForInformationAnswer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestForInformationAnswer to fetch.
     * 
    **/
    where: RequestForInformationAnswerWhereUniqueInput
  }


  /**
   * RequestForInformationAnswer findFirst
   */
  export type RequestForInformationAnswerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
    /**
     * Throw an Error if a RequestForInformationAnswer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestForInformationAnswer to fetch.
     * 
    **/
    where?: RequestForInformationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformationAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationAnswerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestForInformationAnswers.
     * 
    **/
    cursor?: RequestForInformationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformationAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformationAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestForInformationAnswers.
     * 
    **/
    distinct?: Enumerable<RequestForInformationAnswerScalarFieldEnum>
  }


  /**
   * RequestForInformationAnswer findMany
   */
  export type RequestForInformationAnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
    /**
     * Filter, which RequestForInformationAnswers to fetch.
     * 
    **/
    where?: RequestForInformationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformationAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationAnswerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestForInformationAnswers.
     * 
    **/
    cursor?: RequestForInformationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformationAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformationAnswers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestForInformationAnswerScalarFieldEnum>
  }


  /**
   * RequestForInformationAnswer create
   */
  export type RequestForInformationAnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
    /**
     * The data needed to create a RequestForInformationAnswer.
     * 
    **/
    data: XOR<RequestForInformationAnswerCreateInput, RequestForInformationAnswerUncheckedCreateInput>
  }


  /**
   * RequestForInformationAnswer createMany
   */
  export type RequestForInformationAnswerCreateManyArgs = {
    data: Enumerable<RequestForInformationAnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestForInformationAnswer update
   */
  export type RequestForInformationAnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
    /**
     * The data needed to update a RequestForInformationAnswer.
     * 
    **/
    data: XOR<RequestForInformationAnswerUpdateInput, RequestForInformationAnswerUncheckedUpdateInput>
    /**
     * Choose, which RequestForInformationAnswer to update.
     * 
    **/
    where: RequestForInformationAnswerWhereUniqueInput
  }


  /**
   * RequestForInformationAnswer updateMany
   */
  export type RequestForInformationAnswerUpdateManyArgs = {
    data: XOR<RequestForInformationAnswerUpdateManyMutationInput, RequestForInformationAnswerUncheckedUpdateManyInput>
    where?: RequestForInformationAnswerWhereInput
  }


  /**
   * RequestForInformationAnswer upsert
   */
  export type RequestForInformationAnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
    /**
     * The filter to search for the RequestForInformationAnswer to update in case it exists.
     * 
    **/
    where: RequestForInformationAnswerWhereUniqueInput
    /**
     * In case the RequestForInformationAnswer found by the `where` argument doesn't exist, create a new RequestForInformationAnswer with this data.
     * 
    **/
    create: XOR<RequestForInformationAnswerCreateInput, RequestForInformationAnswerUncheckedCreateInput>
    /**
     * In case the RequestForInformationAnswer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestForInformationAnswerUpdateInput, RequestForInformationAnswerUncheckedUpdateInput>
  }


  /**
   * RequestForInformationAnswer delete
   */
  export type RequestForInformationAnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
    /**
     * Filter which RequestForInformationAnswer to delete.
     * 
    **/
    where: RequestForInformationAnswerWhereUniqueInput
  }


  /**
   * RequestForInformationAnswer deleteMany
   */
  export type RequestForInformationAnswerDeleteManyArgs = {
    where?: RequestForInformationAnswerWhereInput
  }


  /**
   * RequestForInformationAnswer without action
   */
  export type RequestForInformationAnswerArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationAnswer
     * 
    **/
    select?: RequestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationAnswerInclude | null
  }



  /**
   * Model RequestForInformationDocument
   */


  export type AggregateRequestForInformationDocument = {
    _count: RequestForInformationDocumentCountAggregateOutputType | null
    count: RequestForInformationDocumentCountAggregateOutputType | null
    _avg: RequestForInformationDocumentAvgAggregateOutputType | null
    avg: RequestForInformationDocumentAvgAggregateOutputType | null
    _sum: RequestForInformationDocumentSumAggregateOutputType | null
    sum: RequestForInformationDocumentSumAggregateOutputType | null
    _min: RequestForInformationDocumentMinAggregateOutputType | null
    min: RequestForInformationDocumentMinAggregateOutputType | null
    _max: RequestForInformationDocumentMaxAggregateOutputType | null
    max: RequestForInformationDocumentMaxAggregateOutputType | null
  }

  export type RequestForInformationDocumentAvgAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationDocumentSumAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationDocumentMinAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type RequestForInformationDocumentMaxAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type RequestForInformationDocumentCountAggregateOutputType = {
    Id: number
    RequestForInformationId: number
    ImageUrl: number
    Name: number
    _all: number
  }


  export type RequestForInformationDocumentAvgAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationDocumentSumAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationDocumentMinAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
    ImageUrl?: true
    Name?: true
  }

  export type RequestForInformationDocumentMaxAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
    ImageUrl?: true
    Name?: true
  }

  export type RequestForInformationDocumentCountAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
    ImageUrl?: true
    Name?: true
    _all?: true
  }

  export type RequestForInformationDocumentAggregateArgs = {
    /**
     * Filter which RequestForInformationDocument to aggregate.
     * 
    **/
    where?: RequestForInformationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformationDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestForInformationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformationDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformationDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestForInformationDocuments
    **/
    _count?: true | RequestForInformationDocumentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | RequestForInformationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestForInformationDocumentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: RequestForInformationDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestForInformationDocumentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: RequestForInformationDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestForInformationDocumentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: RequestForInformationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestForInformationDocumentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: RequestForInformationDocumentMaxAggregateInputType
  }

  export type GetRequestForInformationDocumentAggregateType<T extends RequestForInformationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestForInformationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestForInformationDocument[P]>
      : GetScalarType<T[P], AggregateRequestForInformationDocument[P]>
  }


    
    
  export type RequestForInformationDocumentGroupByArgs = {
    where?: RequestForInformationDocumentWhereInput
    orderBy?: Enumerable<RequestForInformationDocumentOrderByInput>
    by: Array<RequestForInformationDocumentScalarFieldEnum>
    having?: RequestForInformationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestForInformationDocumentCountAggregateInputType | true
    _avg?: RequestForInformationDocumentAvgAggregateInputType
    _sum?: RequestForInformationDocumentSumAggregateInputType
    _min?: RequestForInformationDocumentMinAggregateInputType
    _max?: RequestForInformationDocumentMaxAggregateInputType
  }


  export type RequestForInformationDocumentGroupByOutputType = {
    Id: number
    RequestForInformationId: number
    ImageUrl: string
    Name: string
    _count: RequestForInformationDocumentCountAggregateOutputType | null
    _avg: RequestForInformationDocumentAvgAggregateOutputType | null
    _sum: RequestForInformationDocumentSumAggregateOutputType | null
    _min: RequestForInformationDocumentMinAggregateOutputType | null
    _max: RequestForInformationDocumentMaxAggregateOutputType | null
  }

  type GetRequestForInformationDocumentGroupByPayload<T extends RequestForInformationDocumentGroupByArgs> = Promise<
    Array<
      PickArray<RequestForInformationDocumentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RequestForInformationDocumentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RequestForInformationDocumentGroupByOutputType[P]> 
            : GetScalarType<T[P], RequestForInformationDocumentGroupByOutputType[P]>
        }
      > 
    >


  export type RequestForInformationDocumentSelect = {
    Id?: boolean
    RequestForInformationId?: boolean
    ImageUrl?: boolean
    Name?: boolean
    RequestForInformation?: boolean | RequestForInformationArgs
  }

  export type RequestForInformationDocumentInclude = {
    RequestForInformation?: boolean | RequestForInformationArgs
  }

  export type RequestForInformationDocumentGetPayload<
    S extends boolean | null | undefined | RequestForInformationDocumentArgs,
    U = keyof S
      > = S extends true
        ? RequestForInformationDocument
    : S extends undefined
    ? never
    : S extends RequestForInformationDocumentArgs | RequestForInformationDocumentFindManyArgs
    ?'include' extends U
    ? RequestForInformationDocument  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RequestForInformation'
        ? RequestForInformationGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RequestForInformationDocument ?RequestForInformationDocument [P]
  : 
          P extends 'RequestForInformation'
        ? RequestForInformationGetPayload<S['select'][P]> : never
  } 
    : RequestForInformationDocument
  : RequestForInformationDocument


  type RequestForInformationDocumentCountArgs = Merge<
    Omit<RequestForInformationDocumentFindManyArgs, 'select' | 'include'> & {
      select?: RequestForInformationDocumentCountAggregateInputType | true
    }
  >

  export interface RequestForInformationDocumentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestForInformationDocument that matches the filter.
     * @param {RequestForInformationDocumentFindUniqueArgs} args - Arguments to find a RequestForInformationDocument
     * @example
     * // Get one RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestForInformationDocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestForInformationDocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestForInformationDocument'> extends True ? CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument>, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T>>> : CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument | null >, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T> | null >>

    /**
     * Find the first RequestForInformationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentFindFirstArgs} args - Arguments to find a RequestForInformationDocument
     * @example
     * // Get one RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestForInformationDocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestForInformationDocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestForInformationDocument'> extends True ? CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument>, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T>>> : CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument | null >, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T> | null >>

    /**
     * Find zero or more RequestForInformationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestForInformationDocuments
     * const requestForInformationDocuments = await prisma.requestForInformationDocument.findMany()
     * 
     * // Get first 10 RequestForInformationDocuments
     * const requestForInformationDocuments = await prisma.requestForInformationDocument.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const requestForInformationDocumentWithIdOnly = await prisma.requestForInformationDocument.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends RequestForInformationDocumentFindManyArgs>(
      args?: SelectSubset<T, RequestForInformationDocumentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestForInformationDocument>>, PrismaPromise<Array<RequestForInformationDocumentGetPayload<T>>>>

    /**
     * Create a RequestForInformationDocument.
     * @param {RequestForInformationDocumentCreateArgs} args - Arguments to create a RequestForInformationDocument.
     * @example
     * // Create one RequestForInformationDocument
     * const RequestForInformationDocument = await prisma.requestForInformationDocument.create({
     *   data: {
     *     // ... data to create a RequestForInformationDocument
     *   }
     * })
     * 
    **/
    create<T extends RequestForInformationDocumentCreateArgs>(
      args: SelectSubset<T, RequestForInformationDocumentCreateArgs>
    ): CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument>, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T>>>

    /**
     * Create many RequestForInformationDocuments.
     *     @param {RequestForInformationDocumentCreateManyArgs} args - Arguments to create many RequestForInformationDocuments.
     *     @example
     *     // Create many RequestForInformationDocuments
     *     const requestForInformationDocument = await prisma.requestForInformationDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestForInformationDocumentCreateManyArgs>(
      args?: SelectSubset<T, RequestForInformationDocumentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestForInformationDocument.
     * @param {RequestForInformationDocumentDeleteArgs} args - Arguments to delete one RequestForInformationDocument.
     * @example
     * // Delete one RequestForInformationDocument
     * const RequestForInformationDocument = await prisma.requestForInformationDocument.delete({
     *   where: {
     *     // ... filter to delete one RequestForInformationDocument
     *   }
     * })
     * 
    **/
    delete<T extends RequestForInformationDocumentDeleteArgs>(
      args: SelectSubset<T, RequestForInformationDocumentDeleteArgs>
    ): CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument>, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T>>>

    /**
     * Update one RequestForInformationDocument.
     * @param {RequestForInformationDocumentUpdateArgs} args - Arguments to update one RequestForInformationDocument.
     * @example
     * // Update one RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestForInformationDocumentUpdateArgs>(
      args: SelectSubset<T, RequestForInformationDocumentUpdateArgs>
    ): CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument>, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T>>>

    /**
     * Delete zero or more RequestForInformationDocuments.
     * @param {RequestForInformationDocumentDeleteManyArgs} args - Arguments to filter RequestForInformationDocuments to delete.
     * @example
     * // Delete a few RequestForInformationDocuments
     * const { count } = await prisma.requestForInformationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestForInformationDocumentDeleteManyArgs>(
      args?: SelectSubset<T, RequestForInformationDocumentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestForInformationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestForInformationDocuments
     * const requestForInformationDocument = await prisma.requestForInformationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestForInformationDocumentUpdateManyArgs>(
      args: SelectSubset<T, RequestForInformationDocumentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestForInformationDocument.
     * @param {RequestForInformationDocumentUpsertArgs} args - Arguments to update or create a RequestForInformationDocument.
     * @example
     * // Update or create a RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.upsert({
     *   create: {
     *     // ... data to create a RequestForInformationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestForInformationDocument we want to update
     *   }
     * })
    **/
    upsert<T extends RequestForInformationDocumentUpsertArgs>(
      args: SelectSubset<T, RequestForInformationDocumentUpsertArgs>
    ): CheckSelect<T, Prisma__RequestForInformationDocumentClient<RequestForInformationDocument>, Prisma__RequestForInformationDocumentClient<RequestForInformationDocumentGetPayload<T>>>

    /**
     * Count the number of RequestForInformationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentCountArgs} args - Arguments to filter RequestForInformationDocuments to count.
     * @example
     * // Count the number of RequestForInformationDocuments
     * const count = await prisma.requestForInformationDocument.count({
     *   where: {
     *     // ... the filter for the RequestForInformationDocuments we want to count
     *   }
     * })
    **/
    count<T extends RequestForInformationDocumentCountArgs>(
      args?: Subset<T, RequestForInformationDocumentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestForInformationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestForInformationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestForInformationDocumentAggregateArgs>(args: Subset<T, RequestForInformationDocumentAggregateArgs>): PrismaPromise<GetRequestForInformationDocumentAggregateType<T>>

    /**
     * Group by RequestForInformationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestForInformationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestForInformationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: RequestForInformationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestForInformationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestForInformationDocumentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestForInformationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestForInformationDocumentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RequestForInformation<T extends RequestForInformationArgs = {}>(args?: Subset<T, RequestForInformationArgs>): CheckSelect<T, Prisma__RequestForInformationClient<RequestForInformation | null >, Prisma__RequestForInformationClient<RequestForInformationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RequestForInformationDocument findUnique
   */
  export type RequestForInformationDocumentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
    /**
     * Throw an Error if a RequestForInformationDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestForInformationDocument to fetch.
     * 
    **/
    where: RequestForInformationDocumentWhereUniqueInput
  }


  /**
   * RequestForInformationDocument findFirst
   */
  export type RequestForInformationDocumentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
    /**
     * Throw an Error if a RequestForInformationDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestForInformationDocument to fetch.
     * 
    **/
    where?: RequestForInformationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformationDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestForInformationDocuments.
     * 
    **/
    cursor?: RequestForInformationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformationDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformationDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestForInformationDocuments.
     * 
    **/
    distinct?: Enumerable<RequestForInformationDocumentScalarFieldEnum>
  }


  /**
   * RequestForInformationDocument findMany
   */
  export type RequestForInformationDocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
    /**
     * Filter, which RequestForInformationDocuments to fetch.
     * 
    **/
    where?: RequestForInformationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestForInformationDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestForInformationDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestForInformationDocuments.
     * 
    **/
    cursor?: RequestForInformationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestForInformationDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestForInformationDocuments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestForInformationDocumentScalarFieldEnum>
  }


  /**
   * RequestForInformationDocument create
   */
  export type RequestForInformationDocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
    /**
     * The data needed to create a RequestForInformationDocument.
     * 
    **/
    data: XOR<RequestForInformationDocumentCreateInput, RequestForInformationDocumentUncheckedCreateInput>
  }


  /**
   * RequestForInformationDocument createMany
   */
  export type RequestForInformationDocumentCreateManyArgs = {
    data: Enumerable<RequestForInformationDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestForInformationDocument update
   */
  export type RequestForInformationDocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
    /**
     * The data needed to update a RequestForInformationDocument.
     * 
    **/
    data: XOR<RequestForInformationDocumentUpdateInput, RequestForInformationDocumentUncheckedUpdateInput>
    /**
     * Choose, which RequestForInformationDocument to update.
     * 
    **/
    where: RequestForInformationDocumentWhereUniqueInput
  }


  /**
   * RequestForInformationDocument updateMany
   */
  export type RequestForInformationDocumentUpdateManyArgs = {
    data: XOR<RequestForInformationDocumentUpdateManyMutationInput, RequestForInformationDocumentUncheckedUpdateManyInput>
    where?: RequestForInformationDocumentWhereInput
  }


  /**
   * RequestForInformationDocument upsert
   */
  export type RequestForInformationDocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
    /**
     * The filter to search for the RequestForInformationDocument to update in case it exists.
     * 
    **/
    where: RequestForInformationDocumentWhereUniqueInput
    /**
     * In case the RequestForInformationDocument found by the `where` argument doesn't exist, create a new RequestForInformationDocument with this data.
     * 
    **/
    create: XOR<RequestForInformationDocumentCreateInput, RequestForInformationDocumentUncheckedCreateInput>
    /**
     * In case the RequestForInformationDocument was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestForInformationDocumentUpdateInput, RequestForInformationDocumentUncheckedUpdateInput>
  }


  /**
   * RequestForInformationDocument delete
   */
  export type RequestForInformationDocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
    /**
     * Filter which RequestForInformationDocument to delete.
     * 
    **/
    where: RequestForInformationDocumentWhereUniqueInput
  }


  /**
   * RequestForInformationDocument deleteMany
   */
  export type RequestForInformationDocumentDeleteManyArgs = {
    where?: RequestForInformationDocumentWhereInput
  }


  /**
   * RequestForInformationDocument without action
   */
  export type RequestForInformationDocumentArgs = {
    /**
     * Select specific fields to fetch from the RequestForInformationDocument
     * 
    **/
    select?: RequestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestForInformationDocumentInclude | null
  }



  /**
   * Model StatusReport
   */


  export type AggregateStatusReport = {
    _count: StatusReportCountAggregateOutputType | null
    count: StatusReportCountAggregateOutputType | null
    _avg: StatusReportAvgAggregateOutputType | null
    avg: StatusReportAvgAggregateOutputType | null
    _sum: StatusReportSumAggregateOutputType | null
    sum: StatusReportSumAggregateOutputType | null
    _min: StatusReportMinAggregateOutputType | null
    min: StatusReportMinAggregateOutputType | null
    _max: StatusReportMaxAggregateOutputType | null
    max: StatusReportMaxAggregateOutputType | null
  }

  export type StatusReportAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type StatusReportSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type StatusReportMinAggregateOutputType = {
    Id: number | null
    Status: string | null
    CodeReportId: number | null
  }

  export type StatusReportMaxAggregateOutputType = {
    Id: number | null
    Status: string | null
    CodeReportId: number | null
  }

  export type StatusReportCountAggregateOutputType = {
    Id: number
    Status: number
    CodeReportId: number
    _all: number
  }


  export type StatusReportAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type StatusReportSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type StatusReportMinAggregateInputType = {
    Id?: true
    Status?: true
    CodeReportId?: true
  }

  export type StatusReportMaxAggregateInputType = {
    Id?: true
    Status?: true
    CodeReportId?: true
  }

  export type StatusReportCountAggregateInputType = {
    Id?: true
    Status?: true
    CodeReportId?: true
    _all?: true
  }

  export type StatusReportAggregateArgs = {
    /**
     * Filter which StatusReport to aggregate.
     * 
    **/
    where?: StatusReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusReports to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StatusReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusReports
    **/
    _count?: true | StatusReportCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | StatusReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusReportAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: StatusReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusReportSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: StatusReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusReportMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: StatusReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusReportMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: StatusReportMaxAggregateInputType
  }

  export type GetStatusReportAggregateType<T extends StatusReportAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusReport[P]>
      : GetScalarType<T[P], AggregateStatusReport[P]>
  }


    
    
  export type StatusReportGroupByArgs = {
    where?: StatusReportWhereInput
    orderBy?: Enumerable<StatusReportOrderByInput>
    by: Array<StatusReportScalarFieldEnum>
    having?: StatusReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusReportCountAggregateInputType | true
    _avg?: StatusReportAvgAggregateInputType
    _sum?: StatusReportSumAggregateInputType
    _min?: StatusReportMinAggregateInputType
    _max?: StatusReportMaxAggregateInputType
  }


  export type StatusReportGroupByOutputType = {
    Id: number
    Status: string
    CodeReportId: number
    _count: StatusReportCountAggregateOutputType | null
    _avg: StatusReportAvgAggregateOutputType | null
    _sum: StatusReportSumAggregateOutputType | null
    _min: StatusReportMinAggregateOutputType | null
    _max: StatusReportMaxAggregateOutputType | null
  }

  type GetStatusReportGroupByPayload<T extends StatusReportGroupByArgs> = Promise<
    Array<
      PickArray<StatusReportGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StatusReportGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StatusReportGroupByOutputType[P]> 
            : GetScalarType<T[P], StatusReportGroupByOutputType[P]>
        }
      > 
    >


  export type StatusReportSelect = {
    Id?: boolean
    Status?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | CodeReportArgs
    StatusReportImage?: boolean | StatusReportImageFindManyArgs
  }

  export type StatusReportInclude = {
    CodeReport?: boolean | CodeReportArgs
    StatusReportImage?: boolean | StatusReportImageFindManyArgs
  }

  export type StatusReportGetPayload<
    S extends boolean | null | undefined | StatusReportArgs,
    U = keyof S
      > = S extends true
        ? StatusReport
    : S extends undefined
    ? never
    : S extends StatusReportArgs | StatusReportFindManyArgs
    ?'include' extends U
    ? StatusReport  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> :
        P extends 'StatusReportImage'
        ? Array < StatusReportImageGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StatusReport ?StatusReport [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> :
        P extends 'StatusReportImage'
        ? Array < StatusReportImageGetPayload<S['select'][P]>>  : never
  } 
    : StatusReport
  : StatusReport


  type StatusReportCountArgs = Merge<
    Omit<StatusReportFindManyArgs, 'select' | 'include'> & {
      select?: StatusReportCountAggregateInputType | true
    }
  >

  export interface StatusReportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StatusReport that matches the filter.
     * @param {StatusReportFindUniqueArgs} args - Arguments to find a StatusReport
     * @example
     * // Get one StatusReport
     * const statusReport = await prisma.statusReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatusReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StatusReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StatusReport'> extends True ? CheckSelect<T, Prisma__StatusReportClient<StatusReport>, Prisma__StatusReportClient<StatusReportGetPayload<T>>> : CheckSelect<T, Prisma__StatusReportClient<StatusReport | null >, Prisma__StatusReportClient<StatusReportGetPayload<T> | null >>

    /**
     * Find the first StatusReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportFindFirstArgs} args - Arguments to find a StatusReport
     * @example
     * // Get one StatusReport
     * const statusReport = await prisma.statusReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatusReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StatusReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StatusReport'> extends True ? CheckSelect<T, Prisma__StatusReportClient<StatusReport>, Prisma__StatusReportClient<StatusReportGetPayload<T>>> : CheckSelect<T, Prisma__StatusReportClient<StatusReport | null >, Prisma__StatusReportClient<StatusReportGetPayload<T> | null >>

    /**
     * Find zero or more StatusReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusReports
     * const statusReports = await prisma.statusReport.findMany()
     * 
     * // Get first 10 StatusReports
     * const statusReports = await prisma.statusReport.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const statusReportWithIdOnly = await prisma.statusReport.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends StatusReportFindManyArgs>(
      args?: SelectSubset<T, StatusReportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StatusReport>>, PrismaPromise<Array<StatusReportGetPayload<T>>>>

    /**
     * Create a StatusReport.
     * @param {StatusReportCreateArgs} args - Arguments to create a StatusReport.
     * @example
     * // Create one StatusReport
     * const StatusReport = await prisma.statusReport.create({
     *   data: {
     *     // ... data to create a StatusReport
     *   }
     * })
     * 
    **/
    create<T extends StatusReportCreateArgs>(
      args: SelectSubset<T, StatusReportCreateArgs>
    ): CheckSelect<T, Prisma__StatusReportClient<StatusReport>, Prisma__StatusReportClient<StatusReportGetPayload<T>>>

    /**
     * Create many StatusReports.
     *     @param {StatusReportCreateManyArgs} args - Arguments to create many StatusReports.
     *     @example
     *     // Create many StatusReports
     *     const statusReport = await prisma.statusReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatusReportCreateManyArgs>(
      args?: SelectSubset<T, StatusReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StatusReport.
     * @param {StatusReportDeleteArgs} args - Arguments to delete one StatusReport.
     * @example
     * // Delete one StatusReport
     * const StatusReport = await prisma.statusReport.delete({
     *   where: {
     *     // ... filter to delete one StatusReport
     *   }
     * })
     * 
    **/
    delete<T extends StatusReportDeleteArgs>(
      args: SelectSubset<T, StatusReportDeleteArgs>
    ): CheckSelect<T, Prisma__StatusReportClient<StatusReport>, Prisma__StatusReportClient<StatusReportGetPayload<T>>>

    /**
     * Update one StatusReport.
     * @param {StatusReportUpdateArgs} args - Arguments to update one StatusReport.
     * @example
     * // Update one StatusReport
     * const statusReport = await prisma.statusReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatusReportUpdateArgs>(
      args: SelectSubset<T, StatusReportUpdateArgs>
    ): CheckSelect<T, Prisma__StatusReportClient<StatusReport>, Prisma__StatusReportClient<StatusReportGetPayload<T>>>

    /**
     * Delete zero or more StatusReports.
     * @param {StatusReportDeleteManyArgs} args - Arguments to filter StatusReports to delete.
     * @example
     * // Delete a few StatusReports
     * const { count } = await prisma.statusReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatusReportDeleteManyArgs>(
      args?: SelectSubset<T, StatusReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusReports
     * const statusReport = await prisma.statusReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatusReportUpdateManyArgs>(
      args: SelectSubset<T, StatusReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusReport.
     * @param {StatusReportUpsertArgs} args - Arguments to update or create a StatusReport.
     * @example
     * // Update or create a StatusReport
     * const statusReport = await prisma.statusReport.upsert({
     *   create: {
     *     // ... data to create a StatusReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusReport we want to update
     *   }
     * })
    **/
    upsert<T extends StatusReportUpsertArgs>(
      args: SelectSubset<T, StatusReportUpsertArgs>
    ): CheckSelect<T, Prisma__StatusReportClient<StatusReport>, Prisma__StatusReportClient<StatusReportGetPayload<T>>>

    /**
     * Count the number of StatusReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportCountArgs} args - Arguments to filter StatusReports to count.
     * @example
     * // Count the number of StatusReports
     * const count = await prisma.statusReport.count({
     *   where: {
     *     // ... the filter for the StatusReports we want to count
     *   }
     * })
    **/
    count<T extends StatusReportCountArgs>(
      args?: Subset<T, StatusReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusReportAggregateArgs>(args: Subset<T, StatusReportAggregateArgs>): PrismaPromise<GetStatusReportAggregateType<T>>

    /**
     * Group by StatusReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusReportGroupByArgs['orderBy'] }
        : { orderBy?: StatusReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusReportGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StatusReportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    StatusReportImage<T extends StatusReportImageFindManyArgs = {}>(args?: Subset<T, StatusReportImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StatusReportImage>>, PrismaPromise<Array<StatusReportImageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StatusReport findUnique
   */
  export type StatusReportFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
    /**
     * Throw an Error if a StatusReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StatusReport to fetch.
     * 
    **/
    where: StatusReportWhereUniqueInput
  }


  /**
   * StatusReport findFirst
   */
  export type StatusReportFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
    /**
     * Throw an Error if a StatusReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StatusReport to fetch.
     * 
    **/
    where?: StatusReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusReports to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusReports.
     * 
    **/
    cursor?: StatusReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusReports.
     * 
    **/
    distinct?: Enumerable<StatusReportScalarFieldEnum>
  }


  /**
   * StatusReport findMany
   */
  export type StatusReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
    /**
     * Filter, which StatusReports to fetch.
     * 
    **/
    where?: StatusReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusReports to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusReports.
     * 
    **/
    cursor?: StatusReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusReports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StatusReportScalarFieldEnum>
  }


  /**
   * StatusReport create
   */
  export type StatusReportCreateArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
    /**
     * The data needed to create a StatusReport.
     * 
    **/
    data: XOR<StatusReportCreateInput, StatusReportUncheckedCreateInput>
  }


  /**
   * StatusReport createMany
   */
  export type StatusReportCreateManyArgs = {
    data: Enumerable<StatusReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StatusReport update
   */
  export type StatusReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
    /**
     * The data needed to update a StatusReport.
     * 
    **/
    data: XOR<StatusReportUpdateInput, StatusReportUncheckedUpdateInput>
    /**
     * Choose, which StatusReport to update.
     * 
    **/
    where: StatusReportWhereUniqueInput
  }


  /**
   * StatusReport updateMany
   */
  export type StatusReportUpdateManyArgs = {
    data: XOR<StatusReportUpdateManyMutationInput, StatusReportUncheckedUpdateManyInput>
    where?: StatusReportWhereInput
  }


  /**
   * StatusReport upsert
   */
  export type StatusReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
    /**
     * The filter to search for the StatusReport to update in case it exists.
     * 
    **/
    where: StatusReportWhereUniqueInput
    /**
     * In case the StatusReport found by the `where` argument doesn't exist, create a new StatusReport with this data.
     * 
    **/
    create: XOR<StatusReportCreateInput, StatusReportUncheckedCreateInput>
    /**
     * In case the StatusReport was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StatusReportUpdateInput, StatusReportUncheckedUpdateInput>
  }


  /**
   * StatusReport delete
   */
  export type StatusReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
    /**
     * Filter which StatusReport to delete.
     * 
    **/
    where: StatusReportWhereUniqueInput
  }


  /**
   * StatusReport deleteMany
   */
  export type StatusReportDeleteManyArgs = {
    where?: StatusReportWhereInput
  }


  /**
   * StatusReport without action
   */
  export type StatusReportArgs = {
    /**
     * Select specific fields to fetch from the StatusReport
     * 
    **/
    select?: StatusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportInclude | null
  }



  /**
   * Model StatusReportImage
   */


  export type AggregateStatusReportImage = {
    _count: StatusReportImageCountAggregateOutputType | null
    count: StatusReportImageCountAggregateOutputType | null
    _avg: StatusReportImageAvgAggregateOutputType | null
    avg: StatusReportImageAvgAggregateOutputType | null
    _sum: StatusReportImageSumAggregateOutputType | null
    sum: StatusReportImageSumAggregateOutputType | null
    _min: StatusReportImageMinAggregateOutputType | null
    min: StatusReportImageMinAggregateOutputType | null
    _max: StatusReportImageMaxAggregateOutputType | null
    max: StatusReportImageMaxAggregateOutputType | null
  }

  export type StatusReportImageAvgAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
  }

  export type StatusReportImageSumAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
  }

  export type StatusReportImageMinAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type StatusReportImageMaxAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type StatusReportImageCountAggregateOutputType = {
    Id: number
    StatusReportId: number
    ImageUrl: number
    Name: number
    _all: number
  }


  export type StatusReportImageAvgAggregateInputType = {
    Id?: true
    StatusReportId?: true
  }

  export type StatusReportImageSumAggregateInputType = {
    Id?: true
    StatusReportId?: true
  }

  export type StatusReportImageMinAggregateInputType = {
    Id?: true
    StatusReportId?: true
    ImageUrl?: true
    Name?: true
  }

  export type StatusReportImageMaxAggregateInputType = {
    Id?: true
    StatusReportId?: true
    ImageUrl?: true
    Name?: true
  }

  export type StatusReportImageCountAggregateInputType = {
    Id?: true
    StatusReportId?: true
    ImageUrl?: true
    Name?: true
    _all?: true
  }

  export type StatusReportImageAggregateArgs = {
    /**
     * Filter which StatusReportImage to aggregate.
     * 
    **/
    where?: StatusReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StatusReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusReportImages
    **/
    _count?: true | StatusReportImageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | StatusReportImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusReportImageAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: StatusReportImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusReportImageSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: StatusReportImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusReportImageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: StatusReportImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusReportImageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: StatusReportImageMaxAggregateInputType
  }

  export type GetStatusReportImageAggregateType<T extends StatusReportImageAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusReportImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusReportImage[P]>
      : GetScalarType<T[P], AggregateStatusReportImage[P]>
  }


    
    
  export type StatusReportImageGroupByArgs = {
    where?: StatusReportImageWhereInput
    orderBy?: Enumerable<StatusReportImageOrderByInput>
    by: Array<StatusReportImageScalarFieldEnum>
    having?: StatusReportImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusReportImageCountAggregateInputType | true
    _avg?: StatusReportImageAvgAggregateInputType
    _sum?: StatusReportImageSumAggregateInputType
    _min?: StatusReportImageMinAggregateInputType
    _max?: StatusReportImageMaxAggregateInputType
  }


  export type StatusReportImageGroupByOutputType = {
    Id: number
    StatusReportId: number
    ImageUrl: string
    Name: string
    _count: StatusReportImageCountAggregateOutputType | null
    _avg: StatusReportImageAvgAggregateOutputType | null
    _sum: StatusReportImageSumAggregateOutputType | null
    _min: StatusReportImageMinAggregateOutputType | null
    _max: StatusReportImageMaxAggregateOutputType | null
  }

  type GetStatusReportImageGroupByPayload<T extends StatusReportImageGroupByArgs> = Promise<
    Array<
      PickArray<StatusReportImageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StatusReportImageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StatusReportImageGroupByOutputType[P]> 
            : GetScalarType<T[P], StatusReportImageGroupByOutputType[P]>
        }
      > 
    >


  export type StatusReportImageSelect = {
    Id?: boolean
    StatusReportId?: boolean
    ImageUrl?: boolean
    Name?: boolean
    StatusReport?: boolean | StatusReportArgs
  }

  export type StatusReportImageInclude = {
    StatusReport?: boolean | StatusReportArgs
  }

  export type StatusReportImageGetPayload<
    S extends boolean | null | undefined | StatusReportImageArgs,
    U = keyof S
      > = S extends true
        ? StatusReportImage
    : S extends undefined
    ? never
    : S extends StatusReportImageArgs | StatusReportImageFindManyArgs
    ?'include' extends U
    ? StatusReportImage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'StatusReport'
        ? StatusReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StatusReportImage ?StatusReportImage [P]
  : 
          P extends 'StatusReport'
        ? StatusReportGetPayload<S['select'][P]> : never
  } 
    : StatusReportImage
  : StatusReportImage


  type StatusReportImageCountArgs = Merge<
    Omit<StatusReportImageFindManyArgs, 'select' | 'include'> & {
      select?: StatusReportImageCountAggregateInputType | true
    }
  >

  export interface StatusReportImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StatusReportImage that matches the filter.
     * @param {StatusReportImageFindUniqueArgs} args - Arguments to find a StatusReportImage
     * @example
     * // Get one StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatusReportImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StatusReportImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StatusReportImage'> extends True ? CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage>, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T>>> : CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage | null >, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T> | null >>

    /**
     * Find the first StatusReportImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageFindFirstArgs} args - Arguments to find a StatusReportImage
     * @example
     * // Get one StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatusReportImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StatusReportImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StatusReportImage'> extends True ? CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage>, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T>>> : CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage | null >, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T> | null >>

    /**
     * Find zero or more StatusReportImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusReportImages
     * const statusReportImages = await prisma.statusReportImage.findMany()
     * 
     * // Get first 10 StatusReportImages
     * const statusReportImages = await prisma.statusReportImage.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const statusReportImageWithIdOnly = await prisma.statusReportImage.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends StatusReportImageFindManyArgs>(
      args?: SelectSubset<T, StatusReportImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StatusReportImage>>, PrismaPromise<Array<StatusReportImageGetPayload<T>>>>

    /**
     * Create a StatusReportImage.
     * @param {StatusReportImageCreateArgs} args - Arguments to create a StatusReportImage.
     * @example
     * // Create one StatusReportImage
     * const StatusReportImage = await prisma.statusReportImage.create({
     *   data: {
     *     // ... data to create a StatusReportImage
     *   }
     * })
     * 
    **/
    create<T extends StatusReportImageCreateArgs>(
      args: SelectSubset<T, StatusReportImageCreateArgs>
    ): CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage>, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T>>>

    /**
     * Create many StatusReportImages.
     *     @param {StatusReportImageCreateManyArgs} args - Arguments to create many StatusReportImages.
     *     @example
     *     // Create many StatusReportImages
     *     const statusReportImage = await prisma.statusReportImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatusReportImageCreateManyArgs>(
      args?: SelectSubset<T, StatusReportImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StatusReportImage.
     * @param {StatusReportImageDeleteArgs} args - Arguments to delete one StatusReportImage.
     * @example
     * // Delete one StatusReportImage
     * const StatusReportImage = await prisma.statusReportImage.delete({
     *   where: {
     *     // ... filter to delete one StatusReportImage
     *   }
     * })
     * 
    **/
    delete<T extends StatusReportImageDeleteArgs>(
      args: SelectSubset<T, StatusReportImageDeleteArgs>
    ): CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage>, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T>>>

    /**
     * Update one StatusReportImage.
     * @param {StatusReportImageUpdateArgs} args - Arguments to update one StatusReportImage.
     * @example
     * // Update one StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatusReportImageUpdateArgs>(
      args: SelectSubset<T, StatusReportImageUpdateArgs>
    ): CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage>, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T>>>

    /**
     * Delete zero or more StatusReportImages.
     * @param {StatusReportImageDeleteManyArgs} args - Arguments to filter StatusReportImages to delete.
     * @example
     * // Delete a few StatusReportImages
     * const { count } = await prisma.statusReportImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatusReportImageDeleteManyArgs>(
      args?: SelectSubset<T, StatusReportImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusReportImages
     * const statusReportImage = await prisma.statusReportImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatusReportImageUpdateManyArgs>(
      args: SelectSubset<T, StatusReportImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusReportImage.
     * @param {StatusReportImageUpsertArgs} args - Arguments to update or create a StatusReportImage.
     * @example
     * // Update or create a StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.upsert({
     *   create: {
     *     // ... data to create a StatusReportImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusReportImage we want to update
     *   }
     * })
    **/
    upsert<T extends StatusReportImageUpsertArgs>(
      args: SelectSubset<T, StatusReportImageUpsertArgs>
    ): CheckSelect<T, Prisma__StatusReportImageClient<StatusReportImage>, Prisma__StatusReportImageClient<StatusReportImageGetPayload<T>>>

    /**
     * Count the number of StatusReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageCountArgs} args - Arguments to filter StatusReportImages to count.
     * @example
     * // Count the number of StatusReportImages
     * const count = await prisma.statusReportImage.count({
     *   where: {
     *     // ... the filter for the StatusReportImages we want to count
     *   }
     * })
    **/
    count<T extends StatusReportImageCountArgs>(
      args?: Subset<T, StatusReportImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusReportImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusReportImageAggregateArgs>(args: Subset<T, StatusReportImageAggregateArgs>): PrismaPromise<GetStatusReportImageAggregateType<T>>

    /**
     * Group by StatusReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusReportImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusReportImageGroupByArgs['orderBy'] }
        : { orderBy?: StatusReportImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusReportImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusReportImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusReportImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StatusReportImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StatusReport<T extends StatusReportArgs = {}>(args?: Subset<T, StatusReportArgs>): CheckSelect<T, Prisma__StatusReportClient<StatusReport | null >, Prisma__StatusReportClient<StatusReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StatusReportImage findUnique
   */
  export type StatusReportImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
    /**
     * Throw an Error if a StatusReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StatusReportImage to fetch.
     * 
    **/
    where: StatusReportImageWhereUniqueInput
  }


  /**
   * StatusReportImage findFirst
   */
  export type StatusReportImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
    /**
     * Throw an Error if a StatusReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StatusReportImage to fetch.
     * 
    **/
    where?: StatusReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusReportImages.
     * 
    **/
    cursor?: StatusReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusReportImages.
     * 
    **/
    distinct?: Enumerable<StatusReportImageScalarFieldEnum>
  }


  /**
   * StatusReportImage findMany
   */
  export type StatusReportImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
    /**
     * Filter, which StatusReportImages to fetch.
     * 
    **/
    where?: StatusReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<StatusReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusReportImages.
     * 
    **/
    cursor?: StatusReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusReportImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StatusReportImageScalarFieldEnum>
  }


  /**
   * StatusReportImage create
   */
  export type StatusReportImageCreateArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
    /**
     * The data needed to create a StatusReportImage.
     * 
    **/
    data: XOR<StatusReportImageCreateInput, StatusReportImageUncheckedCreateInput>
  }


  /**
   * StatusReportImage createMany
   */
  export type StatusReportImageCreateManyArgs = {
    data: Enumerable<StatusReportImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StatusReportImage update
   */
  export type StatusReportImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
    /**
     * The data needed to update a StatusReportImage.
     * 
    **/
    data: XOR<StatusReportImageUpdateInput, StatusReportImageUncheckedUpdateInput>
    /**
     * Choose, which StatusReportImage to update.
     * 
    **/
    where: StatusReportImageWhereUniqueInput
  }


  /**
   * StatusReportImage updateMany
   */
  export type StatusReportImageUpdateManyArgs = {
    data: XOR<StatusReportImageUpdateManyMutationInput, StatusReportImageUncheckedUpdateManyInput>
    where?: StatusReportImageWhereInput
  }


  /**
   * StatusReportImage upsert
   */
  export type StatusReportImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
    /**
     * The filter to search for the StatusReportImage to update in case it exists.
     * 
    **/
    where: StatusReportImageWhereUniqueInput
    /**
     * In case the StatusReportImage found by the `where` argument doesn't exist, create a new StatusReportImage with this data.
     * 
    **/
    create: XOR<StatusReportImageCreateInput, StatusReportImageUncheckedCreateInput>
    /**
     * In case the StatusReportImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StatusReportImageUpdateInput, StatusReportImageUncheckedUpdateInput>
  }


  /**
   * StatusReportImage delete
   */
  export type StatusReportImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
    /**
     * Filter which StatusReportImage to delete.
     * 
    **/
    where: StatusReportImageWhereUniqueInput
  }


  /**
   * StatusReportImage deleteMany
   */
  export type StatusReportImageDeleteManyArgs = {
    where?: StatusReportImageWhereInput
  }


  /**
   * StatusReportImage without action
   */
  export type StatusReportImageArgs = {
    /**
     * Select specific fields to fetch from the StatusReportImage
     * 
    **/
    select?: StatusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StatusReportImageInclude | null
  }



  /**
   * Model Tool
   */


  export type AggregateTool = {
    _count: ToolCountAggregateOutputType | null
    count: ToolCountAggregateOutputType | null
    _avg: ToolAvgAggregateOutputType | null
    avg: ToolAvgAggregateOutputType | null
    _sum: ToolSumAggregateOutputType | null
    sum: ToolSumAggregateOutputType | null
    _min: ToolMinAggregateOutputType | null
    min: ToolMinAggregateOutputType | null
    _max: ToolMaxAggregateOutputType | null
    max: ToolMaxAggregateOutputType | null
  }

  export type ToolAvgAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolSumAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    Quantity: number
    CodeReportId: number
    _all: number
  }


  export type ToolAvgAggregateInputType = {
    Id?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolSumAggregateInputType = {
    Id?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Quantity?: true
    CodeReportId?: true
    _all?: true
  }

  export type ToolAggregateArgs = {
    /**
     * Filter which Tool to aggregate.
     * 
    **/
    where?: ToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tools to fetch.
     * 
    **/
    orderBy?: Enumerable<ToolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tools.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tools
    **/
    _count?: true | ToolCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ToolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ToolAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ToolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ToolSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ToolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToolMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ToolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToolMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ToolMaxAggregateInputType
  }

  export type GetToolAggregateType<T extends ToolAggregateArgs> = {
        [P in keyof T & keyof AggregateTool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTool[P]>
      : GetScalarType<T[P], AggregateTool[P]>
  }


    
    
  export type ToolGroupByArgs = {
    where?: ToolWhereInput
    orderBy?: Enumerable<ToolOrderByInput>
    by: Array<ToolScalarFieldEnum>
    having?: ToolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToolCountAggregateInputType | true
    _avg?: ToolAvgAggregateInputType
    _sum?: ToolSumAggregateInputType
    _min?: ToolMinAggregateInputType
    _max?: ToolMaxAggregateInputType
  }


  export type ToolGroupByOutputType = {
    Id: number
    Name: string
    Description: string
    Quantity: number
    CodeReportId: number
    _count: ToolCountAggregateOutputType | null
    _avg: ToolAvgAggregateOutputType | null
    _sum: ToolSumAggregateOutputType | null
    _min: ToolMinAggregateOutputType | null
    _max: ToolMaxAggregateOutputType | null
  }

  type GetToolGroupByPayload<T extends ToolGroupByArgs> = Promise<
    Array<
      PickArray<ToolGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ToolGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ToolGroupByOutputType[P]> 
            : GetScalarType<T[P], ToolGroupByOutputType[P]>
        }
      > 
    >


  export type ToolSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    Quantity?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | CodeReportArgs
  }

  export type ToolInclude = {
    CodeReport?: boolean | CodeReportArgs
  }

  export type ToolGetPayload<
    S extends boolean | null | undefined | ToolArgs,
    U = keyof S
      > = S extends true
        ? Tool
    : S extends undefined
    ? never
    : S extends ToolArgs | ToolFindManyArgs
    ?'include' extends U
    ? Tool  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Tool ?Tool [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> : never
  } 
    : Tool
  : Tool


  type ToolCountArgs = Merge<
    Omit<ToolFindManyArgs, 'select' | 'include'> & {
      select?: ToolCountAggregateInputType | true
    }
  >

  export interface ToolDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tool that matches the filter.
     * @param {ToolFindUniqueArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ToolFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ToolFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tool'> extends True ? CheckSelect<T, Prisma__ToolClient<Tool>, Prisma__ToolClient<ToolGetPayload<T>>> : CheckSelect<T, Prisma__ToolClient<Tool | null >, Prisma__ToolClient<ToolGetPayload<T> | null >>

    /**
     * Find the first Tool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolFindFirstArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ToolFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ToolFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tool'> extends True ? CheckSelect<T, Prisma__ToolClient<Tool>, Prisma__ToolClient<ToolGetPayload<T>>> : CheckSelect<T, Prisma__ToolClient<Tool | null >, Prisma__ToolClient<ToolGetPayload<T> | null >>

    /**
     * Find zero or more Tools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tools
     * const tools = await prisma.tool.findMany()
     * 
     * // Get first 10 Tools
     * const tools = await prisma.tool.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const toolWithIdOnly = await prisma.tool.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends ToolFindManyArgs>(
      args?: SelectSubset<T, ToolFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tool>>, PrismaPromise<Array<ToolGetPayload<T>>>>

    /**
     * Create a Tool.
     * @param {ToolCreateArgs} args - Arguments to create a Tool.
     * @example
     * // Create one Tool
     * const Tool = await prisma.tool.create({
     *   data: {
     *     // ... data to create a Tool
     *   }
     * })
     * 
    **/
    create<T extends ToolCreateArgs>(
      args: SelectSubset<T, ToolCreateArgs>
    ): CheckSelect<T, Prisma__ToolClient<Tool>, Prisma__ToolClient<ToolGetPayload<T>>>

    /**
     * Create many Tools.
     *     @param {ToolCreateManyArgs} args - Arguments to create many Tools.
     *     @example
     *     // Create many Tools
     *     const tool = await prisma.tool.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ToolCreateManyArgs>(
      args?: SelectSubset<T, ToolCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tool.
     * @param {ToolDeleteArgs} args - Arguments to delete one Tool.
     * @example
     * // Delete one Tool
     * const Tool = await prisma.tool.delete({
     *   where: {
     *     // ... filter to delete one Tool
     *   }
     * })
     * 
    **/
    delete<T extends ToolDeleteArgs>(
      args: SelectSubset<T, ToolDeleteArgs>
    ): CheckSelect<T, Prisma__ToolClient<Tool>, Prisma__ToolClient<ToolGetPayload<T>>>

    /**
     * Update one Tool.
     * @param {ToolUpdateArgs} args - Arguments to update one Tool.
     * @example
     * // Update one Tool
     * const tool = await prisma.tool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ToolUpdateArgs>(
      args: SelectSubset<T, ToolUpdateArgs>
    ): CheckSelect<T, Prisma__ToolClient<Tool>, Prisma__ToolClient<ToolGetPayload<T>>>

    /**
     * Delete zero or more Tools.
     * @param {ToolDeleteManyArgs} args - Arguments to filter Tools to delete.
     * @example
     * // Delete a few Tools
     * const { count } = await prisma.tool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ToolDeleteManyArgs>(
      args?: SelectSubset<T, ToolDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tools
     * const tool = await prisma.tool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ToolUpdateManyArgs>(
      args: SelectSubset<T, ToolUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tool.
     * @param {ToolUpsertArgs} args - Arguments to update or create a Tool.
     * @example
     * // Update or create a Tool
     * const tool = await prisma.tool.upsert({
     *   create: {
     *     // ... data to create a Tool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tool we want to update
     *   }
     * })
    **/
    upsert<T extends ToolUpsertArgs>(
      args: SelectSubset<T, ToolUpsertArgs>
    ): CheckSelect<T, Prisma__ToolClient<Tool>, Prisma__ToolClient<ToolGetPayload<T>>>

    /**
     * Count the number of Tools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolCountArgs} args - Arguments to filter Tools to count.
     * @example
     * // Count the number of Tools
     * const count = await prisma.tool.count({
     *   where: {
     *     // ... the filter for the Tools we want to count
     *   }
     * })
    **/
    count<T extends ToolCountArgs>(
      args?: Subset<T, ToolCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToolAggregateArgs>(args: Subset<T, ToolAggregateArgs>): PrismaPromise<GetToolAggregateType<T>>

    /**
     * Group by Tool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToolGroupByArgs['orderBy'] }
        : { orderBy?: ToolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToolGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ToolClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tool findUnique
   */
  export type ToolFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
    /**
     * Throw an Error if a Tool can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tool to fetch.
     * 
    **/
    where: ToolWhereUniqueInput
  }


  /**
   * Tool findFirst
   */
  export type ToolFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
    /**
     * Throw an Error if a Tool can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tool to fetch.
     * 
    **/
    where?: ToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tools to fetch.
     * 
    **/
    orderBy?: Enumerable<ToolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tools.
     * 
    **/
    cursor?: ToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tools.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tools.
     * 
    **/
    distinct?: Enumerable<ToolScalarFieldEnum>
  }


  /**
   * Tool findMany
   */
  export type ToolFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
    /**
     * Filter, which Tools to fetch.
     * 
    **/
    where?: ToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tools to fetch.
     * 
    **/
    orderBy?: Enumerable<ToolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tools.
     * 
    **/
    cursor?: ToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tools.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ToolScalarFieldEnum>
  }


  /**
   * Tool create
   */
  export type ToolCreateArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
    /**
     * The data needed to create a Tool.
     * 
    **/
    data: XOR<ToolCreateInput, ToolUncheckedCreateInput>
  }


  /**
   * Tool createMany
   */
  export type ToolCreateManyArgs = {
    data: Enumerable<ToolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tool update
   */
  export type ToolUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
    /**
     * The data needed to update a Tool.
     * 
    **/
    data: XOR<ToolUpdateInput, ToolUncheckedUpdateInput>
    /**
     * Choose, which Tool to update.
     * 
    **/
    where: ToolWhereUniqueInput
  }


  /**
   * Tool updateMany
   */
  export type ToolUpdateManyArgs = {
    data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyInput>
    where?: ToolWhereInput
  }


  /**
   * Tool upsert
   */
  export type ToolUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
    /**
     * The filter to search for the Tool to update in case it exists.
     * 
    **/
    where: ToolWhereUniqueInput
    /**
     * In case the Tool found by the `where` argument doesn't exist, create a new Tool with this data.
     * 
    **/
    create: XOR<ToolCreateInput, ToolUncheckedCreateInput>
    /**
     * In case the Tool was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ToolUpdateInput, ToolUncheckedUpdateInput>
  }


  /**
   * Tool delete
   */
  export type ToolDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
    /**
     * Filter which Tool to delete.
     * 
    **/
    where: ToolWhereUniqueInput
  }


  /**
   * Tool deleteMany
   */
  export type ToolDeleteManyArgs = {
    where?: ToolWhereInput
  }


  /**
   * Tool without action
   */
  export type ToolArgs = {
    /**
     * Select specific fields to fetch from the Tool
     * 
    **/
    select?: ToolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ToolInclude | null
  }



  /**
   * Model Weather
   */


  export type AggregateWeather = {
    _count: WeatherCountAggregateOutputType | null
    count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
    max: WeatherMaxAggregateOutputType | null
  }

  export type WeatherAvgAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherSumAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherMinAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherMaxAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherCountAggregateOutputType = {
    Id: number
    WeatherId: number
    CodeReportId: number
    _all: number
  }


  export type WeatherAvgAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherSumAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherMinAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherMaxAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherCountAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
    _all?: true
  }

  export type WeatherAggregateArgs = {
    /**
     * Filter which Weather to aggregate.
     * 
    **/
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     * 
    **/
    orderBy?: Enumerable<WeatherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weathers
    **/
    _count?: true | WeatherCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: WeatherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: WeatherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WeatherMaxAggregateInputType
  }

  export type GetWeatherAggregateType<T extends WeatherAggregateArgs> = {
        [P in keyof T & keyof AggregateWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeather[P]>
      : GetScalarType<T[P], AggregateWeather[P]>
  }


    
    
  export type WeatherGroupByArgs = {
    where?: WeatherWhereInput
    orderBy?: Enumerable<WeatherOrderByInput>
    by: Array<WeatherScalarFieldEnum>
    having?: WeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherCountAggregateInputType | true
    _avg?: WeatherAvgAggregateInputType
    _sum?: WeatherSumAggregateInputType
    _min?: WeatherMinAggregateInputType
    _max?: WeatherMaxAggregateInputType
  }


  export type WeatherGroupByOutputType = {
    Id: number
    WeatherId: number
    CodeReportId: number
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  type GetWeatherGroupByPayload<T extends WeatherGroupByArgs> = Promise<
    Array<
      PickArray<WeatherGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WeatherGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WeatherGroupByOutputType[P]> 
            : GetScalarType<T[P], WeatherGroupByOutputType[P]>
        }
      > 
    >


  export type WeatherSelect = {
    Id?: boolean
    WeatherId?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | CodeReportArgs
  }

  export type WeatherInclude = {
    CodeReport?: boolean | CodeReportArgs
  }

  export type WeatherGetPayload<
    S extends boolean | null | undefined | WeatherArgs,
    U = keyof S
      > = S extends true
        ? Weather
    : S extends undefined
    ? never
    : S extends WeatherArgs | WeatherFindManyArgs
    ?'include' extends U
    ? Weather  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Weather ?Weather [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> : never
  } 
    : Weather
  : Weather


  type WeatherCountArgs = Merge<
    Omit<WeatherFindManyArgs, 'select' | 'include'> & {
      select?: WeatherCountAggregateInputType | true
    }
  >

  export interface WeatherDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weather that matches the filter.
     * @param {WeatherFindUniqueArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WeatherFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WeatherFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Weather'> extends True ? CheckSelect<T, Prisma__WeatherClient<Weather>, Prisma__WeatherClient<WeatherGetPayload<T>>> : CheckSelect<T, Prisma__WeatherClient<Weather | null >, Prisma__WeatherClient<WeatherGetPayload<T> | null >>

    /**
     * Find the first Weather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WeatherFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WeatherFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Weather'> extends True ? CheckSelect<T, Prisma__WeatherClient<Weather>, Prisma__WeatherClient<WeatherGetPayload<T>>> : CheckSelect<T, Prisma__WeatherClient<Weather | null >, Prisma__WeatherClient<WeatherGetPayload<T> | null >>

    /**
     * Find zero or more Weathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weathers
     * const weathers = await prisma.weather.findMany()
     * 
     * // Get first 10 Weathers
     * const weathers = await prisma.weather.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const weatherWithIdOnly = await prisma.weather.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends WeatherFindManyArgs>(
      args?: SelectSubset<T, WeatherFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Weather>>, PrismaPromise<Array<WeatherGetPayload<T>>>>

    /**
     * Create a Weather.
     * @param {WeatherCreateArgs} args - Arguments to create a Weather.
     * @example
     * // Create one Weather
     * const Weather = await prisma.weather.create({
     *   data: {
     *     // ... data to create a Weather
     *   }
     * })
     * 
    **/
    create<T extends WeatherCreateArgs>(
      args: SelectSubset<T, WeatherCreateArgs>
    ): CheckSelect<T, Prisma__WeatherClient<Weather>, Prisma__WeatherClient<WeatherGetPayload<T>>>

    /**
     * Create many Weathers.
     *     @param {WeatherCreateManyArgs} args - Arguments to create many Weathers.
     *     @example
     *     // Create many Weathers
     *     const weather = await prisma.weather.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WeatherCreateManyArgs>(
      args?: SelectSubset<T, WeatherCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weather.
     * @param {WeatherDeleteArgs} args - Arguments to delete one Weather.
     * @example
     * // Delete one Weather
     * const Weather = await prisma.weather.delete({
     *   where: {
     *     // ... filter to delete one Weather
     *   }
     * })
     * 
    **/
    delete<T extends WeatherDeleteArgs>(
      args: SelectSubset<T, WeatherDeleteArgs>
    ): CheckSelect<T, Prisma__WeatherClient<Weather>, Prisma__WeatherClient<WeatherGetPayload<T>>>

    /**
     * Update one Weather.
     * @param {WeatherUpdateArgs} args - Arguments to update one Weather.
     * @example
     * // Update one Weather
     * const weather = await prisma.weather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WeatherUpdateArgs>(
      args: SelectSubset<T, WeatherUpdateArgs>
    ): CheckSelect<T, Prisma__WeatherClient<Weather>, Prisma__WeatherClient<WeatherGetPayload<T>>>

    /**
     * Delete zero or more Weathers.
     * @param {WeatherDeleteManyArgs} args - Arguments to filter Weathers to delete.
     * @example
     * // Delete a few Weathers
     * const { count } = await prisma.weather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WeatherDeleteManyArgs>(
      args?: SelectSubset<T, WeatherDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WeatherUpdateManyArgs>(
      args: SelectSubset<T, WeatherUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weather.
     * @param {WeatherUpsertArgs} args - Arguments to update or create a Weather.
     * @example
     * // Update or create a Weather
     * const weather = await prisma.weather.upsert({
     *   create: {
     *     // ... data to create a Weather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weather we want to update
     *   }
     * })
    **/
    upsert<T extends WeatherUpsertArgs>(
      args: SelectSubset<T, WeatherUpsertArgs>
    ): CheckSelect<T, Prisma__WeatherClient<Weather>, Prisma__WeatherClient<WeatherGetPayload<T>>>

    /**
     * Count the number of Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherCountArgs} args - Arguments to filter Weathers to count.
     * @example
     * // Count the number of Weathers
     * const count = await prisma.weather.count({
     *   where: {
     *     // ... the filter for the Weathers we want to count
     *   }
     * })
    **/
    count<T extends WeatherCountArgs>(
      args?: Subset<T, WeatherCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateArgs>(args: Subset<T, WeatherAggregateArgs>): PrismaPromise<GetWeatherAggregateType<T>>

    /**
     * Group by Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherGroupByArgs['orderBy'] }
        : { orderBy?: WeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WeatherClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Weather findUnique
   */
  export type WeatherFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
    /**
     * Throw an Error if a Weather can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Weather to fetch.
     * 
    **/
    where: WeatherWhereUniqueInput
  }


  /**
   * Weather findFirst
   */
  export type WeatherFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
    /**
     * Throw an Error if a Weather can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Weather to fetch.
     * 
    **/
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     * 
    **/
    orderBy?: Enumerable<WeatherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     * 
    **/
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     * 
    **/
    distinct?: Enumerable<WeatherScalarFieldEnum>
  }


  /**
   * Weather findMany
   */
  export type WeatherFindManyArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
    /**
     * Filter, which Weathers to fetch.
     * 
    **/
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     * 
    **/
    orderBy?: Enumerable<WeatherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weathers.
     * 
    **/
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WeatherScalarFieldEnum>
  }


  /**
   * Weather create
   */
  export type WeatherCreateArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
    /**
     * The data needed to create a Weather.
     * 
    **/
    data: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
  }


  /**
   * Weather createMany
   */
  export type WeatherCreateManyArgs = {
    data: Enumerable<WeatherCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Weather update
   */
  export type WeatherUpdateArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
    /**
     * The data needed to update a Weather.
     * 
    **/
    data: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
    /**
     * Choose, which Weather to update.
     * 
    **/
    where: WeatherWhereUniqueInput
  }


  /**
   * Weather updateMany
   */
  export type WeatherUpdateManyArgs = {
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    where?: WeatherWhereInput
  }


  /**
   * Weather upsert
   */
  export type WeatherUpsertArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
    /**
     * The filter to search for the Weather to update in case it exists.
     * 
    **/
    where: WeatherWhereUniqueInput
    /**
     * In case the Weather found by the `where` argument doesn't exist, create a new Weather with this data.
     * 
    **/
    create: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
    /**
     * In case the Weather was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
  }


  /**
   * Weather delete
   */
  export type WeatherDeleteArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
    /**
     * Filter which Weather to delete.
     * 
    **/
    where: WeatherWhereUniqueInput
  }


  /**
   * Weather deleteMany
   */
  export type WeatherDeleteManyArgs = {
    where?: WeatherWhereInput
  }


  /**
   * Weather without action
   */
  export type WeatherArgs = {
    /**
     * Select specific fields to fetch from the Weather
     * 
    **/
    select?: WeatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeatherInclude | null
  }



  /**
   * Model Worker
   */


  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
    max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerCountAggregateOutputType = {
    Id: number
    Name: number
    CodeReportId: number
    Quantity: number
    _all: number
  }


  export type WorkerAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerMinAggregateInputType = {
    Id?: true
    Name?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerMaxAggregateInputType = {
    Id?: true
    Name?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerCountAggregateInputType = {
    Id?: true
    Name?: true
    CodeReportId?: true
    Quantity?: true
    _all?: true
  }

  export type WorkerAggregateArgs = {
    /**
     * Filter which Worker to aggregate.
     * 
    **/
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: WorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: WorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }


    
    
  export type WorkerGroupByArgs = {
    where?: WorkerWhereInput
    orderBy?: Enumerable<WorkerOrderByInput>
    by: Array<WorkerScalarFieldEnum>
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _avg?: WorkerAvgAggregateInputType
    _sum?: WorkerSumAggregateInputType
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }


  export type WorkerGroupByOutputType = {
    Id: number
    Name: string
    CodeReportId: number
    Quantity: number
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Promise<
    Array<
      PickArray<WorkerGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WorkerGroupByOutputType[P]> 
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      > 
    >


  export type WorkerSelect = {
    Id?: boolean
    Name?: boolean
    CodeReportId?: boolean
    Quantity?: boolean
    CodeReport?: boolean | CodeReportArgs
  }

  export type WorkerInclude = {
    CodeReport?: boolean | CodeReportArgs
  }

  export type WorkerGetPayload<
    S extends boolean | null | undefined | WorkerArgs,
    U = keyof S
      > = S extends true
        ? Worker
    : S extends undefined
    ? never
    : S extends WorkerArgs | WorkerFindManyArgs
    ?'include' extends U
    ? Worker  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Worker ?Worker [P]
  : 
          P extends 'CodeReport'
        ? CodeReportGetPayload<S['select'][P]> : never
  } 
    : Worker
  : Worker


  type WorkerCountArgs = Merge<
    Omit<WorkerFindManyArgs, 'select' | 'include'> & {
      select?: WorkerCountAggregateInputType | true
    }
  >

  export interface WorkerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Worker'> extends True ? CheckSelect<T, Prisma__WorkerClient<Worker>, Prisma__WorkerClient<WorkerGetPayload<T>>> : CheckSelect<T, Prisma__WorkerClient<Worker | null >, Prisma__WorkerClient<WorkerGetPayload<T> | null >>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Worker'> extends True ? CheckSelect<T, Prisma__WorkerClient<Worker>, Prisma__WorkerClient<WorkerGetPayload<T>>> : CheckSelect<T, Prisma__WorkerClient<Worker | null >, Prisma__WorkerClient<WorkerGetPayload<T> | null >>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends WorkerFindManyArgs>(
      args?: SelectSubset<T, WorkerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Worker>>, PrismaPromise<Array<WorkerGetPayload<T>>>>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
    **/
    create<T extends WorkerCreateArgs>(
      args: SelectSubset<T, WorkerCreateArgs>
    ): CheckSelect<T, Prisma__WorkerClient<Worker>, Prisma__WorkerClient<WorkerGetPayload<T>>>

    /**
     * Create many Workers.
     *     @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     *     @example
     *     // Create many Workers
     *     const worker = await prisma.worker.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkerCreateManyArgs>(
      args?: SelectSubset<T, WorkerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
    **/
    delete<T extends WorkerDeleteArgs>(
      args: SelectSubset<T, WorkerDeleteArgs>
    ): CheckSelect<T, Prisma__WorkerClient<Worker>, Prisma__WorkerClient<WorkerGetPayload<T>>>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkerUpdateArgs>(
      args: SelectSubset<T, WorkerUpdateArgs>
    ): CheckSelect<T, Prisma__WorkerClient<Worker>, Prisma__WorkerClient<WorkerGetPayload<T>>>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkerDeleteManyArgs>(
      args?: SelectSubset<T, WorkerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkerUpdateManyArgs>(
      args: SelectSubset<T, WorkerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
    **/
    upsert<T extends WorkerUpsertArgs>(
      args: SelectSubset<T, WorkerUpsertArgs>
    ): CheckSelect<T, Prisma__WorkerClient<Worker>, Prisma__WorkerClient<WorkerGetPayload<T>>>

    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends CodeReportArgs = {}>(args?: Subset<T, CodeReportArgs>): CheckSelect<T, Prisma__CodeReportClient<CodeReport | null >, Prisma__CodeReportClient<CodeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
    /**
     * Throw an Error if a Worker can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Worker to fetch.
     * 
    **/
    where: WorkerWhereUniqueInput
  }


  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
    /**
     * Throw an Error if a Worker can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Worker to fetch.
     * 
    **/
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     * 
    **/
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     * 
    **/
    distinct?: Enumerable<WorkerScalarFieldEnum>
  }


  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
    /**
     * Filter, which Workers to fetch.
     * 
    **/
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     * 
    **/
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkerScalarFieldEnum>
  }


  /**
   * Worker create
   */
  export type WorkerCreateArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
    /**
     * The data needed to create a Worker.
     * 
    **/
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }


  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs = {
    data: Enumerable<WorkerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Worker update
   */
  export type WorkerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
    /**
     * The data needed to update a Worker.
     * 
    **/
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     * 
    **/
    where: WorkerWhereUniqueInput
  }


  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs = {
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    where?: WorkerWhereInput
  }


  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
    /**
     * The filter to search for the Worker to update in case it exists.
     * 
    **/
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     * 
    **/
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }


  /**
   * Worker delete
   */
  export type WorkerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
    /**
     * Filter which Worker to delete.
     * 
    **/
    where: WorkerWhereUniqueInput
  }


  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs = {
    where?: WorkerWhereInput
  }


  /**
   * Worker without action
   */
  export type WorkerArgs = {
    /**
     * Select specific fields to fetch from the Worker
     * 
    **/
    select?: WorkerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkerInclude | null
  }



  /**
   * Model UserContact
   */


  export type AggregateUserContact = {
    _count: UserContactCountAggregateOutputType | null
    count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
    max: UserContactMaxAggregateOutputType | null
  }

  export type UserContactAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type UserContactSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type UserContactMinAggregateOutputType = {
    Id: number | null
    PhoneNumber: string | null
    UserId: number | null
    WhatsappAvailable: boolean | null
  }

  export type UserContactMaxAggregateOutputType = {
    Id: number | null
    PhoneNumber: string | null
    UserId: number | null
    WhatsappAvailable: boolean | null
  }

  export type UserContactCountAggregateOutputType = {
    Id: number
    PhoneNumber: number
    UserId: number
    WhatsappAvailable: number
    _all: number
  }


  export type UserContactAvgAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type UserContactSumAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type UserContactMinAggregateInputType = {
    Id?: true
    PhoneNumber?: true
    UserId?: true
    WhatsappAvailable?: true
  }

  export type UserContactMaxAggregateInputType = {
    Id?: true
    PhoneNumber?: true
    UserId?: true
    WhatsappAvailable?: true
  }

  export type UserContactCountAggregateInputType = {
    Id?: true
    PhoneNumber?: true
    UserId?: true
    WhatsappAvailable?: true
    _all?: true
  }

  export type UserContactAggregateArgs = {
    /**
     * Filter which UserContact to aggregate.
     * 
    **/
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<UserContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserContacts
    **/
    _count?: true | UserContactCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserContactAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserContactSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserContactMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserContactMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserContactMaxAggregateInputType
  }

  export type GetUserContactAggregateType<T extends UserContactAggregateArgs> = {
        [P in keyof T & keyof AggregateUserContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserContact[P]>
      : GetScalarType<T[P], AggregateUserContact[P]>
  }


    
    
  export type UserContactGroupByArgs = {
    where?: UserContactWhereInput
    orderBy?: Enumerable<UserContactOrderByInput>
    by: Array<UserContactScalarFieldEnum>
    having?: UserContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserContactCountAggregateInputType | true
    _avg?: UserContactAvgAggregateInputType
    _sum?: UserContactSumAggregateInputType
    _min?: UserContactMinAggregateInputType
    _max?: UserContactMaxAggregateInputType
  }


  export type UserContactGroupByOutputType = {
    Id: number
    PhoneNumber: string
    UserId: number
    WhatsappAvailable: boolean
    _count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  type GetUserContactGroupByPayload<T extends UserContactGroupByArgs> = Promise<
    Array<
      PickArray<UserContactGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserContactGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserContactGroupByOutputType[P]> 
            : GetScalarType<T[P], UserContactGroupByOutputType[P]>
        }
      > 
    >


  export type UserContactSelect = {
    Id?: boolean
    PhoneNumber?: boolean
    UserId?: boolean
    WhatsappAvailable?: boolean
    User?: boolean | UserArgs
  }

  export type UserContactInclude = {
    User?: boolean | UserArgs
  }

  export type UserContactGetPayload<
    S extends boolean | null | undefined | UserContactArgs,
    U = keyof S
      > = S extends true
        ? UserContact
    : S extends undefined
    ? never
    : S extends UserContactArgs | UserContactFindManyArgs
    ?'include' extends U
    ? UserContact  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserContact ?UserContact [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : UserContact
  : UserContact


  type UserContactCountArgs = Merge<
    Omit<UserContactFindManyArgs, 'select' | 'include'> & {
      select?: UserContactCountAggregateInputType | true
    }
  >

  export interface UserContactDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserContact that matches the filter.
     * @param {UserContactFindUniqueArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserContactFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserContactFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserContact'> extends True ? CheckSelect<T, Prisma__UserContactClient<UserContact>, Prisma__UserContactClient<UserContactGetPayload<T>>> : CheckSelect<T, Prisma__UserContactClient<UserContact | null >, Prisma__UserContactClient<UserContactGetPayload<T> | null >>

    /**
     * Find the first UserContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindFirstArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserContactFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserContactFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserContact'> extends True ? CheckSelect<T, Prisma__UserContactClient<UserContact>, Prisma__UserContactClient<UserContactGetPayload<T>>> : CheckSelect<T, Prisma__UserContactClient<UserContact | null >, Prisma__UserContactClient<UserContactGetPayload<T> | null >>

    /**
     * Find zero or more UserContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserContacts
     * const userContacts = await prisma.userContact.findMany()
     * 
     * // Get first 10 UserContacts
     * const userContacts = await prisma.userContact.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userContactWithIdOnly = await prisma.userContact.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserContactFindManyArgs>(
      args?: SelectSubset<T, UserContactFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserContact>>, PrismaPromise<Array<UserContactGetPayload<T>>>>

    /**
     * Create a UserContact.
     * @param {UserContactCreateArgs} args - Arguments to create a UserContact.
     * @example
     * // Create one UserContact
     * const UserContact = await prisma.userContact.create({
     *   data: {
     *     // ... data to create a UserContact
     *   }
     * })
     * 
    **/
    create<T extends UserContactCreateArgs>(
      args: SelectSubset<T, UserContactCreateArgs>
    ): CheckSelect<T, Prisma__UserContactClient<UserContact>, Prisma__UserContactClient<UserContactGetPayload<T>>>

    /**
     * Create many UserContacts.
     *     @param {UserContactCreateManyArgs} args - Arguments to create many UserContacts.
     *     @example
     *     // Create many UserContacts
     *     const userContact = await prisma.userContact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserContactCreateManyArgs>(
      args?: SelectSubset<T, UserContactCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserContact.
     * @param {UserContactDeleteArgs} args - Arguments to delete one UserContact.
     * @example
     * // Delete one UserContact
     * const UserContact = await prisma.userContact.delete({
     *   where: {
     *     // ... filter to delete one UserContact
     *   }
     * })
     * 
    **/
    delete<T extends UserContactDeleteArgs>(
      args: SelectSubset<T, UserContactDeleteArgs>
    ): CheckSelect<T, Prisma__UserContactClient<UserContact>, Prisma__UserContactClient<UserContactGetPayload<T>>>

    /**
     * Update one UserContact.
     * @param {UserContactUpdateArgs} args - Arguments to update one UserContact.
     * @example
     * // Update one UserContact
     * const userContact = await prisma.userContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserContactUpdateArgs>(
      args: SelectSubset<T, UserContactUpdateArgs>
    ): CheckSelect<T, Prisma__UserContactClient<UserContact>, Prisma__UserContactClient<UserContactGetPayload<T>>>

    /**
     * Delete zero or more UserContacts.
     * @param {UserContactDeleteManyArgs} args - Arguments to filter UserContacts to delete.
     * @example
     * // Delete a few UserContacts
     * const { count } = await prisma.userContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserContactDeleteManyArgs>(
      args?: SelectSubset<T, UserContactDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserContacts
     * const userContact = await prisma.userContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserContactUpdateManyArgs>(
      args: SelectSubset<T, UserContactUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserContact.
     * @param {UserContactUpsertArgs} args - Arguments to update or create a UserContact.
     * @example
     * // Update or create a UserContact
     * const userContact = await prisma.userContact.upsert({
     *   create: {
     *     // ... data to create a UserContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserContact we want to update
     *   }
     * })
    **/
    upsert<T extends UserContactUpsertArgs>(
      args: SelectSubset<T, UserContactUpsertArgs>
    ): CheckSelect<T, Prisma__UserContactClient<UserContact>, Prisma__UserContactClient<UserContactGetPayload<T>>>

    /**
     * Count the number of UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactCountArgs} args - Arguments to filter UserContacts to count.
     * @example
     * // Count the number of UserContacts
     * const count = await prisma.userContact.count({
     *   where: {
     *     // ... the filter for the UserContacts we want to count
     *   }
     * })
    **/
    count<T extends UserContactCountArgs>(
      args?: Subset<T, UserContactCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserContactAggregateArgs>(args: Subset<T, UserContactAggregateArgs>): PrismaPromise<GetUserContactAggregateType<T>>

    /**
     * Group by UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserContactGroupByArgs['orderBy'] }
        : { orderBy?: UserContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserContactGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserContactClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserContact findUnique
   */
  export type UserContactFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
    /**
     * Throw an Error if a UserContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserContact to fetch.
     * 
    **/
    where: UserContactWhereUniqueInput
  }


  /**
   * UserContact findFirst
   */
  export type UserContactFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
    /**
     * Throw an Error if a UserContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserContact to fetch.
     * 
    **/
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<UserContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContacts.
     * 
    **/
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContacts.
     * 
    **/
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }


  /**
   * UserContact findMany
   */
  export type UserContactFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
    /**
     * Filter, which UserContacts to fetch.
     * 
    **/
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<UserContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserContacts.
     * 
    **/
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }


  /**
   * UserContact create
   */
  export type UserContactCreateArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
    /**
     * The data needed to create a UserContact.
     * 
    **/
    data: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
  }


  /**
   * UserContact createMany
   */
  export type UserContactCreateManyArgs = {
    data: Enumerable<UserContactCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserContact update
   */
  export type UserContactUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
    /**
     * The data needed to update a UserContact.
     * 
    **/
    data: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
    /**
     * Choose, which UserContact to update.
     * 
    **/
    where: UserContactWhereUniqueInput
  }


  /**
   * UserContact updateMany
   */
  export type UserContactUpdateManyArgs = {
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyInput>
    where?: UserContactWhereInput
  }


  /**
   * UserContact upsert
   */
  export type UserContactUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
    /**
     * The filter to search for the UserContact to update in case it exists.
     * 
    **/
    where: UserContactWhereUniqueInput
    /**
     * In case the UserContact found by the `where` argument doesn't exist, create a new UserContact with this data.
     * 
    **/
    create: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
    /**
     * In case the UserContact was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
  }


  /**
   * UserContact delete
   */
  export type UserContactDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
    /**
     * Filter which UserContact to delete.
     * 
    **/
    where: UserContactWhereUniqueInput
  }


  /**
   * UserContact deleteMany
   */
  export type UserContactDeleteManyArgs = {
    where?: UserContactWhereInput
  }


  /**
   * UserContact without action
   */
  export type UserContactArgs = {
    /**
     * Select specific fields to fetch from the UserContact
     * 
    **/
    select?: UserContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactInclude | null
  }



  /**
   * Model UserPosition
   */


  export type AggregateUserPosition = {
    _count: UserPositionCountAggregateOutputType | null
    count: UserPositionCountAggregateOutputType | null
    _avg: UserPositionAvgAggregateOutputType | null
    avg: UserPositionAvgAggregateOutputType | null
    _sum: UserPositionSumAggregateOutputType | null
    sum: UserPositionSumAggregateOutputType | null
    _min: UserPositionMinAggregateOutputType | null
    min: UserPositionMinAggregateOutputType | null
    _max: UserPositionMaxAggregateOutputType | null
    max: UserPositionMaxAggregateOutputType | null
  }

  export type UserPositionAvgAggregateOutputType = {
    Id: number | null
    Position: number | null
    CreatedBy: number | null
    UserId: number | null
  }

  export type UserPositionSumAggregateOutputType = {
    Id: number | null
    Position: number | null
    CreatedBy: number | null
    UserId: number | null
  }

  export type UserPositionMinAggregateOutputType = {
    Id: number | null
    Position: number | null
    EffectiveDate: Date | null
    CreatedBy: number | null
    CreatedDate: Date | null
    UserId: number | null
  }

  export type UserPositionMaxAggregateOutputType = {
    Id: number | null
    Position: number | null
    EffectiveDate: Date | null
    CreatedBy: number | null
    CreatedDate: Date | null
    UserId: number | null
  }

  export type UserPositionCountAggregateOutputType = {
    Id: number
    Position: number
    EffectiveDate: number
    CreatedBy: number
    CreatedDate: number
    UserId: number
    _all: number
  }


  export type UserPositionAvgAggregateInputType = {
    Id?: true
    Position?: true
    CreatedBy?: true
    UserId?: true
  }

  export type UserPositionSumAggregateInputType = {
    Id?: true
    Position?: true
    CreatedBy?: true
    UserId?: true
  }

  export type UserPositionMinAggregateInputType = {
    Id?: true
    Position?: true
    EffectiveDate?: true
    CreatedBy?: true
    CreatedDate?: true
    UserId?: true
  }

  export type UserPositionMaxAggregateInputType = {
    Id?: true
    Position?: true
    EffectiveDate?: true
    CreatedBy?: true
    CreatedDate?: true
    UserId?: true
  }

  export type UserPositionCountAggregateInputType = {
    Id?: true
    Position?: true
    EffectiveDate?: true
    CreatedBy?: true
    CreatedDate?: true
    UserId?: true
    _all?: true
  }

  export type UserPositionAggregateArgs = {
    /**
     * Filter which UserPosition to aggregate.
     * 
    **/
    where?: UserPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPositionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPositions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPositions
    **/
    _count?: true | UserPositionCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPositionAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPositionSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPositionMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPositionMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserPositionMaxAggregateInputType
  }

  export type GetUserPositionAggregateType<T extends UserPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPosition[P]>
      : GetScalarType<T[P], AggregateUserPosition[P]>
  }


    
    
  export type UserPositionGroupByArgs = {
    where?: UserPositionWhereInput
    orderBy?: Enumerable<UserPositionOrderByInput>
    by: Array<UserPositionScalarFieldEnum>
    having?: UserPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPositionCountAggregateInputType | true
    _avg?: UserPositionAvgAggregateInputType
    _sum?: UserPositionSumAggregateInputType
    _min?: UserPositionMinAggregateInputType
    _max?: UserPositionMaxAggregateInputType
  }


  export type UserPositionGroupByOutputType = {
    Id: number
    Position: number
    EffectiveDate: Date
    CreatedBy: number
    CreatedDate: Date
    UserId: number
    _count: UserPositionCountAggregateOutputType | null
    _avg: UserPositionAvgAggregateOutputType | null
    _sum: UserPositionSumAggregateOutputType | null
    _min: UserPositionMinAggregateOutputType | null
    _max: UserPositionMaxAggregateOutputType | null
  }

  type GetUserPositionGroupByPayload<T extends UserPositionGroupByArgs> = Promise<
    Array<
      PickArray<UserPositionGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserPositionGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserPositionGroupByOutputType[P]> 
            : GetScalarType<T[P], UserPositionGroupByOutputType[P]>
        }
      > 
    >


  export type UserPositionSelect = {
    Id?: boolean
    Position?: boolean
    EffectiveDate?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    UserId?: boolean
    User4?: boolean | UserArgs
    User5?: boolean | UserArgs
  }

  export type UserPositionInclude = {
    User4?: boolean | UserArgs
    User5?: boolean | UserArgs
  }

  export type UserPositionGetPayload<
    S extends boolean | null | undefined | UserPositionArgs,
    U = keyof S
      > = S extends true
        ? UserPosition
    : S extends undefined
    ? never
    : S extends UserPositionArgs | UserPositionFindManyArgs
    ?'include' extends U
    ? UserPosition  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User4'
        ? UserGetPayload<S['include'][P]> :
        P extends 'User5'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserPosition ?UserPosition [P]
  : 
          P extends 'User4'
        ? UserGetPayload<S['select'][P]> :
        P extends 'User5'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : UserPosition
  : UserPosition


  type UserPositionCountArgs = Merge<
    Omit<UserPositionFindManyArgs, 'select' | 'include'> & {
      select?: UserPositionCountAggregateInputType | true
    }
  >

  export interface UserPositionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserPosition that matches the filter.
     * @param {UserPositionFindUniqueArgs} args - Arguments to find a UserPosition
     * @example
     * // Get one UserPosition
     * const userPosition = await prisma.userPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPositionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserPositionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserPosition'> extends True ? CheckSelect<T, Prisma__UserPositionClient<UserPosition>, Prisma__UserPositionClient<UserPositionGetPayload<T>>> : CheckSelect<T, Prisma__UserPositionClient<UserPosition | null >, Prisma__UserPositionClient<UserPositionGetPayload<T> | null >>

    /**
     * Find the first UserPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionFindFirstArgs} args - Arguments to find a UserPosition
     * @example
     * // Get one UserPosition
     * const userPosition = await prisma.userPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPositionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserPositionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserPosition'> extends True ? CheckSelect<T, Prisma__UserPositionClient<UserPosition>, Prisma__UserPositionClient<UserPositionGetPayload<T>>> : CheckSelect<T, Prisma__UserPositionClient<UserPosition | null >, Prisma__UserPositionClient<UserPositionGetPayload<T> | null >>

    /**
     * Find zero or more UserPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPositions
     * const userPositions = await prisma.userPosition.findMany()
     * 
     * // Get first 10 UserPositions
     * const userPositions = await prisma.userPosition.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userPositionWithIdOnly = await prisma.userPosition.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserPositionFindManyArgs>(
      args?: SelectSubset<T, UserPositionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserPosition>>, PrismaPromise<Array<UserPositionGetPayload<T>>>>

    /**
     * Create a UserPosition.
     * @param {UserPositionCreateArgs} args - Arguments to create a UserPosition.
     * @example
     * // Create one UserPosition
     * const UserPosition = await prisma.userPosition.create({
     *   data: {
     *     // ... data to create a UserPosition
     *   }
     * })
     * 
    **/
    create<T extends UserPositionCreateArgs>(
      args: SelectSubset<T, UserPositionCreateArgs>
    ): CheckSelect<T, Prisma__UserPositionClient<UserPosition>, Prisma__UserPositionClient<UserPositionGetPayload<T>>>

    /**
     * Create many UserPositions.
     *     @param {UserPositionCreateManyArgs} args - Arguments to create many UserPositions.
     *     @example
     *     // Create many UserPositions
     *     const userPosition = await prisma.userPosition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPositionCreateManyArgs>(
      args?: SelectSubset<T, UserPositionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserPosition.
     * @param {UserPositionDeleteArgs} args - Arguments to delete one UserPosition.
     * @example
     * // Delete one UserPosition
     * const UserPosition = await prisma.userPosition.delete({
     *   where: {
     *     // ... filter to delete one UserPosition
     *   }
     * })
     * 
    **/
    delete<T extends UserPositionDeleteArgs>(
      args: SelectSubset<T, UserPositionDeleteArgs>
    ): CheckSelect<T, Prisma__UserPositionClient<UserPosition>, Prisma__UserPositionClient<UserPositionGetPayload<T>>>

    /**
     * Update one UserPosition.
     * @param {UserPositionUpdateArgs} args - Arguments to update one UserPosition.
     * @example
     * // Update one UserPosition
     * const userPosition = await prisma.userPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPositionUpdateArgs>(
      args: SelectSubset<T, UserPositionUpdateArgs>
    ): CheckSelect<T, Prisma__UserPositionClient<UserPosition>, Prisma__UserPositionClient<UserPositionGetPayload<T>>>

    /**
     * Delete zero or more UserPositions.
     * @param {UserPositionDeleteManyArgs} args - Arguments to filter UserPositions to delete.
     * @example
     * // Delete a few UserPositions
     * const { count } = await prisma.userPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPositionDeleteManyArgs>(
      args?: SelectSubset<T, UserPositionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPositions
     * const userPosition = await prisma.userPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPositionUpdateManyArgs>(
      args: SelectSubset<T, UserPositionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPosition.
     * @param {UserPositionUpsertArgs} args - Arguments to update or create a UserPosition.
     * @example
     * // Update or create a UserPosition
     * const userPosition = await prisma.userPosition.upsert({
     *   create: {
     *     // ... data to create a UserPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPosition we want to update
     *   }
     * })
    **/
    upsert<T extends UserPositionUpsertArgs>(
      args: SelectSubset<T, UserPositionUpsertArgs>
    ): CheckSelect<T, Prisma__UserPositionClient<UserPosition>, Prisma__UserPositionClient<UserPositionGetPayload<T>>>

    /**
     * Count the number of UserPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionCountArgs} args - Arguments to filter UserPositions to count.
     * @example
     * // Count the number of UserPositions
     * const count = await prisma.userPosition.count({
     *   where: {
     *     // ... the filter for the UserPositions we want to count
     *   }
     * })
    **/
    count<T extends UserPositionCountArgs>(
      args?: Subset<T, UserPositionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPositionAggregateArgs>(args: Subset<T, UserPositionAggregateArgs>): PrismaPromise<GetUserPositionAggregateType<T>>

    /**
     * Group by UserPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPositionGroupByArgs['orderBy'] }
        : { orderBy?: UserPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPositionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserPositionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User4<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    User5<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserPosition findUnique
   */
  export type UserPositionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
    /**
     * Throw an Error if a UserPosition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserPosition to fetch.
     * 
    **/
    where: UserPositionWhereUniqueInput
  }


  /**
   * UserPosition findFirst
   */
  export type UserPositionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
    /**
     * Throw an Error if a UserPosition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserPosition to fetch.
     * 
    **/
    where?: UserPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPositionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPositions.
     * 
    **/
    cursor?: UserPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPositions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPositions.
     * 
    **/
    distinct?: Enumerable<UserPositionScalarFieldEnum>
  }


  /**
   * UserPosition findMany
   */
  export type UserPositionFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
    /**
     * Filter, which UserPositions to fetch.
     * 
    **/
    where?: UserPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPositionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPositions.
     * 
    **/
    cursor?: UserPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPositions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserPositionScalarFieldEnum>
  }


  /**
   * UserPosition create
   */
  export type UserPositionCreateArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
    /**
     * The data needed to create a UserPosition.
     * 
    **/
    data: XOR<UserPositionCreateInput, UserPositionUncheckedCreateInput>
  }


  /**
   * UserPosition createMany
   */
  export type UserPositionCreateManyArgs = {
    data: Enumerable<UserPositionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserPosition update
   */
  export type UserPositionUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
    /**
     * The data needed to update a UserPosition.
     * 
    **/
    data: XOR<UserPositionUpdateInput, UserPositionUncheckedUpdateInput>
    /**
     * Choose, which UserPosition to update.
     * 
    **/
    where: UserPositionWhereUniqueInput
  }


  /**
   * UserPosition updateMany
   */
  export type UserPositionUpdateManyArgs = {
    data: XOR<UserPositionUpdateManyMutationInput, UserPositionUncheckedUpdateManyInput>
    where?: UserPositionWhereInput
  }


  /**
   * UserPosition upsert
   */
  export type UserPositionUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
    /**
     * The filter to search for the UserPosition to update in case it exists.
     * 
    **/
    where: UserPositionWhereUniqueInput
    /**
     * In case the UserPosition found by the `where` argument doesn't exist, create a new UserPosition with this data.
     * 
    **/
    create: XOR<UserPositionCreateInput, UserPositionUncheckedCreateInput>
    /**
     * In case the UserPosition was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserPositionUpdateInput, UserPositionUncheckedUpdateInput>
  }


  /**
   * UserPosition delete
   */
  export type UserPositionDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
    /**
     * Filter which UserPosition to delete.
     * 
    **/
    where: UserPositionWhereUniqueInput
  }


  /**
   * UserPosition deleteMany
   */
  export type UserPositionDeleteManyArgs = {
    where?: UserPositionWhereInput
  }


  /**
   * UserPosition without action
   */
  export type UserPositionArgs = {
    /**
     * Select specific fields to fetch from the UserPosition
     * 
    **/
    select?: UserPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPositionInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    Id: number | null
  }

  export type UserSumAggregateOutputType = {
    Id: number | null
  }

  export type UserMinAggregateOutputType = {
    Id: number | null
    Email: string | null
    FirstName: string | null
    LastName: string | null
    IsActive: boolean | null
    Password: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    Id: number | null
    Email: string | null
    FirstName: string | null
    LastName: string | null
    IsActive: boolean | null
    Password: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    Id: number
    Email: number
    FirstName: number
    LastName: number
    IsActive: number
    Password: number
    ImageUrl: number
    ThumbnailUrl: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    Id?: true
  }

  export type UserSumAggregateInputType = {
    Id?: true
  }

  export type UserMinAggregateInputType = {
    Id?: true
    Email?: true
    FirstName?: true
    LastName?: true
    IsActive?: true
    Password?: true
    ImageUrl?: true
    ThumbnailUrl?: true
  }

  export type UserMaxAggregateInputType = {
    Id?: true
    Email?: true
    FirstName?: true
    LastName?: true
    IsActive?: true
    Password?: true
    ImageUrl?: true
    ThumbnailUrl?: true
  }

  export type UserCountAggregateInputType = {
    Id?: true
    Email?: true
    FirstName?: true
    LastName?: true
    IsActive?: true
    Password?: true
    ImageUrl?: true
    ThumbnailUrl?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    Id: number
    Email: string
    FirstName: string
    LastName: string
    IsActive: boolean
    Password: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type UserSelect = {
    Id?: boolean
    Email?: boolean
    FirstName?: boolean
    LastName?: boolean
    IsActive?: boolean
    Password?: boolean
    ImageUrl?: boolean
    ThumbnailUrl?: boolean
    Client?: boolean | ClientFindManyArgs
    ClientContact?: boolean | ClientContactFindManyArgs
    CodeProjectDocument?: boolean | CodeProjectDocumentFindManyArgs
    CreateCodeProject?: boolean | CodeProjectFindManyArgs
    ConfirmedCodeProject?: boolean | CodeProjectFindManyArgs
    CompletedCodeProject?: boolean | CodeProjectFindManyArgs
    CodeProjectUser?: boolean | CodeProjectUserFindManyArgs
    CodeReport?: boolean | CodeReportFindManyArgs
    CodeReportApproval?: boolean | CodeReportApprovalFindManyArgs
    ProjectTask?: boolean | ProjectTaskFindManyArgs
    RequestForInformationAnswer?: boolean | RequestForInformationAnswerFindManyArgs
    CreateUserPosition?: boolean | UserPositionFindManyArgs
    UserPosition?: boolean | UserPositionFindManyArgs
    UserContact?: boolean | UserContactFindManyArgs
  }

  export type UserInclude = {
    Client?: boolean | ClientFindManyArgs
    ClientContact?: boolean | ClientContactFindManyArgs
    CodeProjectDocument?: boolean | CodeProjectDocumentFindManyArgs
    CreateCodeProject?: boolean | CodeProjectFindManyArgs
    ConfirmedCodeProject?: boolean | CodeProjectFindManyArgs
    CompletedCodeProject?: boolean | CodeProjectFindManyArgs
    CodeProjectUser?: boolean | CodeProjectUserFindManyArgs
    CodeReport?: boolean | CodeReportFindManyArgs
    CodeReportApproval?: boolean | CodeReportApprovalFindManyArgs
    ProjectTask?: boolean | ProjectTaskFindManyArgs
    RequestForInformationAnswer?: boolean | RequestForInformationAnswerFindManyArgs
    CreateUserPosition?: boolean | UserPositionFindManyArgs
    UserPosition?: boolean | UserPositionFindManyArgs
    UserContact?: boolean | UserContactFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Client'
        ? Array < ClientGetPayload<S['include'][P]>>  :
        P extends 'ClientContact'
        ? Array < ClientContactGetPayload<S['include'][P]>>  :
        P extends 'CodeProjectDocument'
        ? Array < CodeProjectDocumentGetPayload<S['include'][P]>>  :
        P extends 'CreateCodeProject'
        ? Array < CodeProjectGetPayload<S['include'][P]>>  :
        P extends 'ConfirmedCodeProject'
        ? Array < CodeProjectGetPayload<S['include'][P]>>  :
        P extends 'CompletedCodeProject'
        ? Array < CodeProjectGetPayload<S['include'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < CodeProjectUserGetPayload<S['include'][P]>>  :
        P extends 'CodeReport'
        ? Array < CodeReportGetPayload<S['include'][P]>>  :
        P extends 'CodeReportApproval'
        ? Array < CodeReportApprovalGetPayload<S['include'][P]>>  :
        P extends 'ProjectTask'
        ? Array < ProjectTaskGetPayload<S['include'][P]>>  :
        P extends 'RequestForInformationAnswer'
        ? Array < RequestForInformationAnswerGetPayload<S['include'][P]>>  :
        P extends 'CreateUserPosition'
        ? Array < UserPositionGetPayload<S['include'][P]>>  :
        P extends 'UserPosition'
        ? Array < UserPositionGetPayload<S['include'][P]>>  :
        P extends 'UserContact'
        ? Array < UserContactGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'Client'
        ? Array < ClientGetPayload<S['select'][P]>>  :
        P extends 'ClientContact'
        ? Array < ClientContactGetPayload<S['select'][P]>>  :
        P extends 'CodeProjectDocument'
        ? Array < CodeProjectDocumentGetPayload<S['select'][P]>>  :
        P extends 'CreateCodeProject'
        ? Array < CodeProjectGetPayload<S['select'][P]>>  :
        P extends 'ConfirmedCodeProject'
        ? Array < CodeProjectGetPayload<S['select'][P]>>  :
        P extends 'CompletedCodeProject'
        ? Array < CodeProjectGetPayload<S['select'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < CodeProjectUserGetPayload<S['select'][P]>>  :
        P extends 'CodeReport'
        ? Array < CodeReportGetPayload<S['select'][P]>>  :
        P extends 'CodeReportApproval'
        ? Array < CodeReportApprovalGetPayload<S['select'][P]>>  :
        P extends 'ProjectTask'
        ? Array < ProjectTaskGetPayload<S['select'][P]>>  :
        P extends 'RequestForInformationAnswer'
        ? Array < RequestForInformationAnswerGetPayload<S['select'][P]>>  :
        P extends 'CreateUserPosition'
        ? Array < UserPositionGetPayload<S['select'][P]>>  :
        P extends 'UserPosition'
        ? Array < UserPositionGetPayload<S['select'][P]>>  :
        P extends 'UserContact'
        ? Array < UserContactGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Client<T extends ClientFindManyArgs = {}>(args?: Subset<T, ClientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Client>>, PrismaPromise<Array<ClientGetPayload<T>>>>;

    ClientContact<T extends ClientContactFindManyArgs = {}>(args?: Subset<T, ClientContactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ClientContact>>, PrismaPromise<Array<ClientContactGetPayload<T>>>>;

    CodeProjectDocument<T extends CodeProjectDocumentFindManyArgs = {}>(args?: Subset<T, CodeProjectDocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProjectDocument>>, PrismaPromise<Array<CodeProjectDocumentGetPayload<T>>>>;

    CreateCodeProject<T extends CodeProjectFindManyArgs = {}>(args?: Subset<T, CodeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProject>>, PrismaPromise<Array<CodeProjectGetPayload<T>>>>;

    ConfirmedCodeProject<T extends CodeProjectFindManyArgs = {}>(args?: Subset<T, CodeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProject>>, PrismaPromise<Array<CodeProjectGetPayload<T>>>>;

    CompletedCodeProject<T extends CodeProjectFindManyArgs = {}>(args?: Subset<T, CodeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProject>>, PrismaPromise<Array<CodeProjectGetPayload<T>>>>;

    CodeProjectUser<T extends CodeProjectUserFindManyArgs = {}>(args?: Subset<T, CodeProjectUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeProjectUser>>, PrismaPromise<Array<CodeProjectUserGetPayload<T>>>>;

    CodeReport<T extends CodeReportFindManyArgs = {}>(args?: Subset<T, CodeReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeReport>>, PrismaPromise<Array<CodeReportGetPayload<T>>>>;

    CodeReportApproval<T extends CodeReportApprovalFindManyArgs = {}>(args?: Subset<T, CodeReportApprovalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CodeReportApproval>>, PrismaPromise<Array<CodeReportApprovalGetPayload<T>>>>;

    ProjectTask<T extends ProjectTaskFindManyArgs = {}>(args?: Subset<T, ProjectTaskFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProjectTask>>, PrismaPromise<Array<ProjectTaskGetPayload<T>>>>;

    RequestForInformationAnswer<T extends RequestForInformationAnswerFindManyArgs = {}>(args?: Subset<T, RequestForInformationAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestForInformationAnswer>>, PrismaPromise<Array<RequestForInformationAnswerGetPayload<T>>>>;

    CreateUserPosition<T extends UserPositionFindManyArgs = {}>(args?: Subset<T, UserPositionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserPosition>>, PrismaPromise<Array<UserPositionGetPayload<T>>>>;

    UserPosition<T extends UserPositionFindManyArgs = {}>(args?: Subset<T, UserPositionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserPosition>>, PrismaPromise<Array<UserPositionGetPayload<T>>>>;

    UserContact<T extends UserContactFindManyArgs = {}>(args?: Subset<T, UserContactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserContact>>, PrismaPromise<Array<UserContactGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ClientScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Address: 'Address',
    City: 'City',
    PhoneNumber: 'PhoneNumber',
    TaxIdentificationNumber: 'TaxIdentificationNumber',
    IsDelete: 'IsDelete',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientContactScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Position: 'Position',
    PhoneNumber: 'PhoneNumber',
    Email: 'Email',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    ClientId: 'ClientId'
  };

  export type ClientContactScalarFieldEnum = (typeof ClientContactScalarFieldEnum)[keyof typeof ClientContactScalarFieldEnum]


  export const CodeProjectScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    ClientId: 'ClientId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    ConfirmedDate: 'ConfirmedDate',
    ConfirmedBy: 'ConfirmedBy',
    Address: 'Address',
    DocumentName: 'DocumentName',
    IsCompleted: 'IsCompleted',
    CompletedDate: 'CompletedDate',
    CompletedBy: 'CompletedBy',
    IsDelete: 'IsDelete'
  };

  export type CodeProjectScalarFieldEnum = (typeof CodeProjectScalarFieldEnum)[keyof typeof CodeProjectScalarFieldEnum]


  export const CodeProjectDocumentScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Url: 'Url',
    CodeProjectId: 'CodeProjectId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate'
  };

  export type CodeProjectDocumentScalarFieldEnum = (typeof CodeProjectDocumentScalarFieldEnum)[keyof typeof CodeProjectDocumentScalarFieldEnum]


  export const CodeProjectUserScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    CodeProjectId: 'CodeProjectId'
  };

  export type CodeProjectUserScalarFieldEnum = (typeof CodeProjectUserScalarFieldEnum)[keyof typeof CodeProjectUserScalarFieldEnum]


  export const CodeReportScalarFieldEnum: {
    Id: 'Id',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    Date: 'Date',
    CodeProjectId: 'CodeProjectId',
    Type: 'Type',
    IsDelete: 'IsDelete',
    Note: 'Note'
  };

  export type CodeReportScalarFieldEnum = (typeof CodeReportScalarFieldEnum)[keyof typeof CodeReportScalarFieldEnum]


  export const CodeReportApprovalScalarFieldEnum: {
    Id: 'Id',
    CodeReportId: 'CodeReportId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    Comment: 'Comment',
    Approval: 'Approval',
    IsDelete: 'IsDelete'
  };

  export type CodeReportApprovalScalarFieldEnum = (typeof CodeReportApprovalScalarFieldEnum)[keyof typeof CodeReportApprovalScalarFieldEnum]


  export const DailyReportImageScalarFieldEnum: {
    Id: 'Id',
    CodeReportId: 'CodeReportId',
    ImageUrl: 'ImageUrl',
    Name: 'Name',
    Caption: 'Caption'
  };

  export type DailyReportImageScalarFieldEnum = (typeof DailyReportImageScalarFieldEnum)[keyof typeof DailyReportImageScalarFieldEnum]


  export const DailyTaskScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    Unit: 'Unit',
    Quantity: 'Quantity',
    ParentId: 'ParentId',
    CodeReportId: 'CodeReportId',
    Note: 'Note'
  };

  export type DailyTaskScalarFieldEnum = (typeof DailyTaskScalarFieldEnum)[keyof typeof DailyTaskScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Quantity: 'Quantity',
    Status: 'Status',
    Description: 'Description',
    Unit: 'Unit',
    CodeReportId: 'CodeReportId'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    BudgetPrice: 'BudgetPrice',
    Quantity: 'Quantity',
    Done: 'Done',
    IsDelete: 'IsDelete',
    CodeProjectId: 'CodeProjectId',
    ParentId: 'ParentId',
    EstimatedDuration: 'EstimatedDuration',
    Timeline: 'Timeline',
    Price: 'Price',
    Description: 'Description',
    Unit: 'Unit'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectTaskScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    ParentId: 'ParentId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate'
  };

  export type ProjectTaskScalarFieldEnum = (typeof ProjectTaskScalarFieldEnum)[keyof typeof ProjectTaskScalarFieldEnum]


  export const RequestForInformationScalarFieldEnum: {
    Id: 'Id',
    CodeReportId: 'CodeReportId',
    Description: 'Description',
    Header: 'Header',
    AddressedFor: 'AddressedFor',
    IsDelete: 'IsDelete'
  };

  export type RequestForInformationScalarFieldEnum = (typeof RequestForInformationScalarFieldEnum)[keyof typeof RequestForInformationScalarFieldEnum]


  export const RequestForInformationAnswerScalarFieldEnum: {
    Id: 'Id',
    Answer: 'Answer',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    RequestForInformationId: 'RequestForInformationId',
    IsDelete: 'IsDelete'
  };

  export type RequestForInformationAnswerScalarFieldEnum = (typeof RequestForInformationAnswerScalarFieldEnum)[keyof typeof RequestForInformationAnswerScalarFieldEnum]


  export const RequestForInformationDocumentScalarFieldEnum: {
    Id: 'Id',
    RequestForInformationId: 'RequestForInformationId',
    ImageUrl: 'ImageUrl',
    Name: 'Name'
  };

  export type RequestForInformationDocumentScalarFieldEnum = (typeof RequestForInformationDocumentScalarFieldEnum)[keyof typeof RequestForInformationDocumentScalarFieldEnum]


  export const StatusReportScalarFieldEnum: {
    Id: 'Id',
    Status: 'Status',
    CodeReportId: 'CodeReportId'
  };

  export type StatusReportScalarFieldEnum = (typeof StatusReportScalarFieldEnum)[keyof typeof StatusReportScalarFieldEnum]


  export const StatusReportImageScalarFieldEnum: {
    Id: 'Id',
    StatusReportId: 'StatusReportId',
    ImageUrl: 'ImageUrl',
    Name: 'Name'
  };

  export type StatusReportImageScalarFieldEnum = (typeof StatusReportImageScalarFieldEnum)[keyof typeof StatusReportImageScalarFieldEnum]


  export const ToolScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    Quantity: 'Quantity',
    CodeReportId: 'CodeReportId'
  };

  export type ToolScalarFieldEnum = (typeof ToolScalarFieldEnum)[keyof typeof ToolScalarFieldEnum]


  export const WeatherScalarFieldEnum: {
    Id: 'Id',
    WeatherId: 'WeatherId',
    CodeReportId: 'CodeReportId'
  };

  export type WeatherScalarFieldEnum = (typeof WeatherScalarFieldEnum)[keyof typeof WeatherScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    CodeReportId: 'CodeReportId',
    Quantity: 'Quantity'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const UserContactScalarFieldEnum: {
    Id: 'Id',
    PhoneNumber: 'PhoneNumber',
    UserId: 'UserId',
    WhatsappAvailable: 'WhatsappAvailable'
  };

  export type UserContactScalarFieldEnum = (typeof UserContactScalarFieldEnum)[keyof typeof UserContactScalarFieldEnum]


  export const UserPositionScalarFieldEnum: {
    Id: 'Id',
    Position: 'Position',
    EffectiveDate: 'EffectiveDate',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    UserId: 'UserId'
  };

  export type UserPositionScalarFieldEnum = (typeof UserPositionScalarFieldEnum)[keyof typeof UserPositionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    Id: 'Id',
    Email: 'Email',
    FirstName: 'FirstName',
    LastName: 'LastName',
    IsActive: 'IsActive',
    Password: 'Password',
    ImageUrl: 'ImageUrl',
    ThumbnailUrl: 'ThumbnailUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type ClientWhereInput = {
    AND?: Enumerable<ClientWhereInput>
    OR?: Enumerable<ClientWhereInput>
    NOT?: Enumerable<ClientWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Address?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    PhoneNumber?: StringNullableFilter | string | null
    TaxIdentificationNumber?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    IsDelete?: BoolFilter | boolean
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Contact?: ClientContactListRelationFilter
    CodeProject?: CodeProjectListRelationFilter
  }

  export type ClientOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    City?: SortOrder
    PhoneNumber?: SortOrder
    TaxIdentificationNumber?: SortOrder
    IsDelete?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
  }

  export type ClientWhereUniqueInput = {
    Id?: number
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClientScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClientScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Address?: StringNullableWithAggregatesFilter | string | null
    City?: StringNullableWithAggregatesFilter | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter | string | null
    TaxIdentificationNumber?: StringNullableWithAggregatesFilter | string | null
    IsDelete?: BoolWithAggregatesFilter | boolean
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ClientContactWhereInput = {
    AND?: Enumerable<ClientContactWhereInput>
    OR?: Enumerable<ClientContactWhereInput>
    NOT?: Enumerable<ClientContactWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Position?: StringFilter | string
    PhoneNumber?: StringFilter | string
    Email?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Client?: XOR<ClientRelationFilter, ClientWhereInput>
    ClientId?: IntFilter | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClientContactOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Position?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    ClientId?: SortOrder
  }

  export type ClientContactWhereUniqueInput = {
    Id?: number
  }

  export type ClientContactScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClientContactScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClientContactScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClientContactScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Position?: StringWithAggregatesFilter | string
    PhoneNumber?: StringWithAggregatesFilter | string
    Email?: StringWithAggregatesFilter | string
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    ClientId?: IntWithAggregatesFilter | number
  }

  export type CodeProjectWhereInput = {
    AND?: Enumerable<CodeProjectWhereInput>
    OR?: Enumerable<CodeProjectWhereInput>
    NOT?: Enumerable<CodeProjectWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    ClientId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    ConfirmedDate?: DateTimeNullableFilter | Date | string | null
    ConfirmedBy?: IntNullableFilter | number | null
    Address?: StringFilter | string
    DocumentName?: StringFilter | string
    IsCompleted?: BoolFilter | boolean
    CompletedDate?: DateTimeNullableFilter | Date | string | null
    CompletedBy?: IntNullableFilter | number | null
    IsDelete?: BoolFilter | boolean
    Client?: XOR<ClientRelationFilter, ClientWhereInput>
    User1?: XOR<UserRelationFilter, UserWhereInput>
    User2?: XOR<UserRelationFilter, UserWhereInput> | null
    User3?: XOR<UserRelationFilter, UserWhereInput> | null
    CodeProjectDocument?: CodeProjectDocumentListRelationFilter
    CodeProjectUser?: CodeProjectUserListRelationFilter
    CodeReport?: CodeReportListRelationFilter
    Project?: ProjectListRelationFilter
  }

  export type CodeProjectOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    ClientId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    ConfirmedDate?: SortOrder
    ConfirmedBy?: SortOrder
    Address?: SortOrder
    DocumentName?: SortOrder
    IsCompleted?: SortOrder
    CompletedDate?: SortOrder
    CompletedBy?: SortOrder
    IsDelete?: SortOrder
  }

  export type CodeProjectWhereUniqueInput = {
    Id?: number
  }

  export type CodeProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeProjectScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    ClientId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    ConfirmedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ConfirmedBy?: IntNullableWithAggregatesFilter | number | null
    Address?: StringWithAggregatesFilter | string
    DocumentName?: StringWithAggregatesFilter | string
    IsCompleted?: BoolWithAggregatesFilter | boolean
    CompletedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CompletedBy?: IntNullableWithAggregatesFilter | number | null
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type CodeProjectDocumentWhereInput = {
    AND?: Enumerable<CodeProjectDocumentWhereInput>
    OR?: Enumerable<CodeProjectDocumentWhereInput>
    NOT?: Enumerable<CodeProjectDocumentWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Url?: StringFilter | string
    CodeProjectId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    CodeProject?: XOR<CodeProjectRelationFilter, CodeProjectWhereInput>
  }

  export type CodeProjectDocumentOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Url?: SortOrder
    CodeProjectId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
  }

  export type CodeProjectDocumentWhereUniqueInput = {
    Id?: number
  }

  export type CodeProjectDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeProjectDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeProjectDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeProjectDocumentScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Url?: StringWithAggregatesFilter | string
    CodeProjectId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CodeProjectUserWhereInput = {
    AND?: Enumerable<CodeProjectUserWhereInput>
    OR?: Enumerable<CodeProjectUserWhereInput>
    NOT?: Enumerable<CodeProjectUserWhereInput>
    Id?: IntFilter | number
    UserId?: IntFilter | number
    CodeProjectId?: IntFilter | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    CodeProject?: XOR<CodeProjectRelationFilter, CodeProjectWhereInput>
  }

  export type CodeProjectUserOrderByInput = {
    Id?: SortOrder
    UserId?: SortOrder
    CodeProjectId?: SortOrder
  }

  export type CodeProjectUserWhereUniqueInput = {
    Id?: number
  }

  export type CodeProjectUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeProjectUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeProjectUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeProjectUserScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    UserId?: IntWithAggregatesFilter | number
    CodeProjectId?: IntWithAggregatesFilter | number
  }

  export type CodeReportWhereInput = {
    AND?: Enumerable<CodeReportWhereInput>
    OR?: Enumerable<CodeReportWhereInput>
    NOT?: Enumerable<CodeReportWhereInput>
    Id?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Date?: DateTimeFilter | Date | string
    CodeProjectId?: IntFilter | number
    Type?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    Note?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    CodeProject?: XOR<CodeProjectRelationFilter, CodeProjectWhereInput>
    CodeReportApproval?: CodeReportApprovalListRelationFilter
    CodeReportApprovalComment?: CodeReportApprovalListRelationFilter
    DailyReportImage?: DailyReportImageListRelationFilter
    DailyTask?: DailyTaskListRelationFilter
    StatusReport?: XOR<StatusReportRelationFilter, StatusReportWhereInput> | null
    Tool?: ToolListRelationFilter
    Weather?: XOR<WeatherRelationFilter, WeatherWhereInput> | null
    Material?: MaterialListRelationFilter
    Worker?: WorkerListRelationFilter
    RequestForInformation?: XOR<RequestForInformationRelationFilter, RequestForInformationWhereInput> | null
  }

  export type CodeReportOrderByInput = {
    Id?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    Date?: SortOrder
    CodeProjectId?: SortOrder
    Type?: SortOrder
    IsDelete?: SortOrder
    Note?: SortOrder
  }

  export type CodeReportWhereUniqueInput = {
    Id?: number
  }

  export type CodeReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeReportScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    Date?: DateTimeWithAggregatesFilter | Date | string
    CodeProjectId?: IntWithAggregatesFilter | number
    Type?: IntWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
    Note?: StringWithAggregatesFilter | string
  }

  export type CodeReportApprovalWhereInput = {
    AND?: Enumerable<CodeReportApprovalWhereInput>
    OR?: Enumerable<CodeReportApprovalWhereInput>
    NOT?: Enumerable<CodeReportApprovalWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Comment?: StringFilter | string
    Approval?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
    CodeReportComment?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CodeReportApprovalOrderByInput = {
    Id?: SortOrder
    CodeReportId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    Comment?: SortOrder
    Approval?: SortOrder
    IsDelete?: SortOrder
  }

  export type CodeReportApprovalWhereUniqueInput = {
    Id?: number
  }

  export type CodeReportApprovalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeReportApprovalScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeReportApprovalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeReportApprovalScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    Comment?: StringWithAggregatesFilter | string
    Approval?: IntWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type DailyReportImageWhereInput = {
    AND?: Enumerable<DailyReportImageWhereInput>
    OR?: Enumerable<DailyReportImageWhereInput>
    NOT?: Enumerable<DailyReportImageWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    Caption?: StringFilter | string
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
  }

  export type DailyReportImageOrderByInput = {
    Id?: SortOrder
    CodeReportId?: SortOrder
    ImageUrl?: SortOrder
    Name?: SortOrder
    Caption?: SortOrder
  }

  export type DailyReportImageWhereUniqueInput = {
    Id?: number
  }

  export type DailyReportImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyReportImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyReportImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyReportImageScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    ImageUrl?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Caption?: StringWithAggregatesFilter | string
  }

  export type DailyTaskWhereInput = {
    AND?: Enumerable<DailyTaskWhereInput>
    OR?: Enumerable<DailyTaskWhereInput>
    NOT?: Enumerable<DailyTaskWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Unit?: StringFilter | string
    Quantity?: FloatFilter | number
    ParentId?: IntFilter | number
    CodeReportId?: IntFilter | number
    Note?: StringFilter | string
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
  }

  export type DailyTaskOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Unit?: SortOrder
    Quantity?: SortOrder
    ParentId?: SortOrder
    CodeReportId?: SortOrder
    Note?: SortOrder
  }

  export type DailyTaskWhereUniqueInput = {
    Id?: number
  }

  export type DailyTaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyTaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyTaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyTaskScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Description?: StringWithAggregatesFilter | string
    Unit?: StringWithAggregatesFilter | string
    Quantity?: FloatWithAggregatesFilter | number
    ParentId?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    Note?: StringWithAggregatesFilter | string
  }

  export type MaterialWhereInput = {
    AND?: Enumerable<MaterialWhereInput>
    OR?: Enumerable<MaterialWhereInput>
    NOT?: Enumerable<MaterialWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Quantity?: FloatFilter | number
    Status?: IntFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
  }

  export type MaterialOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Quantity?: SortOrder
    Status?: SortOrder
    Description?: SortOrder
    Unit?: SortOrder
    CodeReportId?: SortOrder
  }

  export type MaterialWhereUniqueInput = {
    Id?: number
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MaterialScalarWhereWithAggregatesInput>
    OR?: Enumerable<MaterialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MaterialScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Quantity?: FloatWithAggregatesFilter | number
    Status?: IntWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Unit?: StringWithAggregatesFilter | string
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type ProjectWhereInput = {
    AND?: Enumerable<ProjectWhereInput>
    OR?: Enumerable<ProjectWhereInput>
    NOT?: Enumerable<ProjectWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    BudgetPrice?: FloatFilter | number
    Quantity?: FloatFilter | number
    Done?: FloatFilter | number
    IsDelete?: BoolFilter | boolean
    CodeProjectId?: IntFilter | number
    ParentId?: IntFilter | number
    EstimatedDuration?: FloatFilter | number
    Timeline?: IntFilter | number
    Price?: FloatFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
    CodeProject?: XOR<CodeProjectRelationFilter, CodeProjectWhereInput>
  }

  export type ProjectOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    BudgetPrice?: SortOrder
    Quantity?: SortOrder
    Done?: SortOrder
    IsDelete?: SortOrder
    CodeProjectId?: SortOrder
    ParentId?: SortOrder
    EstimatedDuration?: SortOrder
    Timeline?: SortOrder
    Price?: SortOrder
    Description?: SortOrder
    Unit?: SortOrder
  }

  export type ProjectWhereUniqueInput = {
    Id?: number
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    BudgetPrice?: FloatWithAggregatesFilter | number
    Quantity?: FloatWithAggregatesFilter | number
    Done?: FloatWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
    CodeProjectId?: IntWithAggregatesFilter | number
    ParentId?: IntWithAggregatesFilter | number
    EstimatedDuration?: FloatWithAggregatesFilter | number
    Timeline?: IntWithAggregatesFilter | number
    Price?: FloatWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Unit?: StringWithAggregatesFilter | string
  }

  export type ProjectTaskWhereInput = {
    AND?: Enumerable<ProjectTaskWhereInput>
    OR?: Enumerable<ProjectTaskWhereInput>
    NOT?: Enumerable<ProjectTaskWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    ParentId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectTaskOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    ParentId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
  }

  export type ProjectTaskWhereUniqueInput = {
    Id?: number
  }

  export type ProjectTaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectTaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectTaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectTaskScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Description?: StringWithAggregatesFilter | string
    ParentId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestForInformationWhereInput = {
    AND?: Enumerable<RequestForInformationWhereInput>
    OR?: Enumerable<RequestForInformationWhereInput>
    NOT?: Enumerable<RequestForInformationWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    Description?: StringFilter | string
    Header?: StringFilter | string
    AddressedFor?: StringFilter | string
    IsDelete?: BoolFilter | boolean
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
    RequestForInformationAnswer?: RequestForInformationAnswerListRelationFilter
    RequestForInformationDocument?: RequestForInformationDocumentListRelationFilter
  }

  export type RequestForInformationOrderByInput = {
    Id?: SortOrder
    CodeReportId?: SortOrder
    Description?: SortOrder
    Header?: SortOrder
    AddressedFor?: SortOrder
    IsDelete?: SortOrder
  }

  export type RequestForInformationWhereUniqueInput = {
    Id?: number
  }

  export type RequestForInformationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestForInformationScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestForInformationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestForInformationScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Header?: StringWithAggregatesFilter | string
    AddressedFor?: StringWithAggregatesFilter | string
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type RequestForInformationAnswerWhereInput = {
    AND?: Enumerable<RequestForInformationAnswerWhereInput>
    OR?: Enumerable<RequestForInformationAnswerWhereInput>
    NOT?: Enumerable<RequestForInformationAnswerWhereInput>
    Id?: IntFilter | number
    Answer?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    RequestForInformationId?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    User?: XOR<UserRelationFilter, UserWhereInput>
    RequestForInformation?: XOR<RequestForInformationRelationFilter, RequestForInformationWhereInput>
  }

  export type RequestForInformationAnswerOrderByInput = {
    Id?: SortOrder
    Answer?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    RequestForInformationId?: SortOrder
    IsDelete?: SortOrder
  }

  export type RequestForInformationAnswerWhereUniqueInput = {
    Id?: number
  }

  export type RequestForInformationAnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestForInformationAnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestForInformationAnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestForInformationAnswerScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Answer?: StringWithAggregatesFilter | string
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    RequestForInformationId?: IntWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type RequestForInformationDocumentWhereInput = {
    AND?: Enumerable<RequestForInformationDocumentWhereInput>
    OR?: Enumerable<RequestForInformationDocumentWhereInput>
    NOT?: Enumerable<RequestForInformationDocumentWhereInput>
    Id?: IntFilter | number
    RequestForInformationId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    RequestForInformation?: XOR<RequestForInformationRelationFilter, RequestForInformationWhereInput>
  }

  export type RequestForInformationDocumentOrderByInput = {
    Id?: SortOrder
    RequestForInformationId?: SortOrder
    ImageUrl?: SortOrder
    Name?: SortOrder
  }

  export type RequestForInformationDocumentWhereUniqueInput = {
    Id?: number
  }

  export type RequestForInformationDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestForInformationDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestForInformationDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestForInformationDocumentScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    RequestForInformationId?: IntWithAggregatesFilter | number
    ImageUrl?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
  }

  export type StatusReportWhereInput = {
    AND?: Enumerable<StatusReportWhereInput>
    OR?: Enumerable<StatusReportWhereInput>
    NOT?: Enumerable<StatusReportWhereInput>
    Id?: IntFilter | number
    Status?: StringFilter | string
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
    StatusReportImage?: StatusReportImageListRelationFilter
  }

  export type StatusReportOrderByInput = {
    Id?: SortOrder
    Status?: SortOrder
    CodeReportId?: SortOrder
  }

  export type StatusReportWhereUniqueInput = {
    Id?: number
  }

  export type StatusReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StatusReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<StatusReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StatusReportScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Status?: StringWithAggregatesFilter | string
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type StatusReportImageWhereInput = {
    AND?: Enumerable<StatusReportImageWhereInput>
    OR?: Enumerable<StatusReportImageWhereInput>
    NOT?: Enumerable<StatusReportImageWhereInput>
    Id?: IntFilter | number
    StatusReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    StatusReport?: XOR<StatusReportRelationFilter, StatusReportWhereInput>
  }

  export type StatusReportImageOrderByInput = {
    Id?: SortOrder
    StatusReportId?: SortOrder
    ImageUrl?: SortOrder
    Name?: SortOrder
  }

  export type StatusReportImageWhereUniqueInput = {
    Id?: number
  }

  export type StatusReportImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StatusReportImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<StatusReportImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StatusReportImageScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    StatusReportId?: IntWithAggregatesFilter | number
    ImageUrl?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
  }

  export type ToolWhereInput = {
    AND?: Enumerable<ToolWhereInput>
    OR?: Enumerable<ToolWhereInput>
    NOT?: Enumerable<ToolWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Quantity?: IntFilter | number
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
  }

  export type ToolOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Quantity?: SortOrder
    CodeReportId?: SortOrder
  }

  export type ToolWhereUniqueInput = {
    Id?: number
  }

  export type ToolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ToolScalarWhereWithAggregatesInput>
    OR?: Enumerable<ToolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ToolScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Description?: StringWithAggregatesFilter | string
    Quantity?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type WeatherWhereInput = {
    AND?: Enumerable<WeatherWhereInput>
    OR?: Enumerable<WeatherWhereInput>
    NOT?: Enumerable<WeatherWhereInput>
    Id?: IntFilter | number
    WeatherId?: IntFilter | number
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
  }

  export type WeatherOrderByInput = {
    Id?: SortOrder
    WeatherId?: SortOrder
    CodeReportId?: SortOrder
  }

  export type WeatherWhereUniqueInput = {
    Id?: number
  }

  export type WeatherScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WeatherScalarWhereWithAggregatesInput>
    OR?: Enumerable<WeatherScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WeatherScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    WeatherId?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type WorkerWhereInput = {
    AND?: Enumerable<WorkerWhereInput>
    OR?: Enumerable<WorkerWhereInput>
    NOT?: Enumerable<WorkerWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    CodeReportId?: IntFilter | number
    Quantity?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, CodeReportWhereInput>
  }

  export type WorkerOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    CodeReportId?: SortOrder
    Quantity?: SortOrder
  }

  export type WorkerWhereUniqueInput = {
    Id?: number
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkerScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkerScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    CodeReportId?: IntWithAggregatesFilter | number
    Quantity?: IntWithAggregatesFilter | number
  }

  export type UserContactWhereInput = {
    AND?: Enumerable<UserContactWhereInput>
    OR?: Enumerable<UserContactWhereInput>
    NOT?: Enumerable<UserContactWhereInput>
    Id?: IntFilter | number
    PhoneNumber?: StringFilter | string
    UserId?: IntFilter | number
    WhatsappAvailable?: BoolFilter | boolean
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserContactOrderByInput = {
    Id?: SortOrder
    PhoneNumber?: SortOrder
    UserId?: SortOrder
    WhatsappAvailable?: SortOrder
  }

  export type UserContactWhereUniqueInput = {
    Id?: number
  }

  export type UserContactScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserContactScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserContactScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserContactScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    PhoneNumber?: StringWithAggregatesFilter | string
    UserId?: IntWithAggregatesFilter | number
    WhatsappAvailable?: BoolWithAggregatesFilter | boolean
  }

  export type UserPositionWhereInput = {
    AND?: Enumerable<UserPositionWhereInput>
    OR?: Enumerable<UserPositionWhereInput>
    NOT?: Enumerable<UserPositionWhereInput>
    Id?: IntFilter | number
    Position?: IntFilter | number
    EffectiveDate?: DateTimeFilter | Date | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    UserId?: IntFilter | number
    User4?: XOR<UserRelationFilter, UserWhereInput>
    User5?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserPositionOrderByInput = {
    Id?: SortOrder
    Position?: SortOrder
    EffectiveDate?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    UserId?: SortOrder
  }

  export type UserPositionWhereUniqueInput = {
    Id?: number
  }

  export type UserPositionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserPositionScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserPositionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserPositionScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Position?: IntWithAggregatesFilter | number
    EffectiveDate?: DateTimeWithAggregatesFilter | Date | string
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    UserId?: IntWithAggregatesFilter | number
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    Id?: IntFilter | number
    Email?: StringFilter | string
    FirstName?: StringFilter | string
    LastName?: StringFilter | string
    IsActive?: BoolFilter | boolean
    Password?: StringNullableFilter | string | null
    ImageUrl?: StringNullableFilter | string | null
    ThumbnailUrl?: StringNullableFilter | string | null
    Client?: ClientListRelationFilter
    ClientContact?: ClientContactListRelationFilter
    CodeProjectDocument?: CodeProjectDocumentListRelationFilter
    CreateCodeProject?: CodeProjectListRelationFilter
    ConfirmedCodeProject?: CodeProjectListRelationFilter
    CompletedCodeProject?: CodeProjectListRelationFilter
    CodeProjectUser?: CodeProjectUserListRelationFilter
    CodeReport?: CodeReportListRelationFilter
    CodeReportApproval?: CodeReportApprovalListRelationFilter
    ProjectTask?: ProjectTaskListRelationFilter
    RequestForInformationAnswer?: RequestForInformationAnswerListRelationFilter
    CreateUserPosition?: UserPositionListRelationFilter
    UserPosition?: UserPositionListRelationFilter
    UserContact?: UserContactListRelationFilter
  }

  export type UserOrderByInput = {
    Id?: SortOrder
    Email?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    IsActive?: SortOrder
    Password?: SortOrder
    ImageUrl?: SortOrder
    ThumbnailUrl?: SortOrder
  }

  export type UserWhereUniqueInput = {
    Id?: number
    Email?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Email?: StringWithAggregatesFilter | string
    FirstName?: StringWithAggregatesFilter | string
    LastName?: StringWithAggregatesFilter | string
    IsActive?: BoolWithAggregatesFilter | boolean
    Password?: StringNullableWithAggregatesFilter | string | null
    ImageUrl?: StringNullableWithAggregatesFilter | string | null
    ThumbnailUrl?: StringNullableWithAggregatesFilter | string | null
  }

  export type ClientCreateInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    User: UserCreateNestedOneWithoutClientInput
    Contact?: ClientContactCreateNestedManyWithoutClientInput
    CodeProject?: CodeProjectCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
    Contact?: ClientContactUncheckedCreateNestedManyWithoutClientInput
    CodeProject?: CodeProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutClientInput
    Contact?: ClientContactUpdateManyWithoutClientInput
    CodeProject?: CodeProjectUpdateManyWithoutClientInput
  }

  export type ClientUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ClientContactUncheckedUpdateManyWithoutClientInput
    CodeProject?: CodeProjectUncheckedUpdateManyWithoutClientInput
  }

  export type ClientCreateManyInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContactCreateInput = {
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    Client: ClientCreateNestedOneWithoutContactInput
    User: UserCreateNestedOneWithoutClientContactInput
  }

  export type ClientContactUncheckedCreateInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
    ClientId: number
  }

  export type ClientContactUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Client?: ClientUpdateOneRequiredWithoutContactInput
    User?: UserUpdateOneRequiredWithoutClientContactInput
  }

  export type ClientContactUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContactCreateManyInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
    ClientId: number
  }

  export type ClientContactUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContactUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeProjectCreateInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateManyInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type CodeProjectUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeProjectUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeProjectDocumentCreateInput = {
    Name: string
    Url: string
    CreatedDate?: Date | string
    User: UserCreateNestedOneWithoutCodeProjectDocumentInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeProjectDocumentInput
  }

  export type CodeProjectDocumentUncheckedCreateInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type CodeProjectDocumentUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutCodeProjectDocumentInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeProjectDocumentInput
  }

  export type CodeProjectDocumentUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeProjectDocumentCreateManyInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type CodeProjectDocumentUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeProjectDocumentUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeProjectUserCreateInput = {
    User: UserCreateNestedOneWithoutCodeProjectUserInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeProjectUserInput
  }

  export type CodeProjectUserUncheckedCreateInput = {
    Id?: number
    UserId: number
    CodeProjectId: number
  }

  export type CodeProjectUserUpdateInput = {
    User?: UserUpdateOneRequiredWithoutCodeProjectUserInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeProjectUserInput
  }

  export type CodeProjectUserUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    CodeProjectId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeProjectUserCreateManyInput = {
    Id?: number
    UserId: number
    CodeProjectId: number
  }

  export type CodeProjectUserUpdateManyMutationInput = {

  }

  export type CodeProjectUserUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    CodeProjectId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeReportCreateInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUpdateInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportCreateManyInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
  }

  export type CodeReportUpdateManyMutationInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type CodeReportUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type CodeReportApprovalCreateInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReport: CodeReportCreateNestedOneWithoutCodeReportApprovalInput
    CodeReportComment: CodeReportCreateNestedOneWithoutCodeReportApprovalCommentInput
    User: UserCreateNestedOneWithoutCodeReportApprovalInput
  }

  export type CodeReportApprovalUncheckedCreateInput = {
    Id?: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type CodeReportApprovalUpdateInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: CodeReportUpdateOneRequiredWithoutCodeReportApprovalInput
    CodeReportComment?: CodeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput
    User?: UserUpdateOneRequiredWithoutCodeReportApprovalInput
  }

  export type CodeReportApprovalUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeReportApprovalCreateManyInput = {
    Id?: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type CodeReportApprovalUpdateManyMutationInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeReportApprovalUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyReportImageCreateInput = {
    ImageUrl: string
    Name: string
    Caption: string
    CodeReport: CodeReportCreateNestedOneWithoutDailyReportImageInput
  }

  export type DailyReportImageUncheckedCreateInput = {
    Id?: number
    CodeReportId: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type DailyReportImageUpdateInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
    CodeReport?: CodeReportUpdateOneRequiredWithoutDailyReportImageInput
  }

  export type DailyReportImageUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportImageCreateManyInput = {
    Id?: number
    CodeReportId: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type DailyReportImageUpdateManyMutationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportImageUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type DailyTaskCreateInput = {
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
    CodeReport: CodeReportCreateNestedOneWithoutDailyTaskInput
  }

  export type DailyTaskUncheckedCreateInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: string
  }

  export type DailyTaskUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    CodeReport?: CodeReportUpdateOneRequiredWithoutDailyTaskInput
  }

  export type DailyTaskUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type DailyTaskCreateManyInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: string
  }

  export type DailyTaskUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type DailyTaskUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialCreateInput = {
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReport: CodeReportCreateNestedOneWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReportId: number
  }

  export type MaterialUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeReport?: CodeReportUpdateOneRequiredWithoutMaterialInput
  }

  export type MaterialUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialCreateManyInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReportId: number
  }

  export type MaterialUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateInput = {
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
    CodeProject: CodeProjectCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type ProjectUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeProject?: CodeProjectUpdateOneRequiredWithoutProjectInput
  }

  export type ProjectUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateManyInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type ProjectUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTaskCreateInput = {
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
    User: UserCreateNestedOneWithoutProjectTaskInput
  }

  export type ProjectTaskUncheckedCreateInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type ProjectTaskUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutProjectTaskInput
  }

  export type ProjectTaskUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskCreateManyInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type ProjectTaskUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestForInformationCreateInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    CodeReport: CodeReportCreateNestedOneWithoutRequestForInformationInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedCreateInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUpdateInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: CodeReportUpdateOneRequiredWithoutRequestForInformationInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentUpdateManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type RequestForInformationCreateManyInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
  }

  export type RequestForInformationUpdateManyMutationInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestForInformationUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestForInformationAnswerCreateInput = {
    Answer: string
    CreatedDate: Date | string
    IsDelete?: boolean
    User: UserCreateNestedOneWithoutRequestForInformationAnswerInput
    RequestForInformation: RequestForInformationCreateNestedOneWithoutRequestForInformationAnswerInput
  }

  export type RequestForInformationAnswerUncheckedCreateInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type RequestForInformationAnswerUpdateInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutRequestForInformationAnswerInput
    RequestForInformation?: RequestForInformationUpdateOneRequiredWithoutRequestForInformationAnswerInput
  }

  export type RequestForInformationAnswerUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestForInformationAnswerCreateManyInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type RequestForInformationAnswerUpdateManyMutationInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestForInformationAnswerUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestForInformationDocumentCreateInput = {
    ImageUrl: string
    Name: string
    RequestForInformation: RequestForInformationCreateNestedOneWithoutRequestForInformationDocumentInput
  }

  export type RequestForInformationDocumentUncheckedCreateInput = {
    Id?: number
    RequestForInformationId: number
    ImageUrl: string
    Name: string
  }

  export type RequestForInformationDocumentUpdateInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    RequestForInformation?: RequestForInformationUpdateOneRequiredWithoutRequestForInformationDocumentInput
  }

  export type RequestForInformationDocumentUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type RequestForInformationDocumentCreateManyInput = {
    Id?: number
    RequestForInformationId: number
    ImageUrl: string
    Name: string
  }

  export type RequestForInformationDocumentUpdateManyMutationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type RequestForInformationDocumentUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusReportCreateInput = {
    Status: string
    CodeReport: CodeReportCreateNestedOneWithoutStatusReportInput
    StatusReportImage?: StatusReportImageCreateNestedManyWithoutStatusReportInput
  }

  export type StatusReportUncheckedCreateInput = {
    Id?: number
    Status: string
    CodeReportId: number
    StatusReportImage?: StatusReportImageUncheckedCreateNestedManyWithoutStatusReportInput
  }

  export type StatusReportUpdateInput = {
    Status?: StringFieldUpdateOperationsInput | string
    CodeReport?: CodeReportUpdateOneRequiredWithoutStatusReportInput
    StatusReportImage?: StatusReportImageUpdateManyWithoutStatusReportInput
  }

  export type StatusReportUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
    StatusReportImage?: StatusReportImageUncheckedUpdateManyWithoutStatusReportInput
  }

  export type StatusReportCreateManyInput = {
    Id?: number
    Status: string
    CodeReportId: number
  }

  export type StatusReportUpdateManyMutationInput = {
    Status?: StringFieldUpdateOperationsInput | string
  }

  export type StatusReportUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type StatusReportImageCreateInput = {
    ImageUrl: string
    Name: string
    StatusReport: StatusReportCreateNestedOneWithoutStatusReportImageInput
  }

  export type StatusReportImageUncheckedCreateInput = {
    Id?: number
    StatusReportId: number
    ImageUrl: string
    Name: string
  }

  export type StatusReportImageUpdateInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    StatusReport?: StatusReportUpdateOneRequiredWithoutStatusReportImageInput
  }

  export type StatusReportImageUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    StatusReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusReportImageCreateManyInput = {
    Id?: number
    StatusReportId: number
    ImageUrl: string
    Name: string
  }

  export type StatusReportImageUpdateManyMutationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusReportImageUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    StatusReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type ToolCreateInput = {
    Name: string
    Description: string
    Quantity: number
    CodeReport: CodeReportCreateNestedOneWithoutToolInput
  }

  export type ToolUncheckedCreateInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
    CodeReportId: number
  }

  export type ToolUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReport?: CodeReportUpdateOneRequiredWithoutToolInput
  }

  export type ToolUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type ToolCreateManyInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
    CodeReportId: number
  }

  export type ToolUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ToolUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type WeatherCreateInput = {
    WeatherId: number
    CodeReport: CodeReportCreateNestedOneWithoutWeatherInput
  }

  export type WeatherUncheckedCreateInput = {
    Id?: number
    WeatherId: number
    CodeReportId: number
  }

  export type WeatherUpdateInput = {
    WeatherId?: IntFieldUpdateOperationsInput | number
    CodeReport?: CodeReportUpdateOneRequiredWithoutWeatherInput
  }

  export type WeatherUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    WeatherId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type WeatherCreateManyInput = {
    Id?: number
    WeatherId: number
    CodeReportId: number
  }

  export type WeatherUpdateManyMutationInput = {
    WeatherId?: IntFieldUpdateOperationsInput | number
  }

  export type WeatherUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    WeatherId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerCreateInput = {
    Name: string
    Quantity: number
    CodeReport: CodeReportCreateNestedOneWithoutWorkerInput
  }

  export type WorkerUncheckedCreateInput = {
    Id?: number
    Name: string
    CodeReportId: number
    Quantity: number
  }

  export type WorkerUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReport?: CodeReportUpdateOneRequiredWithoutWorkerInput
  }

  export type WorkerUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerCreateManyInput = {
    Id?: number
    Name: string
    CodeReportId: number
    Quantity: number
  }

  export type WorkerUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type UserContactCreateInput = {
    PhoneNumber: string
    WhatsappAvailable: boolean
    User: UserCreateNestedOneWithoutUserContactInput
  }

  export type UserContactUncheckedCreateInput = {
    Id?: number
    PhoneNumber: string
    UserId: number
    WhatsappAvailable: boolean
  }

  export type UserContactUpdateInput = {
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutUserContactInput
  }

  export type UserContactUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    UserId?: IntFieldUpdateOperationsInput | number
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserContactCreateManyInput = {
    Id?: number
    PhoneNumber: string
    UserId: number
    WhatsappAvailable: boolean
  }

  export type UserContactUpdateManyMutationInput = {
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserContactUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    UserId?: IntFieldUpdateOperationsInput | number
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPositionCreateInput = {
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    User4: UserCreateNestedOneWithoutCreateUserPositionInput
    User5: UserCreateNestedOneWithoutUserPositionInput
  }

  export type UserPositionUncheckedCreateInput = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
    UserId: number
  }

  export type UserPositionUpdateInput = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User4?: UserUpdateOneRequiredWithoutCreateUserPositionInput
    User5?: UserUpdateOneRequiredWithoutUserPositionInput
  }

  export type UserPositionUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPositionCreateManyInput = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
    UserId: number
  }

  export type UserPositionUpdateManyMutationInput = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPositionUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ClientContactListRelationFilter = {
    every?: ClientContactWhereInput
    some?: ClientContactWhereInput
    none?: ClientContactWhereInput
  }

  export type CodeProjectListRelationFilter = {
    every?: CodeProjectWhereInput
    some?: CodeProjectWhereInput
    none?: CodeProjectWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CodeProjectDocumentListRelationFilter = {
    every?: CodeProjectDocumentWhereInput
    some?: CodeProjectDocumentWhereInput
    none?: CodeProjectDocumentWhereInput
  }

  export type CodeProjectUserListRelationFilter = {
    every?: CodeProjectUserWhereInput
    some?: CodeProjectUserWhereInput
    none?: CodeProjectUserWhereInput
  }

  export type CodeReportListRelationFilter = {
    every?: CodeReportWhereInput
    some?: CodeReportWhereInput
    none?: CodeReportWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type CodeProjectRelationFilter = {
    is?: CodeProjectWhereInput
    isNot?: CodeProjectWhereInput
  }

  export type CodeReportApprovalListRelationFilter = {
    every?: CodeReportApprovalWhereInput
    some?: CodeReportApprovalWhereInput
    none?: CodeReportApprovalWhereInput
  }

  export type DailyReportImageListRelationFilter = {
    every?: DailyReportImageWhereInput
    some?: DailyReportImageWhereInput
    none?: DailyReportImageWhereInput
  }

  export type DailyTaskListRelationFilter = {
    every?: DailyTaskWhereInput
    some?: DailyTaskWhereInput
    none?: DailyTaskWhereInput
  }

  export type StatusReportRelationFilter = {
    is?: StatusReportWhereInput
    isNot?: StatusReportWhereInput
  }

  export type ToolListRelationFilter = {
    every?: ToolWhereInput
    some?: ToolWhereInput
    none?: ToolWhereInput
  }

  export type WeatherRelationFilter = {
    is?: WeatherWhereInput | null
    isNot?: WeatherWhereInput | null
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type WorkerListRelationFilter = {
    every?: WorkerWhereInput
    some?: WorkerWhereInput
    none?: WorkerWhereInput
  }

  export type RequestForInformationRelationFilter = {
    is?: RequestForInformationWhereInput
    isNot?: RequestForInformationWhereInput
  }

  export type CodeReportRelationFilter = {
    is?: CodeReportWhereInput
    isNot?: CodeReportWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type RequestForInformationAnswerListRelationFilter = {
    every?: RequestForInformationAnswerWhereInput
    some?: RequestForInformationAnswerWhereInput
    none?: RequestForInformationAnswerWhereInput
  }

  export type RequestForInformationDocumentListRelationFilter = {
    every?: RequestForInformationDocumentWhereInput
    some?: RequestForInformationDocumentWhereInput
    none?: RequestForInformationDocumentWhereInput
  }

  export type StatusReportImageListRelationFilter = {
    every?: StatusReportImageWhereInput
    some?: StatusReportImageWhereInput
    none?: StatusReportImageWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type ProjectTaskListRelationFilter = {
    every?: ProjectTaskWhereInput
    some?: ProjectTaskWhereInput
    none?: ProjectTaskWhereInput
  }

  export type UserPositionListRelationFilter = {
    every?: UserPositionWhereInput
    some?: UserPositionWhereInput
    none?: UserPositionWhereInput
  }

  export type UserContactListRelationFilter = {
    every?: UserContactWhereInput
    some?: UserContactWhereInput
    none?: UserContactWhereInput
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type ClientContactCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutClientInput>, Enumerable<ClientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutClientInput>
    createMany?: ClientContactCreateManyClientInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
  }

  export type CodeProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutClientInput>, Enumerable<CodeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutClientInput>
    createMany?: CodeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type ClientContactUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutClientInput>, Enumerable<ClientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutClientInput>
    createMany?: ClientContactCreateManyClientInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
  }

  export type CodeProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutClientInput>, Enumerable<CodeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutClientInput>
    createMany?: CodeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type ClientContactUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutClientInput>, Enumerable<ClientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ClientContactUpsertWithWhereUniqueWithoutClientInput>
    createMany?: ClientContactCreateManyClientInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
    set?: Enumerable<ClientContactWhereUniqueInput>
    disconnect?: Enumerable<ClientContactWhereUniqueInput>
    delete?: Enumerable<ClientContactWhereUniqueInput>
    update?: Enumerable<ClientContactUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ClientContactUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ClientContactScalarWhereInput>
  }

  export type CodeProjectUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutClientInput>, Enumerable<CodeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutClientInput>
    createMany?: CodeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientContactUncheckedUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutClientInput>, Enumerable<ClientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<ClientContactUpsertWithWhereUniqueWithoutClientInput>
    createMany?: ClientContactCreateManyClientInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
    set?: Enumerable<ClientContactWhereUniqueInput>
    disconnect?: Enumerable<ClientContactWhereUniqueInput>
    delete?: Enumerable<ClientContactWhereUniqueInput>
    update?: Enumerable<ClientContactUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<ClientContactUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<ClientContactScalarWhereInput>
  }

  export type CodeProjectUncheckedUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutClientInput>, Enumerable<CodeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutClientInput>
    createMany?: CodeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type ClientCreateNestedOneWithoutContactInput = {
    create?: XOR<ClientCreateWithoutContactInput, ClientUncheckedCreateWithoutContactInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientContactInput = {
    create?: XOR<UserCreateWithoutClientContactInput, UserUncheckedCreateWithoutClientContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientContactInput
    connect?: UserWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutContactInput = {
    create?: XOR<ClientCreateWithoutContactInput, ClientUncheckedCreateWithoutContactInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactInput
    upsert?: ClientUpsertWithoutContactInput
    connect?: ClientWhereUniqueInput
    update?: XOR<ClientUpdateWithoutContactInput, ClientUncheckedUpdateWithoutContactInput>
  }

  export type UserUpdateOneRequiredWithoutClientContactInput = {
    create?: XOR<UserCreateWithoutClientContactInput, UserUncheckedCreateWithoutClientContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientContactInput
    upsert?: UserUpsertWithoutClientContactInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutClientContactInput, UserUncheckedUpdateWithoutClientContactInput>
  }

  export type ClientCreateNestedOneWithoutCodeProjectInput = {
    create?: XOR<ClientCreateWithoutCodeProjectInput, ClientUncheckedCreateWithoutCodeProjectInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCodeProjectInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreateCodeProjectInput = {
    create?: XOR<UserCreateWithoutCreateCodeProjectInput, UserUncheckedCreateWithoutCreateCodeProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreateCodeProjectInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConfirmedCodeProjectInput = {
    create?: XOR<UserCreateWithoutConfirmedCodeProjectInput, UserUncheckedCreateWithoutConfirmedCodeProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmedCodeProjectInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompletedCodeProjectInput = {
    create?: XOR<UserCreateWithoutCompletedCodeProjectInput, UserUncheckedCreateWithoutCompletedCodeProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedCodeProjectInput
    connect?: UserWhereUniqueInput
  }

  export type CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    createMany?: CodeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
  }

  export type CodeProjectUserCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutCodeProjectInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutCodeProjectInput>
    createMany?: CodeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
  }

  export type CodeReportCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutCodeProjectInput>, Enumerable<CodeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutCodeProjectInput>
    createMany?: CodeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
  }

  export type ProjectCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCodeProjectInput>, Enumerable<ProjectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCodeProjectInput>
    createMany?: ProjectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    createMany?: CodeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
  }

  export type CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutCodeProjectInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutCodeProjectInput>
    createMany?: CodeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
  }

  export type CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutCodeProjectInput>, Enumerable<CodeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutCodeProjectInput>
    createMany?: CodeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
  }

  export type ProjectUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCodeProjectInput>, Enumerable<ProjectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCodeProjectInput>
    createMany?: ProjectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClientUpdateOneRequiredWithoutCodeProjectInput = {
    create?: XOR<ClientCreateWithoutCodeProjectInput, ClientUncheckedCreateWithoutCodeProjectInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCodeProjectInput
    upsert?: ClientUpsertWithoutCodeProjectInput
    connect?: ClientWhereUniqueInput
    update?: XOR<ClientUpdateWithoutCodeProjectInput, ClientUncheckedUpdateWithoutCodeProjectInput>
  }

  export type UserUpdateOneRequiredWithoutCreateCodeProjectInput = {
    create?: XOR<UserCreateWithoutCreateCodeProjectInput, UserUncheckedCreateWithoutCreateCodeProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreateCodeProjectInput
    upsert?: UserUpsertWithoutCreateCodeProjectInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreateCodeProjectInput, UserUncheckedUpdateWithoutCreateCodeProjectInput>
  }

  export type UserUpdateOneWithoutConfirmedCodeProjectInput = {
    create?: XOR<UserCreateWithoutConfirmedCodeProjectInput, UserUncheckedCreateWithoutConfirmedCodeProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfirmedCodeProjectInput
    upsert?: UserUpsertWithoutConfirmedCodeProjectInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutConfirmedCodeProjectInput, UserUncheckedUpdateWithoutConfirmedCodeProjectInput>
  }

  export type UserUpdateOneWithoutCompletedCodeProjectInput = {
    create?: XOR<UserCreateWithoutCompletedCodeProjectInput, UserUncheckedCreateWithoutCompletedCodeProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedCodeProjectInput
    upsert?: UserUpsertWithoutCompletedCodeProjectInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutCompletedCodeProjectInput, UserUncheckedUpdateWithoutCompletedCodeProjectInput>
  }

  export type CodeProjectDocumentUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<CodeProjectDocumentUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: CodeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    set?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    update?: Enumerable<CodeProjectDocumentUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<CodeProjectDocumentUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<CodeProjectDocumentScalarWhereInput>
  }

  export type CodeProjectUserUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutCodeProjectInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<CodeProjectUserUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: CodeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
    set?: Enumerable<CodeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectUserWhereUniqueInput>
    delete?: Enumerable<CodeProjectUserWhereUniqueInput>
    update?: Enumerable<CodeProjectUserUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<CodeProjectUserUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<CodeProjectUserScalarWhereInput>
  }

  export type CodeReportUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutCodeProjectInput>, Enumerable<CodeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<CodeReportUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: CodeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
    set?: Enumerable<CodeReportWhereUniqueInput>
    disconnect?: Enumerable<CodeReportWhereUniqueInput>
    delete?: Enumerable<CodeReportWhereUniqueInput>
    update?: Enumerable<CodeReportUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<CodeReportUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<CodeReportScalarWhereInput>
  }

  export type ProjectUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCodeProjectInput>, Enumerable<ProjectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: ProjectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<CodeProjectDocumentUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: CodeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    set?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    update?: Enumerable<CodeProjectDocumentUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<CodeProjectDocumentUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<CodeProjectDocumentScalarWhereInput>
  }

  export type CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutCodeProjectInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<CodeProjectUserUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: CodeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
    set?: Enumerable<CodeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectUserWhereUniqueInput>
    delete?: Enumerable<CodeProjectUserWhereUniqueInput>
    update?: Enumerable<CodeProjectUserUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<CodeProjectUserUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<CodeProjectUserScalarWhereInput>
  }

  export type CodeReportUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutCodeProjectInput>, Enumerable<CodeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<CodeReportUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: CodeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
    set?: Enumerable<CodeReportWhereUniqueInput>
    disconnect?: Enumerable<CodeReportWhereUniqueInput>
    delete?: Enumerable<CodeReportWhereUniqueInput>
    update?: Enumerable<CodeReportUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<CodeReportUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<CodeReportScalarWhereInput>
  }

  export type ProjectUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<ProjectCreateWithoutCodeProjectInput>, Enumerable<ProjectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<ProjectCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<ProjectUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: ProjectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<ProjectWhereUniqueInput>
    set?: Enumerable<ProjectWhereUniqueInput>
    disconnect?: Enumerable<ProjectWhereUniqueInput>
    delete?: Enumerable<ProjectWhereUniqueInput>
    update?: Enumerable<ProjectUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<ProjectUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<ProjectScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCodeProjectDocumentInput = {
    create?: XOR<UserCreateWithoutCodeProjectDocumentInput, UserUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeProjectDocumentInput
    connect?: UserWhereUniqueInput
  }

  export type CodeProjectCreateNestedOneWithoutCodeProjectDocumentInput = {
    create?: XOR<CodeProjectCreateWithoutCodeProjectDocumentInput, CodeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutCodeProjectDocumentInput
    connect?: CodeProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCodeProjectDocumentInput = {
    create?: XOR<UserCreateWithoutCodeProjectDocumentInput, UserUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeProjectDocumentInput
    upsert?: UserUpsertWithoutCodeProjectDocumentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCodeProjectDocumentInput, UserUncheckedUpdateWithoutCodeProjectDocumentInput>
  }

  export type CodeProjectUpdateOneRequiredWithoutCodeProjectDocumentInput = {
    create?: XOR<CodeProjectCreateWithoutCodeProjectDocumentInput, CodeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutCodeProjectDocumentInput
    upsert?: CodeProjectUpsertWithoutCodeProjectDocumentInput
    connect?: CodeProjectWhereUniqueInput
    update?: XOR<CodeProjectUpdateWithoutCodeProjectDocumentInput, CodeProjectUncheckedUpdateWithoutCodeProjectDocumentInput>
  }

  export type UserCreateNestedOneWithoutCodeProjectUserInput = {
    create?: XOR<UserCreateWithoutCodeProjectUserInput, UserUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeProjectUserInput
    connect?: UserWhereUniqueInput
  }

  export type CodeProjectCreateNestedOneWithoutCodeProjectUserInput = {
    create?: XOR<CodeProjectCreateWithoutCodeProjectUserInput, CodeProjectUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutCodeProjectUserInput
    connect?: CodeProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCodeProjectUserInput = {
    create?: XOR<UserCreateWithoutCodeProjectUserInput, UserUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeProjectUserInput
    upsert?: UserUpsertWithoutCodeProjectUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCodeProjectUserInput, UserUncheckedUpdateWithoutCodeProjectUserInput>
  }

  export type CodeProjectUpdateOneRequiredWithoutCodeProjectUserInput = {
    create?: XOR<CodeProjectCreateWithoutCodeProjectUserInput, CodeProjectUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutCodeProjectUserInput
    upsert?: CodeProjectUpsertWithoutCodeProjectUserInput
    connect?: CodeProjectWhereUniqueInput
    update?: XOR<CodeProjectUpdateWithoutCodeProjectUserInput, CodeProjectUncheckedUpdateWithoutCodeProjectUserInput>
  }

  export type UserCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<UserCreateWithoutCodeReportInput, UserUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeReportInput
    connect?: UserWhereUniqueInput
  }

  export type CodeProjectCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<CodeProjectCreateWithoutCodeReportInput, CodeProjectUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutCodeReportInput
    connect?: CodeProjectWhereUniqueInput
  }

  export type CodeReportApprovalCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportInput>
    createMany?: CodeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
  }

  export type CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    createMany?: CodeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
  }

  export type DailyReportImageCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyReportImageCreateWithoutCodeReportInput>, Enumerable<DailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyReportImageCreateOrConnectWithoutCodeReportInput>
    createMany?: DailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyReportImageWhereUniqueInput>
  }

  export type DailyTaskCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyTaskCreateWithoutCodeReportInput>, Enumerable<DailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyTaskCreateOrConnectWithoutCodeReportInput>
    createMany?: DailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyTaskWhereUniqueInput>
  }

  export type StatusReportCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<StatusReportCreateWithoutCodeReportInput, StatusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: StatusReportCreateOrConnectWithoutCodeReportInput
    connect?: StatusReportWhereUniqueInput
  }

  export type ToolCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<ToolCreateWithoutCodeReportInput>, Enumerable<ToolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<ToolCreateOrConnectWithoutCodeReportInput>
    createMany?: ToolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<ToolWhereUniqueInput>
  }

  export type WeatherCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<WeatherCreateWithoutCodeReportInput, WeatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCodeReportInput
    connect?: WeatherWhereUniqueInput
  }

  export type MaterialCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<MaterialCreateWithoutCodeReportInput>, Enumerable<MaterialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<MaterialCreateOrConnectWithoutCodeReportInput>
    createMany?: MaterialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<MaterialWhereUniqueInput>
  }

  export type WorkerCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<WorkerCreateWithoutCodeReportInput>, Enumerable<WorkerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<WorkerCreateOrConnectWithoutCodeReportInput>
    createMany?: WorkerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<WorkerWhereUniqueInput>
  }

  export type RequestForInformationCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<RequestForInformationCreateWithoutCodeReportInput, RequestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutCodeReportInput
    connect?: RequestForInformationWhereUniqueInput
  }

  export type CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportInput>
    createMany?: CodeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
  }

  export type CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    createMany?: CodeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
  }

  export type DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyReportImageCreateWithoutCodeReportInput>, Enumerable<DailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyReportImageCreateOrConnectWithoutCodeReportInput>
    createMany?: DailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyReportImageWhereUniqueInput>
  }

  export type DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyTaskCreateWithoutCodeReportInput>, Enumerable<DailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyTaskCreateOrConnectWithoutCodeReportInput>
    createMany?: DailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyTaskWhereUniqueInput>
  }

  export type StatusReportUncheckedCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<StatusReportCreateWithoutCodeReportInput, StatusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: StatusReportCreateOrConnectWithoutCodeReportInput
    connect?: StatusReportWhereUniqueInput
  }

  export type ToolUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<ToolCreateWithoutCodeReportInput>, Enumerable<ToolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<ToolCreateOrConnectWithoutCodeReportInput>
    createMany?: ToolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<ToolWhereUniqueInput>
  }

  export type WeatherUncheckedCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<WeatherCreateWithoutCodeReportInput, WeatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCodeReportInput
    connect?: WeatherWhereUniqueInput
  }

  export type MaterialUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<MaterialCreateWithoutCodeReportInput>, Enumerable<MaterialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<MaterialCreateOrConnectWithoutCodeReportInput>
    createMany?: MaterialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<MaterialWhereUniqueInput>
  }

  export type WorkerUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<WorkerCreateWithoutCodeReportInput>, Enumerable<WorkerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<WorkerCreateOrConnectWithoutCodeReportInput>
    createMany?: WorkerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<WorkerWhereUniqueInput>
  }

  export type RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<RequestForInformationCreateWithoutCodeReportInput, RequestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutCodeReportInput
    connect?: RequestForInformationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCodeReportInput = {
    create?: XOR<UserCreateWithoutCodeReportInput, UserUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeReportInput
    upsert?: UserUpsertWithoutCodeReportInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCodeReportInput, UserUncheckedUpdateWithoutCodeReportInput>
  }

  export type CodeProjectUpdateOneRequiredWithoutCodeReportInput = {
    create?: XOR<CodeProjectCreateWithoutCodeReportInput, CodeProjectUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutCodeReportInput
    upsert?: CodeProjectUpsertWithoutCodeReportInput
    connect?: CodeProjectWhereUniqueInput
    update?: XOR<CodeProjectUpdateWithoutCodeReportInput, CodeProjectUncheckedUpdateWithoutCodeReportInput>
  }

  export type CodeReportApprovalUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<CodeReportApprovalUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: CodeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    set?: Enumerable<CodeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    delete?: Enumerable<CodeReportApprovalWhereUniqueInput>
    update?: Enumerable<CodeReportApprovalUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<CodeReportApprovalUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<CodeReportApprovalScalarWhereInput>
  }

  export type CodeReportApprovalUpdateManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    upsert?: Enumerable<CodeReportApprovalUpsertWithWhereUniqueWithoutCodeReportCommentInput>
    createMany?: CodeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    set?: Enumerable<CodeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    delete?: Enumerable<CodeReportApprovalWhereUniqueInput>
    update?: Enumerable<CodeReportApprovalUpdateWithWhereUniqueWithoutCodeReportCommentInput>
    updateMany?: Enumerable<CodeReportApprovalUpdateManyWithWhereWithoutCodeReportCommentInput>
    deleteMany?: Enumerable<CodeReportApprovalScalarWhereInput>
  }

  export type DailyReportImageUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyReportImageCreateWithoutCodeReportInput>, Enumerable<DailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyReportImageCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<DailyReportImageUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: DailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyReportImageWhereUniqueInput>
    set?: Enumerable<DailyReportImageWhereUniqueInput>
    disconnect?: Enumerable<DailyReportImageWhereUniqueInput>
    delete?: Enumerable<DailyReportImageWhereUniqueInput>
    update?: Enumerable<DailyReportImageUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<DailyReportImageUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<DailyReportImageScalarWhereInput>
  }

  export type DailyTaskUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyTaskCreateWithoutCodeReportInput>, Enumerable<DailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyTaskCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<DailyTaskUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: DailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyTaskWhereUniqueInput>
    set?: Enumerable<DailyTaskWhereUniqueInput>
    disconnect?: Enumerable<DailyTaskWhereUniqueInput>
    delete?: Enumerable<DailyTaskWhereUniqueInput>
    update?: Enumerable<DailyTaskUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<DailyTaskUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<DailyTaskScalarWhereInput>
  }

  export type StatusReportUpdateOneWithoutCodeReportInput = {
    create?: XOR<StatusReportCreateWithoutCodeReportInput, StatusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: StatusReportCreateOrConnectWithoutCodeReportInput
    upsert?: StatusReportUpsertWithoutCodeReportInput
    connect?: StatusReportWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<StatusReportUpdateWithoutCodeReportInput, StatusReportUncheckedUpdateWithoutCodeReportInput>
  }

  export type ToolUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<ToolCreateWithoutCodeReportInput>, Enumerable<ToolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<ToolCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<ToolUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: ToolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<ToolWhereUniqueInput>
    set?: Enumerable<ToolWhereUniqueInput>
    disconnect?: Enumerable<ToolWhereUniqueInput>
    delete?: Enumerable<ToolWhereUniqueInput>
    update?: Enumerable<ToolUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<ToolUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<ToolScalarWhereInput>
  }

  export type WeatherUpdateOneWithoutCodeReportInput = {
    create?: XOR<WeatherCreateWithoutCodeReportInput, WeatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCodeReportInput
    upsert?: WeatherUpsertWithoutCodeReportInput
    connect?: WeatherWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WeatherUpdateWithoutCodeReportInput, WeatherUncheckedUpdateWithoutCodeReportInput>
  }

  export type MaterialUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<MaterialCreateWithoutCodeReportInput>, Enumerable<MaterialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<MaterialCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<MaterialUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: MaterialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<MaterialWhereUniqueInput>
    set?: Enumerable<MaterialWhereUniqueInput>
    disconnect?: Enumerable<MaterialWhereUniqueInput>
    delete?: Enumerable<MaterialWhereUniqueInput>
    update?: Enumerable<MaterialUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<MaterialUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<MaterialScalarWhereInput>
  }

  export type WorkerUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<WorkerCreateWithoutCodeReportInput>, Enumerable<WorkerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<WorkerCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<WorkerUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: WorkerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<WorkerWhereUniqueInput>
    set?: Enumerable<WorkerWhereUniqueInput>
    disconnect?: Enumerable<WorkerWhereUniqueInput>
    delete?: Enumerable<WorkerWhereUniqueInput>
    update?: Enumerable<WorkerUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<WorkerUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<WorkerScalarWhereInput>
  }

  export type RequestForInformationUpdateOneWithoutCodeReportInput = {
    create?: XOR<RequestForInformationCreateWithoutCodeReportInput, RequestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutCodeReportInput
    upsert?: RequestForInformationUpsertWithoutCodeReportInput
    connect?: RequestForInformationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RequestForInformationUpdateWithoutCodeReportInput, RequestForInformationUncheckedUpdateWithoutCodeReportInput>
  }

  export type CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<CodeReportApprovalUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: CodeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    set?: Enumerable<CodeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    delete?: Enumerable<CodeReportApprovalWhereUniqueInput>
    update?: Enumerable<CodeReportApprovalUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<CodeReportApprovalUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<CodeReportApprovalScalarWhereInput>
  }

  export type CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    upsert?: Enumerable<CodeReportApprovalUpsertWithWhereUniqueWithoutCodeReportCommentInput>
    createMany?: CodeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    set?: Enumerable<CodeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    delete?: Enumerable<CodeReportApprovalWhereUniqueInput>
    update?: Enumerable<CodeReportApprovalUpdateWithWhereUniqueWithoutCodeReportCommentInput>
    updateMany?: Enumerable<CodeReportApprovalUpdateManyWithWhereWithoutCodeReportCommentInput>
    deleteMany?: Enumerable<CodeReportApprovalScalarWhereInput>
  }

  export type DailyReportImageUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyReportImageCreateWithoutCodeReportInput>, Enumerable<DailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyReportImageCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<DailyReportImageUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: DailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyReportImageWhereUniqueInput>
    set?: Enumerable<DailyReportImageWhereUniqueInput>
    disconnect?: Enumerable<DailyReportImageWhereUniqueInput>
    delete?: Enumerable<DailyReportImageWhereUniqueInput>
    update?: Enumerable<DailyReportImageUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<DailyReportImageUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<DailyReportImageScalarWhereInput>
  }

  export type DailyTaskUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<DailyTaskCreateWithoutCodeReportInput>, Enumerable<DailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<DailyTaskCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<DailyTaskUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: DailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<DailyTaskWhereUniqueInput>
    set?: Enumerable<DailyTaskWhereUniqueInput>
    disconnect?: Enumerable<DailyTaskWhereUniqueInput>
    delete?: Enumerable<DailyTaskWhereUniqueInput>
    update?: Enumerable<DailyTaskUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<DailyTaskUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<DailyTaskScalarWhereInput>
  }

  export type StatusReportUncheckedUpdateOneWithoutCodeReportInput = {
    create?: XOR<StatusReportCreateWithoutCodeReportInput, StatusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: StatusReportCreateOrConnectWithoutCodeReportInput
    upsert?: StatusReportUpsertWithoutCodeReportInput
    connect?: StatusReportWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<StatusReportUpdateWithoutCodeReportInput, StatusReportUncheckedUpdateWithoutCodeReportInput>
  }

  export type ToolUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<ToolCreateWithoutCodeReportInput>, Enumerable<ToolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<ToolCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<ToolUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: ToolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<ToolWhereUniqueInput>
    set?: Enumerable<ToolWhereUniqueInput>
    disconnect?: Enumerable<ToolWhereUniqueInput>
    delete?: Enumerable<ToolWhereUniqueInput>
    update?: Enumerable<ToolUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<ToolUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<ToolScalarWhereInput>
  }

  export type WeatherUncheckedUpdateOneWithoutCodeReportInput = {
    create?: XOR<WeatherCreateWithoutCodeReportInput, WeatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: WeatherCreateOrConnectWithoutCodeReportInput
    upsert?: WeatherUpsertWithoutCodeReportInput
    connect?: WeatherWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WeatherUpdateWithoutCodeReportInput, WeatherUncheckedUpdateWithoutCodeReportInput>
  }

  export type MaterialUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<MaterialCreateWithoutCodeReportInput>, Enumerable<MaterialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<MaterialCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<MaterialUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: MaterialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<MaterialWhereUniqueInput>
    set?: Enumerable<MaterialWhereUniqueInput>
    disconnect?: Enumerable<MaterialWhereUniqueInput>
    delete?: Enumerable<MaterialWhereUniqueInput>
    update?: Enumerable<MaterialUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<MaterialUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<MaterialScalarWhereInput>
  }

  export type WorkerUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<WorkerCreateWithoutCodeReportInput>, Enumerable<WorkerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<WorkerCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<WorkerUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: WorkerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<WorkerWhereUniqueInput>
    set?: Enumerable<WorkerWhereUniqueInput>
    disconnect?: Enumerable<WorkerWhereUniqueInput>
    delete?: Enumerable<WorkerWhereUniqueInput>
    update?: Enumerable<WorkerUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<WorkerUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<WorkerScalarWhereInput>
  }

  export type RequestForInformationUncheckedUpdateOneWithoutCodeReportInput = {
    create?: XOR<RequestForInformationCreateWithoutCodeReportInput, RequestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutCodeReportInput
    upsert?: RequestForInformationUpsertWithoutCodeReportInput
    connect?: RequestForInformationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RequestForInformationUpdateWithoutCodeReportInput, RequestForInformationUncheckedUpdateWithoutCodeReportInput>
  }

  export type CodeReportCreateNestedOneWithoutCodeReportApprovalInput = {
    create?: XOR<CodeReportCreateWithoutCodeReportApprovalInput, CodeReportUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutCodeReportApprovalInput
    connect?: CodeReportWhereUniqueInput
  }

  export type CodeReportCreateNestedOneWithoutCodeReportApprovalCommentInput = {
    create?: XOR<CodeReportCreateWithoutCodeReportApprovalCommentInput, CodeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutCodeReportApprovalCommentInput
    connect?: CodeReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCodeReportApprovalInput = {
    create?: XOR<UserCreateWithoutCodeReportApprovalInput, UserUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeReportApprovalInput
    connect?: UserWhereUniqueInput
  }

  export type CodeReportUpdateOneRequiredWithoutCodeReportApprovalInput = {
    create?: XOR<CodeReportCreateWithoutCodeReportApprovalInput, CodeReportUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutCodeReportApprovalInput
    upsert?: CodeReportUpsertWithoutCodeReportApprovalInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutCodeReportApprovalInput, CodeReportUncheckedUpdateWithoutCodeReportApprovalInput>
  }

  export type CodeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput = {
    create?: XOR<CodeReportCreateWithoutCodeReportApprovalCommentInput, CodeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutCodeReportApprovalCommentInput
    upsert?: CodeReportUpsertWithoutCodeReportApprovalCommentInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutCodeReportApprovalCommentInput, CodeReportUncheckedUpdateWithoutCodeReportApprovalCommentInput>
  }

  export type UserUpdateOneRequiredWithoutCodeReportApprovalInput = {
    create?: XOR<UserCreateWithoutCodeReportApprovalInput, UserUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeReportApprovalInput
    upsert?: UserUpsertWithoutCodeReportApprovalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCodeReportApprovalInput, UserUncheckedUpdateWithoutCodeReportApprovalInput>
  }

  export type CodeReportCreateNestedOneWithoutDailyReportImageInput = {
    create?: XOR<CodeReportCreateWithoutDailyReportImageInput, CodeReportUncheckedCreateWithoutDailyReportImageInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutDailyReportImageInput
    connect?: CodeReportWhereUniqueInput
  }

  export type CodeReportUpdateOneRequiredWithoutDailyReportImageInput = {
    create?: XOR<CodeReportCreateWithoutDailyReportImageInput, CodeReportUncheckedCreateWithoutDailyReportImageInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutDailyReportImageInput
    upsert?: CodeReportUpsertWithoutDailyReportImageInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutDailyReportImageInput, CodeReportUncheckedUpdateWithoutDailyReportImageInput>
  }

  export type CodeReportCreateNestedOneWithoutDailyTaskInput = {
    create?: XOR<CodeReportCreateWithoutDailyTaskInput, CodeReportUncheckedCreateWithoutDailyTaskInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutDailyTaskInput
    connect?: CodeReportWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CodeReportUpdateOneRequiredWithoutDailyTaskInput = {
    create?: XOR<CodeReportCreateWithoutDailyTaskInput, CodeReportUncheckedCreateWithoutDailyTaskInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutDailyTaskInput
    upsert?: CodeReportUpsertWithoutDailyTaskInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutDailyTaskInput, CodeReportUncheckedUpdateWithoutDailyTaskInput>
  }

  export type CodeReportCreateNestedOneWithoutMaterialInput = {
    create?: XOR<CodeReportCreateWithoutMaterialInput, CodeReportUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutMaterialInput
    connect?: CodeReportWhereUniqueInput
  }

  export type CodeReportUpdateOneRequiredWithoutMaterialInput = {
    create?: XOR<CodeReportCreateWithoutMaterialInput, CodeReportUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutMaterialInput
    upsert?: CodeReportUpsertWithoutMaterialInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutMaterialInput, CodeReportUncheckedUpdateWithoutMaterialInput>
  }

  export type CodeProjectCreateNestedOneWithoutProjectInput = {
    create?: XOR<CodeProjectCreateWithoutProjectInput, CodeProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutProjectInput
    connect?: CodeProjectWhereUniqueInput
  }

  export type CodeProjectUpdateOneRequiredWithoutProjectInput = {
    create?: XOR<CodeProjectCreateWithoutProjectInput, CodeProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: CodeProjectCreateOrConnectWithoutProjectInput
    upsert?: CodeProjectUpsertWithoutProjectInput
    connect?: CodeProjectWhereUniqueInput
    update?: XOR<CodeProjectUpdateWithoutProjectInput, CodeProjectUncheckedUpdateWithoutProjectInput>
  }

  export type UserCreateNestedOneWithoutProjectTaskInput = {
    create?: XOR<UserCreateWithoutProjectTaskInput, UserUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectTaskInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProjectTaskInput = {
    create?: XOR<UserCreateWithoutProjectTaskInput, UserUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectTaskInput
    upsert?: UserUpsertWithoutProjectTaskInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProjectTaskInput, UserUncheckedUpdateWithoutProjectTaskInput>
  }

  export type CodeReportCreateNestedOneWithoutRequestForInformationInput = {
    create?: XOR<CodeReportCreateWithoutRequestForInformationInput, CodeReportUncheckedCreateWithoutRequestForInformationInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutRequestForInformationInput
    connect?: CodeReportWhereUniqueInput
  }

  export type RequestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    createMany?: RequestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
  }

  export type RequestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    createMany?: RequestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
  }

  export type RequestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    createMany?: RequestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
  }

  export type RequestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    createMany?: RequestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
  }

  export type CodeReportUpdateOneRequiredWithoutRequestForInformationInput = {
    create?: XOR<CodeReportCreateWithoutRequestForInformationInput, CodeReportUncheckedCreateWithoutRequestForInformationInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutRequestForInformationInput
    upsert?: CodeReportUpsertWithoutRequestForInformationInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutRequestForInformationInput, CodeReportUncheckedUpdateWithoutRequestForInformationInput>
  }

  export type RequestForInformationAnswerUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<RequestForInformationAnswerUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: RequestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<RequestForInformationAnswerUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<RequestForInformationAnswerUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<RequestForInformationAnswerScalarWhereInput>
  }

  export type RequestForInformationDocumentUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<RequestForInformationDocumentUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: RequestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    set?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    disconnect?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    delete?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    update?: Enumerable<RequestForInformationDocumentUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<RequestForInformationDocumentUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<RequestForInformationDocumentScalarWhereInput>
  }

  export type RequestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<RequestForInformationAnswerUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: RequestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<RequestForInformationAnswerUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<RequestForInformationAnswerUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<RequestForInformationAnswerScalarWhereInput>
  }

  export type RequestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<RequestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<RequestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<RequestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<RequestForInformationDocumentUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: RequestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    set?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    disconnect?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    delete?: Enumerable<RequestForInformationDocumentWhereUniqueInput>
    update?: Enumerable<RequestForInformationDocumentUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<RequestForInformationDocumentUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<RequestForInformationDocumentScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRequestForInformationAnswerInput = {
    create?: XOR<UserCreateWithoutRequestForInformationAnswerInput, UserUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestForInformationAnswerInput
    connect?: UserWhereUniqueInput
  }

  export type RequestForInformationCreateNestedOneWithoutRequestForInformationAnswerInput = {
    create?: XOR<RequestForInformationCreateWithoutRequestForInformationAnswerInput, RequestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutRequestForInformationAnswerInput
    connect?: RequestForInformationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRequestForInformationAnswerInput = {
    create?: XOR<UserCreateWithoutRequestForInformationAnswerInput, UserUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestForInformationAnswerInput
    upsert?: UserUpsertWithoutRequestForInformationAnswerInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestForInformationAnswerInput, UserUncheckedUpdateWithoutRequestForInformationAnswerInput>
  }

  export type RequestForInformationUpdateOneRequiredWithoutRequestForInformationAnswerInput = {
    create?: XOR<RequestForInformationCreateWithoutRequestForInformationAnswerInput, RequestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutRequestForInformationAnswerInput
    upsert?: RequestForInformationUpsertWithoutRequestForInformationAnswerInput
    connect?: RequestForInformationWhereUniqueInput
    update?: XOR<RequestForInformationUpdateWithoutRequestForInformationAnswerInput, RequestForInformationUncheckedUpdateWithoutRequestForInformationAnswerInput>
  }

  export type RequestForInformationCreateNestedOneWithoutRequestForInformationDocumentInput = {
    create?: XOR<RequestForInformationCreateWithoutRequestForInformationDocumentInput, RequestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutRequestForInformationDocumentInput
    connect?: RequestForInformationWhereUniqueInput
  }

  export type RequestForInformationUpdateOneRequiredWithoutRequestForInformationDocumentInput = {
    create?: XOR<RequestForInformationCreateWithoutRequestForInformationDocumentInput, RequestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
    connectOrCreate?: RequestForInformationCreateOrConnectWithoutRequestForInformationDocumentInput
    upsert?: RequestForInformationUpsertWithoutRequestForInformationDocumentInput
    connect?: RequestForInformationWhereUniqueInput
    update?: XOR<RequestForInformationUpdateWithoutRequestForInformationDocumentInput, RequestForInformationUncheckedUpdateWithoutRequestForInformationDocumentInput>
  }

  export type CodeReportCreateNestedOneWithoutStatusReportInput = {
    create?: XOR<CodeReportCreateWithoutStatusReportInput, CodeReportUncheckedCreateWithoutStatusReportInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutStatusReportInput
    connect?: CodeReportWhereUniqueInput
  }

  export type StatusReportImageCreateNestedManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<StatusReportImageCreateWithoutStatusReportInput>, Enumerable<StatusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<StatusReportImageCreateOrConnectWithoutStatusReportInput>
    createMany?: StatusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<StatusReportImageWhereUniqueInput>
  }

  export type StatusReportImageUncheckedCreateNestedManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<StatusReportImageCreateWithoutStatusReportInput>, Enumerable<StatusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<StatusReportImageCreateOrConnectWithoutStatusReportInput>
    createMany?: StatusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<StatusReportImageWhereUniqueInput>
  }

  export type CodeReportUpdateOneRequiredWithoutStatusReportInput = {
    create?: XOR<CodeReportCreateWithoutStatusReportInput, CodeReportUncheckedCreateWithoutStatusReportInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutStatusReportInput
    upsert?: CodeReportUpsertWithoutStatusReportInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutStatusReportInput, CodeReportUncheckedUpdateWithoutStatusReportInput>
  }

  export type StatusReportImageUpdateManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<StatusReportImageCreateWithoutStatusReportInput>, Enumerable<StatusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<StatusReportImageCreateOrConnectWithoutStatusReportInput>
    upsert?: Enumerable<StatusReportImageUpsertWithWhereUniqueWithoutStatusReportInput>
    createMany?: StatusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<StatusReportImageWhereUniqueInput>
    set?: Enumerable<StatusReportImageWhereUniqueInput>
    disconnect?: Enumerable<StatusReportImageWhereUniqueInput>
    delete?: Enumerable<StatusReportImageWhereUniqueInput>
    update?: Enumerable<StatusReportImageUpdateWithWhereUniqueWithoutStatusReportInput>
    updateMany?: Enumerable<StatusReportImageUpdateManyWithWhereWithoutStatusReportInput>
    deleteMany?: Enumerable<StatusReportImageScalarWhereInput>
  }

  export type StatusReportImageUncheckedUpdateManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<StatusReportImageCreateWithoutStatusReportInput>, Enumerable<StatusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<StatusReportImageCreateOrConnectWithoutStatusReportInput>
    upsert?: Enumerable<StatusReportImageUpsertWithWhereUniqueWithoutStatusReportInput>
    createMany?: StatusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<StatusReportImageWhereUniqueInput>
    set?: Enumerable<StatusReportImageWhereUniqueInput>
    disconnect?: Enumerable<StatusReportImageWhereUniqueInput>
    delete?: Enumerable<StatusReportImageWhereUniqueInput>
    update?: Enumerable<StatusReportImageUpdateWithWhereUniqueWithoutStatusReportInput>
    updateMany?: Enumerable<StatusReportImageUpdateManyWithWhereWithoutStatusReportInput>
    deleteMany?: Enumerable<StatusReportImageScalarWhereInput>
  }

  export type StatusReportCreateNestedOneWithoutStatusReportImageInput = {
    create?: XOR<StatusReportCreateWithoutStatusReportImageInput, StatusReportUncheckedCreateWithoutStatusReportImageInput>
    connectOrCreate?: StatusReportCreateOrConnectWithoutStatusReportImageInput
    connect?: StatusReportWhereUniqueInput
  }

  export type StatusReportUpdateOneRequiredWithoutStatusReportImageInput = {
    create?: XOR<StatusReportCreateWithoutStatusReportImageInput, StatusReportUncheckedCreateWithoutStatusReportImageInput>
    connectOrCreate?: StatusReportCreateOrConnectWithoutStatusReportImageInput
    upsert?: StatusReportUpsertWithoutStatusReportImageInput
    connect?: StatusReportWhereUniqueInput
    update?: XOR<StatusReportUpdateWithoutStatusReportImageInput, StatusReportUncheckedUpdateWithoutStatusReportImageInput>
  }

  export type CodeReportCreateNestedOneWithoutToolInput = {
    create?: XOR<CodeReportCreateWithoutToolInput, CodeReportUncheckedCreateWithoutToolInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutToolInput
    connect?: CodeReportWhereUniqueInput
  }

  export type CodeReportUpdateOneRequiredWithoutToolInput = {
    create?: XOR<CodeReportCreateWithoutToolInput, CodeReportUncheckedCreateWithoutToolInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutToolInput
    upsert?: CodeReportUpsertWithoutToolInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutToolInput, CodeReportUncheckedUpdateWithoutToolInput>
  }

  export type CodeReportCreateNestedOneWithoutWeatherInput = {
    create?: XOR<CodeReportCreateWithoutWeatherInput, CodeReportUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutWeatherInput
    connect?: CodeReportWhereUniqueInput
  }

  export type CodeReportUpdateOneRequiredWithoutWeatherInput = {
    create?: XOR<CodeReportCreateWithoutWeatherInput, CodeReportUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutWeatherInput
    upsert?: CodeReportUpsertWithoutWeatherInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutWeatherInput, CodeReportUncheckedUpdateWithoutWeatherInput>
  }

  export type CodeReportCreateNestedOneWithoutWorkerInput = {
    create?: XOR<CodeReportCreateWithoutWorkerInput, CodeReportUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutWorkerInput
    connect?: CodeReportWhereUniqueInput
  }

  export type CodeReportUpdateOneRequiredWithoutWorkerInput = {
    create?: XOR<CodeReportCreateWithoutWorkerInput, CodeReportUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: CodeReportCreateOrConnectWithoutWorkerInput
    upsert?: CodeReportUpsertWithoutWorkerInput
    connect?: CodeReportWhereUniqueInput
    update?: XOR<CodeReportUpdateWithoutWorkerInput, CodeReportUncheckedUpdateWithoutWorkerInput>
  }

  export type UserCreateNestedOneWithoutUserContactInput = {
    create?: XOR<UserCreateWithoutUserContactInput, UserUncheckedCreateWithoutUserContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserContactInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserContactInput = {
    create?: XOR<UserCreateWithoutUserContactInput, UserUncheckedCreateWithoutUserContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserContactInput
    upsert?: UserUpsertWithoutUserContactInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserContactInput, UserUncheckedUpdateWithoutUserContactInput>
  }

  export type UserCreateNestedOneWithoutCreateUserPositionInput = {
    create?: XOR<UserCreateWithoutCreateUserPositionInput, UserUncheckedCreateWithoutCreateUserPositionInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreateUserPositionInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserPositionInput = {
    create?: XOR<UserCreateWithoutUserPositionInput, UserUncheckedCreateWithoutUserPositionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPositionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreateUserPositionInput = {
    create?: XOR<UserCreateWithoutCreateUserPositionInput, UserUncheckedCreateWithoutCreateUserPositionInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreateUserPositionInput
    upsert?: UserUpsertWithoutCreateUserPositionInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreateUserPositionInput, UserUncheckedUpdateWithoutCreateUserPositionInput>
  }

  export type UserUpdateOneRequiredWithoutUserPositionInput = {
    create?: XOR<UserCreateWithoutUserPositionInput, UserUncheckedCreateWithoutUserPositionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPositionInput
    upsert?: UserUpsertWithoutUserPositionInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserPositionInput, UserUncheckedUpdateWithoutUserPositionInput>
  }

  export type ClientCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type ClientContactCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutUserInput>, Enumerable<ClientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutUserInput>
    createMany?: ClientContactCreateManyUserInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
  }

  export type CodeProjectDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutUserInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutUserInput>
    createMany?: CodeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
  }

  export type CodeProjectCreateNestedManyWithoutUser1Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser1Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser1Input>
    createMany?: CodeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type CodeProjectCreateNestedManyWithoutUser2Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser2Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser2Input>
    createMany?: CodeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type CodeProjectCreateNestedManyWithoutUser3Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser3Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser3Input>
    createMany?: CodeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type CodeProjectUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutUserInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutUserInput>
    createMany?: CodeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
  }

  export type CodeReportCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutUserInput>, Enumerable<CodeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutUserInput>
    createMany?: CodeReportCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
  }

  export type CodeReportApprovalCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutUserInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutUserInput>
    createMany?: CodeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
  }

  export type ProjectTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProjectTaskCreateWithoutUserInput>, Enumerable<ProjectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectTaskCreateOrConnectWithoutUserInput>
    createMany?: ProjectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<ProjectTaskWhereUniqueInput>
  }

  export type RequestForInformationAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutUserInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutUserInput>
    createMany?: RequestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
  }

  export type UserPositionCreateNestedManyWithoutUser4Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser4Input>, Enumerable<UserPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser4Input>
    createMany?: UserPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
  }

  export type UserPositionCreateNestedManyWithoutUser5Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser5Input>, Enumerable<UserPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser5Input>
    createMany?: UserPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
  }

  export type UserContactCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactWhereUniqueInput>
  }

  export type ClientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type ClientContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutUserInput>, Enumerable<ClientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutUserInput>
    createMany?: ClientContactCreateManyUserInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
  }

  export type CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutUserInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutUserInput>
    createMany?: CodeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
  }

  export type CodeProjectUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser1Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser1Input>
    createMany?: CodeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type CodeProjectUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser2Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser2Input>
    createMany?: CodeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type CodeProjectUncheckedCreateNestedManyWithoutUser3Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser3Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser3Input>
    createMany?: CodeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
  }

  export type CodeProjectUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutUserInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutUserInput>
    createMany?: CodeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
  }

  export type CodeReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutUserInput>, Enumerable<CodeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutUserInput>
    createMany?: CodeReportCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
  }

  export type CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutUserInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutUserInput>
    createMany?: CodeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
  }

  export type ProjectTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProjectTaskCreateWithoutUserInput>, Enumerable<ProjectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectTaskCreateOrConnectWithoutUserInput>
    createMany?: ProjectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<ProjectTaskWhereUniqueInput>
  }

  export type RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutUserInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutUserInput>
    createMany?: RequestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
  }

  export type UserPositionUncheckedCreateNestedManyWithoutUser4Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser4Input>, Enumerable<UserPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser4Input>
    createMany?: UserPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
  }

  export type UserPositionUncheckedCreateNestedManyWithoutUser5Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser5Input>, Enumerable<UserPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser5Input>
    createMany?: UserPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
  }

  export type UserContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactWhereUniqueInput>
  }

  export type ClientUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type ClientContactUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutUserInput>, Enumerable<ClientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ClientContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ClientContactCreateManyUserInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
    set?: Enumerable<ClientContactWhereUniqueInput>
    disconnect?: Enumerable<ClientContactWhereUniqueInput>
    delete?: Enumerable<ClientContactWhereUniqueInput>
    update?: Enumerable<ClientContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ClientContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ClientContactScalarWhereInput>
  }

  export type CodeProjectDocumentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutUserInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeProjectDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    set?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    update?: Enumerable<CodeProjectDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeProjectDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeProjectDocumentScalarWhereInput>
  }

  export type CodeProjectUpdateManyWithoutUser1Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser1Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser1Input>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutUser1Input>
    createMany?: CodeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutUser1Input>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutUser1Input>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type CodeProjectUpdateManyWithoutUser2Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser2Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser2Input>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutUser2Input>
    createMany?: CodeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutUser2Input>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutUser2Input>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type CodeProjectUpdateManyWithoutUser3Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser3Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser3Input>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutUser3Input>
    createMany?: CodeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutUser3Input>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutUser3Input>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type CodeProjectUserUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutUserInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeProjectUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
    set?: Enumerable<CodeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectUserWhereUniqueInput>
    delete?: Enumerable<CodeProjectUserWhereUniqueInput>
    update?: Enumerable<CodeProjectUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeProjectUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeProjectUserScalarWhereInput>
  }

  export type CodeReportUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutUserInput>, Enumerable<CodeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeReportCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
    set?: Enumerable<CodeReportWhereUniqueInput>
    disconnect?: Enumerable<CodeReportWhereUniqueInput>
    delete?: Enumerable<CodeReportWhereUniqueInput>
    update?: Enumerable<CodeReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeReportScalarWhereInput>
  }

  export type CodeReportApprovalUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutUserInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeReportApprovalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    set?: Enumerable<CodeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    delete?: Enumerable<CodeReportApprovalWhereUniqueInput>
    update?: Enumerable<CodeReportApprovalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeReportApprovalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeReportApprovalScalarWhereInput>
  }

  export type ProjectTaskUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ProjectTaskCreateWithoutUserInput>, Enumerable<ProjectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectTaskCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProjectTaskUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProjectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<ProjectTaskWhereUniqueInput>
    set?: Enumerable<ProjectTaskWhereUniqueInput>
    disconnect?: Enumerable<ProjectTaskWhereUniqueInput>
    delete?: Enumerable<ProjectTaskWhereUniqueInput>
    update?: Enumerable<ProjectTaskUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProjectTaskUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProjectTaskScalarWhereInput>
  }

  export type RequestForInformationAnswerUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutUserInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestForInformationAnswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<RequestForInformationAnswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestForInformationAnswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestForInformationAnswerScalarWhereInput>
  }

  export type UserPositionUpdateManyWithoutUser4Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser4Input>, Enumerable<UserPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser4Input>
    upsert?: Enumerable<UserPositionUpsertWithWhereUniqueWithoutUser4Input>
    createMany?: UserPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
    set?: Enumerable<UserPositionWhereUniqueInput>
    disconnect?: Enumerable<UserPositionWhereUniqueInput>
    delete?: Enumerable<UserPositionWhereUniqueInput>
    update?: Enumerable<UserPositionUpdateWithWhereUniqueWithoutUser4Input>
    updateMany?: Enumerable<UserPositionUpdateManyWithWhereWithoutUser4Input>
    deleteMany?: Enumerable<UserPositionScalarWhereInput>
  }

  export type UserPositionUpdateManyWithoutUser5Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser5Input>, Enumerable<UserPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser5Input>
    upsert?: Enumerable<UserPositionUpsertWithWhereUniqueWithoutUser5Input>
    createMany?: UserPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
    set?: Enumerable<UserPositionWhereUniqueInput>
    disconnect?: Enumerable<UserPositionWhereUniqueInput>
    delete?: Enumerable<UserPositionWhereUniqueInput>
    update?: Enumerable<UserPositionUpdateWithWhereUniqueWithoutUser5Input>
    updateMany?: Enumerable<UserPositionUpdateManyWithWhereWithoutUser5Input>
    deleteMany?: Enumerable<UserPositionScalarWhereInput>
  }

  export type UserContactUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactWhereUniqueInput>
    set?: Enumerable<UserContactWhereUniqueInput>
    disconnect?: Enumerable<UserContactWhereUniqueInput>
    delete?: Enumerable<UserContactWhereUniqueInput>
    update?: Enumerable<UserContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserContactScalarWhereInput>
  }

  export type ClientUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientCreateWithoutUserInput>, Enumerable<ClientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type ClientContactUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ClientContactCreateWithoutUserInput>, Enumerable<ClientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ClientContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ClientContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ClientContactCreateManyUserInputEnvelope
    connect?: Enumerable<ClientContactWhereUniqueInput>
    set?: Enumerable<ClientContactWhereUniqueInput>
    disconnect?: Enumerable<ClientContactWhereUniqueInput>
    delete?: Enumerable<ClientContactWhereUniqueInput>
    update?: Enumerable<ClientContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ClientContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ClientContactScalarWhereInput>
  }

  export type CodeProjectDocumentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectDocumentCreateWithoutUserInput>, Enumerable<CodeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeProjectDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    set?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<CodeProjectDocumentWhereUniqueInput>
    update?: Enumerable<CodeProjectDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeProjectDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeProjectDocumentScalarWhereInput>
  }

  export type CodeProjectUncheckedUpdateManyWithoutUser1Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser1Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser1Input>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutUser1Input>
    createMany?: CodeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutUser1Input>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutUser1Input>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type CodeProjectUncheckedUpdateManyWithoutUser2Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser2Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser2Input>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutUser2Input>
    createMany?: CodeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutUser2Input>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutUser2Input>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type CodeProjectUncheckedUpdateManyWithoutUser3Input = {
    create?: XOR<Enumerable<CodeProjectCreateWithoutUser3Input>, Enumerable<CodeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<CodeProjectCreateOrConnectWithoutUser3Input>
    upsert?: Enumerable<CodeProjectUpsertWithWhereUniqueWithoutUser3Input>
    createMany?: CodeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<CodeProjectWhereUniqueInput>
    set?: Enumerable<CodeProjectWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectWhereUniqueInput>
    delete?: Enumerable<CodeProjectWhereUniqueInput>
    update?: Enumerable<CodeProjectUpdateWithWhereUniqueWithoutUser3Input>
    updateMany?: Enumerable<CodeProjectUpdateManyWithWhereWithoutUser3Input>
    deleteMany?: Enumerable<CodeProjectScalarWhereInput>
  }

  export type CodeProjectUserUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeProjectUserCreateWithoutUserInput>, Enumerable<CodeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeProjectUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeProjectUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<CodeProjectUserWhereUniqueInput>
    set?: Enumerable<CodeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<CodeProjectUserWhereUniqueInput>
    delete?: Enumerable<CodeProjectUserWhereUniqueInput>
    update?: Enumerable<CodeProjectUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeProjectUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeProjectUserScalarWhereInput>
  }

  export type CodeReportUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportCreateWithoutUserInput>, Enumerable<CodeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeReportCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportWhereUniqueInput>
    set?: Enumerable<CodeReportWhereUniqueInput>
    disconnect?: Enumerable<CodeReportWhereUniqueInput>
    delete?: Enumerable<CodeReportWhereUniqueInput>
    update?: Enumerable<CodeReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeReportScalarWhereInput>
  }

  export type CodeReportApprovalUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeReportApprovalCreateWithoutUserInput>, Enumerable<CodeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeReportApprovalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeReportApprovalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    set?: Enumerable<CodeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<CodeReportApprovalWhereUniqueInput>
    delete?: Enumerable<CodeReportApprovalWhereUniqueInput>
    update?: Enumerable<CodeReportApprovalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeReportApprovalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeReportApprovalScalarWhereInput>
  }

  export type ProjectTaskUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ProjectTaskCreateWithoutUserInput>, Enumerable<ProjectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectTaskCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProjectTaskUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProjectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<ProjectTaskWhereUniqueInput>
    set?: Enumerable<ProjectTaskWhereUniqueInput>
    disconnect?: Enumerable<ProjectTaskWhereUniqueInput>
    delete?: Enumerable<ProjectTaskWhereUniqueInput>
    update?: Enumerable<ProjectTaskUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProjectTaskUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProjectTaskScalarWhereInput>
  }

  export type RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestForInformationAnswerCreateWithoutUserInput>, Enumerable<RequestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestForInformationAnswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestForInformationAnswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<RequestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<RequestForInformationAnswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestForInformationAnswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestForInformationAnswerScalarWhereInput>
  }

  export type UserPositionUncheckedUpdateManyWithoutUser4Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser4Input>, Enumerable<UserPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser4Input>
    upsert?: Enumerable<UserPositionUpsertWithWhereUniqueWithoutUser4Input>
    createMany?: UserPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
    set?: Enumerable<UserPositionWhereUniqueInput>
    disconnect?: Enumerable<UserPositionWhereUniqueInput>
    delete?: Enumerable<UserPositionWhereUniqueInput>
    update?: Enumerable<UserPositionUpdateWithWhereUniqueWithoutUser4Input>
    updateMany?: Enumerable<UserPositionUpdateManyWithWhereWithoutUser4Input>
    deleteMany?: Enumerable<UserPositionScalarWhereInput>
  }

  export type UserPositionUncheckedUpdateManyWithoutUser5Input = {
    create?: XOR<Enumerable<UserPositionCreateWithoutUser5Input>, Enumerable<UserPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<UserPositionCreateOrConnectWithoutUser5Input>
    upsert?: Enumerable<UserPositionUpsertWithWhereUniqueWithoutUser5Input>
    createMany?: UserPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<UserPositionWhereUniqueInput>
    set?: Enumerable<UserPositionWhereUniqueInput>
    disconnect?: Enumerable<UserPositionWhereUniqueInput>
    delete?: Enumerable<UserPositionWhereUniqueInput>
    update?: Enumerable<UserPositionUpdateWithWhereUniqueWithoutUser5Input>
    updateMany?: Enumerable<UserPositionUpdateManyWithWhereWithoutUser5Input>
    deleteMany?: Enumerable<UserPositionScalarWhereInput>
  }

  export type UserContactUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactWhereUniqueInput>
    set?: Enumerable<UserContactWhereUniqueInput>
    disconnect?: Enumerable<UserContactWhereUniqueInput>
    delete?: Enumerable<UserContactWhereUniqueInput>
    update?: Enumerable<UserContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserContactScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type UserCreateWithoutClientInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type ClientContactCreateWithoutClientInput = {
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    User: UserCreateNestedOneWithoutClientContactInput
  }

  export type ClientContactUncheckedCreateWithoutClientInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type ClientContactCreateOrConnectWithoutClientInput = {
    where: ClientContactWhereUniqueInput
    create: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
  }

  export type ClientContactCreateManyClientInputEnvelope = {
    data: Enumerable<ClientContactCreateManyClientInput>
    skipDuplicates?: boolean
  }

  export type CodeProjectCreateWithoutClientInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutClientInput = {
    Id?: number
    Name: string
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutClientInput = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutClientInput, CodeProjectUncheckedCreateWithoutClientInput>
  }

  export type CodeProjectCreateManyClientInputEnvelope = {
    data: Enumerable<CodeProjectCreateManyClientInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type ClientContactUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientContactWhereUniqueInput
    update: XOR<ClientContactUpdateWithoutClientInput, ClientContactUncheckedUpdateWithoutClientInput>
    create: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
  }

  export type ClientContactUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientContactWhereUniqueInput
    data: XOR<ClientContactUpdateWithoutClientInput, ClientContactUncheckedUpdateWithoutClientInput>
  }

  export type ClientContactUpdateManyWithWhereWithoutClientInput = {
    where: ClientContactScalarWhereInput
    data: XOR<ClientContactUpdateManyMutationInput, ClientContactUncheckedUpdateManyWithoutContactInput>
  }

  export type ClientContactScalarWhereInput = {
    AND?: Enumerable<ClientContactScalarWhereInput>
    OR?: Enumerable<ClientContactScalarWhereInput>
    NOT?: Enumerable<ClientContactScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Position?: StringFilter | string
    PhoneNumber?: StringFilter | string
    Email?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    ClientId?: IntFilter | number
  }

  export type CodeProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: CodeProjectWhereUniqueInput
    update: XOR<CodeProjectUpdateWithoutClientInput, CodeProjectUncheckedUpdateWithoutClientInput>
    create: XOR<CodeProjectCreateWithoutClientInput, CodeProjectUncheckedCreateWithoutClientInput>
  }

  export type CodeProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: CodeProjectWhereUniqueInput
    data: XOR<CodeProjectUpdateWithoutClientInput, CodeProjectUncheckedUpdateWithoutClientInput>
  }

  export type CodeProjectUpdateManyWithWhereWithoutClientInput = {
    where: CodeProjectScalarWhereInput
    data: XOR<CodeProjectUpdateManyMutationInput, CodeProjectUncheckedUpdateManyWithoutCodeProjectInput>
  }

  export type CodeProjectScalarWhereInput = {
    AND?: Enumerable<CodeProjectScalarWhereInput>
    OR?: Enumerable<CodeProjectScalarWhereInput>
    NOT?: Enumerable<CodeProjectScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    ClientId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    ConfirmedDate?: DateTimeNullableFilter | Date | string | null
    ConfirmedBy?: IntNullableFilter | number | null
    Address?: StringFilter | string
    DocumentName?: StringFilter | string
    IsCompleted?: BoolFilter | boolean
    CompletedDate?: DateTimeNullableFilter | Date | string | null
    CompletedBy?: IntNullableFilter | number | null
    IsDelete?: BoolFilter | boolean
  }

  export type ClientCreateWithoutContactInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    User: UserCreateNestedOneWithoutClientInput
    CodeProject?: CodeProjectCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutContactInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
    CodeProject?: CodeProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutContactInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutContactInput, ClientUncheckedCreateWithoutContactInput>
  }

  export type UserCreateWithoutClientContactInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientContactInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientContactInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientContactInput, UserUncheckedCreateWithoutClientContactInput>
  }

  export type ClientUpsertWithoutContactInput = {
    update: XOR<ClientUpdateWithoutContactInput, ClientUncheckedUpdateWithoutContactInput>
    create: XOR<ClientCreateWithoutContactInput, ClientUncheckedCreateWithoutContactInput>
  }

  export type ClientUpdateWithoutContactInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutClientInput
    CodeProject?: CodeProjectUpdateManyWithoutClientInput
  }

  export type ClientUncheckedUpdateWithoutContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProject?: CodeProjectUncheckedUpdateManyWithoutClientInput
  }

  export type UserUpsertWithoutClientContactInput = {
    update: XOR<UserUpdateWithoutClientContactInput, UserUncheckedUpdateWithoutClientContactInput>
    create: XOR<UserCreateWithoutClientContactInput, UserUncheckedCreateWithoutClientContactInput>
  }

  export type UserUpdateWithoutClientContactInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutClientContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type ClientCreateWithoutCodeProjectInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    User: UserCreateNestedOneWithoutClientInput
    Contact?: ClientContactCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
    Contact?: ClientContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCodeProjectInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCodeProjectInput, ClientUncheckedCreateWithoutCodeProjectInput>
  }

  export type UserCreateWithoutCreateCodeProjectInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreateCodeProjectInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreateCodeProjectInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreateCodeProjectInput, UserUncheckedCreateWithoutCreateCodeProjectInput>
  }

  export type UserCreateWithoutConfirmedCodeProjectInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConfirmedCodeProjectInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConfirmedCodeProjectInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConfirmedCodeProjectInput, UserUncheckedCreateWithoutConfirmedCodeProjectInput>
  }

  export type UserCreateWithoutCompletedCodeProjectInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompletedCodeProjectInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompletedCodeProjectInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompletedCodeProjectInput, UserUncheckedCreateWithoutCompletedCodeProjectInput>
  }

  export type CodeProjectDocumentCreateWithoutCodeProjectInput = {
    Name: string
    Url: string
    CreatedDate?: Date | string
    User: UserCreateNestedOneWithoutCodeProjectDocumentInput
  }

  export type CodeProjectDocumentUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    Name: string
    Url: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type CodeProjectDocumentCreateOrConnectWithoutCodeProjectInput = {
    where: CodeProjectDocumentWhereUniqueInput
    create: XOR<CodeProjectDocumentCreateWithoutCodeProjectInput, CodeProjectDocumentUncheckedCreateWithoutCodeProjectInput>
  }

  export type CodeProjectDocumentCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<CodeProjectDocumentCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type CodeProjectUserCreateWithoutCodeProjectInput = {
    User: UserCreateNestedOneWithoutCodeProjectUserInput
  }

  export type CodeProjectUserUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    UserId: number
  }

  export type CodeProjectUserCreateOrConnectWithoutCodeProjectInput = {
    where: CodeProjectUserWhereUniqueInput
    create: XOR<CodeProjectUserCreateWithoutCodeProjectInput, CodeProjectUserUncheckedCreateWithoutCodeProjectInput>
  }

  export type CodeProjectUserCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<CodeProjectUserCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type CodeReportCreateWithoutCodeProjectInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutCodeProjectInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutCodeProjectInput, CodeReportUncheckedCreateWithoutCodeProjectInput>
  }

  export type CodeReportCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<CodeReportCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCodeProjectInput = {
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type ProjectUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type ProjectCreateOrConnectWithoutCodeProjectInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCodeProjectInput, ProjectUncheckedCreateWithoutCodeProjectInput>
  }

  export type ProjectCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<ProjectCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutCodeProjectInput = {
    update: XOR<ClientUpdateWithoutCodeProjectInput, ClientUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<ClientCreateWithoutCodeProjectInput, ClientUncheckedCreateWithoutCodeProjectInput>
  }

  export type ClientUpdateWithoutCodeProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutClientInput
    Contact?: ClientContactUpdateManyWithoutClientInput
  }

  export type ClientUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ClientContactUncheckedUpdateManyWithoutClientInput
  }

  export type UserUpsertWithoutCreateCodeProjectInput = {
    update: XOR<UserUpdateWithoutCreateCodeProjectInput, UserUncheckedUpdateWithoutCreateCodeProjectInput>
    create: XOR<UserCreateWithoutCreateCodeProjectInput, UserUncheckedCreateWithoutCreateCodeProjectInput>
  }

  export type UserUpdateWithoutCreateCodeProjectInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCreateCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutConfirmedCodeProjectInput = {
    update: XOR<UserUpdateWithoutConfirmedCodeProjectInput, UserUncheckedUpdateWithoutConfirmedCodeProjectInput>
    create: XOR<UserCreateWithoutConfirmedCodeProjectInput, UserUncheckedCreateWithoutConfirmedCodeProjectInput>
  }

  export type UserUpdateWithoutConfirmedCodeProjectInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutConfirmedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutCompletedCodeProjectInput = {
    update: XOR<UserUpdateWithoutCompletedCodeProjectInput, UserUncheckedUpdateWithoutCompletedCodeProjectInput>
    create: XOR<UserCreateWithoutCompletedCodeProjectInput, UserUncheckedCreateWithoutCompletedCodeProjectInput>
  }

  export type UserUpdateWithoutCompletedCodeProjectInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCompletedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type CodeProjectDocumentUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: CodeProjectDocumentWhereUniqueInput
    update: XOR<CodeProjectDocumentUpdateWithoutCodeProjectInput, CodeProjectDocumentUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<CodeProjectDocumentCreateWithoutCodeProjectInput, CodeProjectDocumentUncheckedCreateWithoutCodeProjectInput>
  }

  export type CodeProjectDocumentUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: CodeProjectDocumentWhereUniqueInput
    data: XOR<CodeProjectDocumentUpdateWithoutCodeProjectInput, CodeProjectDocumentUncheckedUpdateWithoutCodeProjectInput>
  }

  export type CodeProjectDocumentUpdateManyWithWhereWithoutCodeProjectInput = {
    where: CodeProjectDocumentScalarWhereInput
    data: XOR<CodeProjectDocumentUpdateManyMutationInput, CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectDocumentInput>
  }

  export type CodeProjectDocumentScalarWhereInput = {
    AND?: Enumerable<CodeProjectDocumentScalarWhereInput>
    OR?: Enumerable<CodeProjectDocumentScalarWhereInput>
    NOT?: Enumerable<CodeProjectDocumentScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Url?: StringFilter | string
    CodeProjectId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
  }

  export type CodeProjectUserUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: CodeProjectUserWhereUniqueInput
    update: XOR<CodeProjectUserUpdateWithoutCodeProjectInput, CodeProjectUserUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<CodeProjectUserCreateWithoutCodeProjectInput, CodeProjectUserUncheckedCreateWithoutCodeProjectInput>
  }

  export type CodeProjectUserUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: CodeProjectUserWhereUniqueInput
    data: XOR<CodeProjectUserUpdateWithoutCodeProjectInput, CodeProjectUserUncheckedUpdateWithoutCodeProjectInput>
  }

  export type CodeProjectUserUpdateManyWithWhereWithoutCodeProjectInput = {
    where: CodeProjectUserScalarWhereInput
    data: XOR<CodeProjectUserUpdateManyMutationInput, CodeProjectUserUncheckedUpdateManyWithoutCodeProjectUserInput>
  }

  export type CodeProjectUserScalarWhereInput = {
    AND?: Enumerable<CodeProjectUserScalarWhereInput>
    OR?: Enumerable<CodeProjectUserScalarWhereInput>
    NOT?: Enumerable<CodeProjectUserScalarWhereInput>
    Id?: IntFilter | number
    UserId?: IntFilter | number
    CodeProjectId?: IntFilter | number
  }

  export type CodeReportUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: CodeReportWhereUniqueInput
    update: XOR<CodeReportUpdateWithoutCodeProjectInput, CodeReportUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<CodeReportCreateWithoutCodeProjectInput, CodeReportUncheckedCreateWithoutCodeProjectInput>
  }

  export type CodeReportUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: CodeReportWhereUniqueInput
    data: XOR<CodeReportUpdateWithoutCodeProjectInput, CodeReportUncheckedUpdateWithoutCodeProjectInput>
  }

  export type CodeReportUpdateManyWithWhereWithoutCodeProjectInput = {
    where: CodeReportScalarWhereInput
    data: XOR<CodeReportUpdateManyMutationInput, CodeReportUncheckedUpdateManyWithoutCodeReportInput>
  }

  export type CodeReportScalarWhereInput = {
    AND?: Enumerable<CodeReportScalarWhereInput>
    OR?: Enumerable<CodeReportScalarWhereInput>
    NOT?: Enumerable<CodeReportScalarWhereInput>
    Id?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Date?: DateTimeFilter | Date | string
    CodeProjectId?: IntFilter | number
    Type?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    Note?: StringFilter | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCodeProjectInput, ProjectUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<ProjectCreateWithoutCodeProjectInput, ProjectUncheckedCreateWithoutCodeProjectInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCodeProjectInput, ProjectUncheckedUpdateWithoutCodeProjectInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCodeProjectInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: Enumerable<ProjectScalarWhereInput>
    OR?: Enumerable<ProjectScalarWhereInput>
    NOT?: Enumerable<ProjectScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    BudgetPrice?: FloatFilter | number
    Quantity?: FloatFilter | number
    Done?: FloatFilter | number
    IsDelete?: BoolFilter | boolean
    CodeProjectId?: IntFilter | number
    ParentId?: IntFilter | number
    EstimatedDuration?: FloatFilter | number
    Timeline?: IntFilter | number
    Price?: FloatFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
  }

  export type UserCreateWithoutCodeProjectDocumentInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCodeProjectDocumentInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCodeProjectDocumentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodeProjectDocumentInput, UserUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type CodeProjectCreateWithoutCodeProjectDocumentInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutCodeProjectDocumentInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutCodeProjectDocumentInput = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutCodeProjectDocumentInput, CodeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type UserUpsertWithoutCodeProjectDocumentInput = {
    update: XOR<UserUpdateWithoutCodeProjectDocumentInput, UserUncheckedUpdateWithoutCodeProjectDocumentInput>
    create: XOR<UserCreateWithoutCodeProjectDocumentInput, UserUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type UserUpdateWithoutCodeProjectDocumentInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCodeProjectDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type CodeProjectUpsertWithoutCodeProjectDocumentInput = {
    update: XOR<CodeProjectUpdateWithoutCodeProjectDocumentInput, CodeProjectUncheckedUpdateWithoutCodeProjectDocumentInput>
    create: XOR<CodeProjectCreateWithoutCodeProjectDocumentInput, CodeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type CodeProjectUpdateWithoutCodeProjectDocumentInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutCodeProjectDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type UserCreateWithoutCodeProjectUserInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCodeProjectUserInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCodeProjectUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodeProjectUserInput, UserUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type CodeProjectCreateWithoutCodeProjectUserInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutCodeProjectUserInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutCodeProjectUserInput = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutCodeProjectUserInput, CodeProjectUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type UserUpsertWithoutCodeProjectUserInput = {
    update: XOR<UserUpdateWithoutCodeProjectUserInput, UserUncheckedUpdateWithoutCodeProjectUserInput>
    create: XOR<UserCreateWithoutCodeProjectUserInput, UserUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type UserUpdateWithoutCodeProjectUserInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCodeProjectUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type CodeProjectUpsertWithoutCodeProjectUserInput = {
    update: XOR<CodeProjectUpdateWithoutCodeProjectUserInput, CodeProjectUncheckedUpdateWithoutCodeProjectUserInput>
    create: XOR<CodeProjectCreateWithoutCodeProjectUserInput, CodeProjectUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type CodeProjectUpdateWithoutCodeProjectUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutCodeProjectUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type UserCreateWithoutCodeReportInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCodeReportInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodeReportInput, UserUncheckedCreateWithoutCodeReportInput>
  }

  export type CodeProjectCreateWithoutCodeReportInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutCodeReportInput = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutCodeReportInput, CodeProjectUncheckedCreateWithoutCodeReportInput>
  }

  export type CodeReportApprovalCreateWithoutCodeReportInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReportComment: CodeReportCreateNestedOneWithoutCodeReportApprovalCommentInput
    User: UserCreateNestedOneWithoutCodeReportApprovalInput
  }

  export type CodeReportApprovalUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type CodeReportApprovalCreateOrConnectWithoutCodeReportInput = {
    where: CodeReportApprovalWhereUniqueInput
    create: XOR<CodeReportApprovalCreateWithoutCodeReportInput, CodeReportApprovalUncheckedCreateWithoutCodeReportInput>
  }

  export type CodeReportApprovalCreateManyCodeReportInputEnvelope = {
    data: Enumerable<CodeReportApprovalCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type CodeReportApprovalCreateWithoutCodeReportCommentInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReport: CodeReportCreateNestedOneWithoutCodeReportApprovalInput
    User: UserCreateNestedOneWithoutCodeReportApprovalInput
  }

  export type CodeReportApprovalUncheckedCreateWithoutCodeReportCommentInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type CodeReportApprovalCreateOrConnectWithoutCodeReportCommentInput = {
    where: CodeReportApprovalWhereUniqueInput
    create: XOR<CodeReportApprovalCreateWithoutCodeReportCommentInput, CodeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>
  }

  export type CodeReportApprovalCreateManyCodeReportCommentInputEnvelope = {
    data: Enumerable<CodeReportApprovalCreateManyCodeReportCommentInput>
    skipDuplicates?: boolean
  }

  export type DailyReportImageCreateWithoutCodeReportInput = {
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type DailyReportImageUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type DailyReportImageCreateOrConnectWithoutCodeReportInput = {
    where: DailyReportImageWhereUniqueInput
    create: XOR<DailyReportImageCreateWithoutCodeReportInput, DailyReportImageUncheckedCreateWithoutCodeReportInput>
  }

  export type DailyReportImageCreateManyCodeReportInputEnvelope = {
    data: Enumerable<DailyReportImageCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type DailyTaskCreateWithoutCodeReportInput = {
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
  }

  export type DailyTaskUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
  }

  export type DailyTaskCreateOrConnectWithoutCodeReportInput = {
    where: DailyTaskWhereUniqueInput
    create: XOR<DailyTaskCreateWithoutCodeReportInput, DailyTaskUncheckedCreateWithoutCodeReportInput>
  }

  export type DailyTaskCreateManyCodeReportInputEnvelope = {
    data: Enumerable<DailyTaskCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type StatusReportCreateWithoutCodeReportInput = {
    Status: string
    StatusReportImage?: StatusReportImageCreateNestedManyWithoutStatusReportInput
  }

  export type StatusReportUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Status: string
    StatusReportImage?: StatusReportImageUncheckedCreateNestedManyWithoutStatusReportInput
  }

  export type StatusReportCreateOrConnectWithoutCodeReportInput = {
    where: StatusReportWhereUniqueInput
    create: XOR<StatusReportCreateWithoutCodeReportInput, StatusReportUncheckedCreateWithoutCodeReportInput>
  }

  export type ToolCreateWithoutCodeReportInput = {
    Name: string
    Description: string
    Quantity: number
  }

  export type ToolUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
  }

  export type ToolCreateOrConnectWithoutCodeReportInput = {
    where: ToolWhereUniqueInput
    create: XOR<ToolCreateWithoutCodeReportInput, ToolUncheckedCreateWithoutCodeReportInput>
  }

  export type ToolCreateManyCodeReportInputEnvelope = {
    data: Enumerable<ToolCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type WeatherCreateWithoutCodeReportInput = {
    WeatherId: number
  }

  export type WeatherUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    WeatherId: number
  }

  export type WeatherCreateOrConnectWithoutCodeReportInput = {
    where: WeatherWhereUniqueInput
    create: XOR<WeatherCreateWithoutCodeReportInput, WeatherUncheckedCreateWithoutCodeReportInput>
  }

  export type MaterialCreateWithoutCodeReportInput = {
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
  }

  export type MaterialUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
  }

  export type MaterialCreateOrConnectWithoutCodeReportInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCodeReportInput, MaterialUncheckedCreateWithoutCodeReportInput>
  }

  export type MaterialCreateManyCodeReportInputEnvelope = {
    data: Enumerable<MaterialCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type WorkerCreateWithoutCodeReportInput = {
    Name: string
    Quantity: number
  }

  export type WorkerUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
  }

  export type WorkerCreateOrConnectWithoutCodeReportInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutCodeReportInput, WorkerUncheckedCreateWithoutCodeReportInput>
  }

  export type WorkerCreateManyCodeReportInputEnvelope = {
    data: Enumerable<WorkerCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type RequestForInformationCreateWithoutCodeReportInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationCreateOrConnectWithoutCodeReportInput = {
    where: RequestForInformationWhereUniqueInput
    create: XOR<RequestForInformationCreateWithoutCodeReportInput, RequestForInformationUncheckedCreateWithoutCodeReportInput>
  }

  export type UserUpsertWithoutCodeReportInput = {
    update: XOR<UserUpdateWithoutCodeReportInput, UserUncheckedUpdateWithoutCodeReportInput>
    create: XOR<UserCreateWithoutCodeReportInput, UserUncheckedCreateWithoutCodeReportInput>
  }

  export type UserUpdateWithoutCodeReportInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type CodeProjectUpsertWithoutCodeReportInput = {
    update: XOR<CodeProjectUpdateWithoutCodeReportInput, CodeProjectUncheckedUpdateWithoutCodeReportInput>
    create: XOR<CodeProjectCreateWithoutCodeReportInput, CodeProjectUncheckedCreateWithoutCodeReportInput>
  }

  export type CodeProjectUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type CodeReportApprovalUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: CodeReportApprovalWhereUniqueInput
    update: XOR<CodeReportApprovalUpdateWithoutCodeReportInput, CodeReportApprovalUncheckedUpdateWithoutCodeReportInput>
    create: XOR<CodeReportApprovalCreateWithoutCodeReportInput, CodeReportApprovalUncheckedCreateWithoutCodeReportInput>
  }

  export type CodeReportApprovalUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: CodeReportApprovalWhereUniqueInput
    data: XOR<CodeReportApprovalUpdateWithoutCodeReportInput, CodeReportApprovalUncheckedUpdateWithoutCodeReportInput>
  }

  export type CodeReportApprovalUpdateManyWithWhereWithoutCodeReportInput = {
    where: CodeReportApprovalScalarWhereInput
    data: XOR<CodeReportApprovalUpdateManyMutationInput, CodeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalInput>
  }

  export type CodeReportApprovalScalarWhereInput = {
    AND?: Enumerable<CodeReportApprovalScalarWhereInput>
    OR?: Enumerable<CodeReportApprovalScalarWhereInput>
    NOT?: Enumerable<CodeReportApprovalScalarWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Comment?: StringFilter | string
    Approval?: IntFilter | number
    IsDelete?: BoolFilter | boolean
  }

  export type CodeReportApprovalUpsertWithWhereUniqueWithoutCodeReportCommentInput = {
    where: CodeReportApprovalWhereUniqueInput
    update: XOR<CodeReportApprovalUpdateWithoutCodeReportCommentInput, CodeReportApprovalUncheckedUpdateWithoutCodeReportCommentInput>
    create: XOR<CodeReportApprovalCreateWithoutCodeReportCommentInput, CodeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>
  }

  export type CodeReportApprovalUpdateWithWhereUniqueWithoutCodeReportCommentInput = {
    where: CodeReportApprovalWhereUniqueInput
    data: XOR<CodeReportApprovalUpdateWithoutCodeReportCommentInput, CodeReportApprovalUncheckedUpdateWithoutCodeReportCommentInput>
  }

  export type CodeReportApprovalUpdateManyWithWhereWithoutCodeReportCommentInput = {
    where: CodeReportApprovalScalarWhereInput
    data: XOR<CodeReportApprovalUpdateManyMutationInput, CodeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalCommentInput>
  }

  export type DailyReportImageUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: DailyReportImageWhereUniqueInput
    update: XOR<DailyReportImageUpdateWithoutCodeReportInput, DailyReportImageUncheckedUpdateWithoutCodeReportInput>
    create: XOR<DailyReportImageCreateWithoutCodeReportInput, DailyReportImageUncheckedCreateWithoutCodeReportInput>
  }

  export type DailyReportImageUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: DailyReportImageWhereUniqueInput
    data: XOR<DailyReportImageUpdateWithoutCodeReportInput, DailyReportImageUncheckedUpdateWithoutCodeReportInput>
  }

  export type DailyReportImageUpdateManyWithWhereWithoutCodeReportInput = {
    where: DailyReportImageScalarWhereInput
    data: XOR<DailyReportImageUpdateManyMutationInput, DailyReportImageUncheckedUpdateManyWithoutDailyReportImageInput>
  }

  export type DailyReportImageScalarWhereInput = {
    AND?: Enumerable<DailyReportImageScalarWhereInput>
    OR?: Enumerable<DailyReportImageScalarWhereInput>
    NOT?: Enumerable<DailyReportImageScalarWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    Caption?: StringFilter | string
  }

  export type DailyTaskUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: DailyTaskWhereUniqueInput
    update: XOR<DailyTaskUpdateWithoutCodeReportInput, DailyTaskUncheckedUpdateWithoutCodeReportInput>
    create: XOR<DailyTaskCreateWithoutCodeReportInput, DailyTaskUncheckedCreateWithoutCodeReportInput>
  }

  export type DailyTaskUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: DailyTaskWhereUniqueInput
    data: XOR<DailyTaskUpdateWithoutCodeReportInput, DailyTaskUncheckedUpdateWithoutCodeReportInput>
  }

  export type DailyTaskUpdateManyWithWhereWithoutCodeReportInput = {
    where: DailyTaskScalarWhereInput
    data: XOR<DailyTaskUpdateManyMutationInput, DailyTaskUncheckedUpdateManyWithoutDailyTaskInput>
  }

  export type DailyTaskScalarWhereInput = {
    AND?: Enumerable<DailyTaskScalarWhereInput>
    OR?: Enumerable<DailyTaskScalarWhereInput>
    NOT?: Enumerable<DailyTaskScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Unit?: StringFilter | string
    Quantity?: FloatFilter | number
    ParentId?: IntFilter | number
    CodeReportId?: IntFilter | number
    Note?: StringFilter | string
  }

  export type StatusReportUpsertWithoutCodeReportInput = {
    update: XOR<StatusReportUpdateWithoutCodeReportInput, StatusReportUncheckedUpdateWithoutCodeReportInput>
    create: XOR<StatusReportCreateWithoutCodeReportInput, StatusReportUncheckedCreateWithoutCodeReportInput>
  }

  export type StatusReportUpdateWithoutCodeReportInput = {
    Status?: StringFieldUpdateOperationsInput | string
    StatusReportImage?: StatusReportImageUpdateManyWithoutStatusReportInput
  }

  export type StatusReportUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    StatusReportImage?: StatusReportImageUncheckedUpdateManyWithoutStatusReportInput
  }

  export type ToolUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: ToolWhereUniqueInput
    update: XOR<ToolUpdateWithoutCodeReportInput, ToolUncheckedUpdateWithoutCodeReportInput>
    create: XOR<ToolCreateWithoutCodeReportInput, ToolUncheckedCreateWithoutCodeReportInput>
  }

  export type ToolUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: ToolWhereUniqueInput
    data: XOR<ToolUpdateWithoutCodeReportInput, ToolUncheckedUpdateWithoutCodeReportInput>
  }

  export type ToolUpdateManyWithWhereWithoutCodeReportInput = {
    where: ToolScalarWhereInput
    data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyWithoutToolInput>
  }

  export type ToolScalarWhereInput = {
    AND?: Enumerable<ToolScalarWhereInput>
    OR?: Enumerable<ToolScalarWhereInput>
    NOT?: Enumerable<ToolScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Quantity?: IntFilter | number
    CodeReportId?: IntFilter | number
  }

  export type WeatherUpsertWithoutCodeReportInput = {
    update: XOR<WeatherUpdateWithoutCodeReportInput, WeatherUncheckedUpdateWithoutCodeReportInput>
    create: XOR<WeatherCreateWithoutCodeReportInput, WeatherUncheckedCreateWithoutCodeReportInput>
  }

  export type WeatherUpdateWithoutCodeReportInput = {
    WeatherId?: IntFieldUpdateOperationsInput | number
  }

  export type WeatherUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    WeatherId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutCodeReportInput, MaterialUncheckedUpdateWithoutCodeReportInput>
    create: XOR<MaterialCreateWithoutCodeReportInput, MaterialUncheckedCreateWithoutCodeReportInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutCodeReportInput, MaterialUncheckedUpdateWithoutCodeReportInput>
  }

  export type MaterialUpdateManyWithWhereWithoutCodeReportInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutMaterialInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: Enumerable<MaterialScalarWhereInput>
    OR?: Enumerable<MaterialScalarWhereInput>
    NOT?: Enumerable<MaterialScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Quantity?: FloatFilter | number
    Status?: IntFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
    CodeReportId?: IntFilter | number
  }

  export type WorkerUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutCodeReportInput, WorkerUncheckedUpdateWithoutCodeReportInput>
    create: XOR<WorkerCreateWithoutCodeReportInput, WorkerUncheckedCreateWithoutCodeReportInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutCodeReportInput, WorkerUncheckedUpdateWithoutCodeReportInput>
  }

  export type WorkerUpdateManyWithWhereWithoutCodeReportInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutWorkerInput>
  }

  export type WorkerScalarWhereInput = {
    AND?: Enumerable<WorkerScalarWhereInput>
    OR?: Enumerable<WorkerScalarWhereInput>
    NOT?: Enumerable<WorkerScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    CodeReportId?: IntFilter | number
    Quantity?: IntFilter | number
  }

  export type RequestForInformationUpsertWithoutCodeReportInput = {
    update: XOR<RequestForInformationUpdateWithoutCodeReportInput, RequestForInformationUncheckedUpdateWithoutCodeReportInput>
    create: XOR<RequestForInformationCreateWithoutCodeReportInput, RequestForInformationUncheckedCreateWithoutCodeReportInput>
  }

  export type RequestForInformationUpdateWithoutCodeReportInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentUpdateManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type CodeReportCreateWithoutCodeReportApprovalInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutCodeReportApprovalInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutCodeReportApprovalInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutCodeReportApprovalInput, CodeReportUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type CodeReportCreateWithoutCodeReportApprovalCommentInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutCodeReportApprovalCommentInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutCodeReportApprovalCommentInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutCodeReportApprovalCommentInput, CodeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
  }

  export type UserCreateWithoutCodeReportApprovalInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCodeReportApprovalInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCodeReportApprovalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodeReportApprovalInput, UserUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type CodeReportUpsertWithoutCodeReportApprovalInput = {
    update: XOR<CodeReportUpdateWithoutCodeReportApprovalInput, CodeReportUncheckedUpdateWithoutCodeReportApprovalInput>
    create: XOR<CodeReportCreateWithoutCodeReportApprovalInput, CodeReportUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type CodeReportUpdateWithoutCodeReportApprovalInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutCodeReportApprovalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUpsertWithoutCodeReportApprovalCommentInput = {
    update: XOR<CodeReportUpdateWithoutCodeReportApprovalCommentInput, CodeReportUncheckedUpdateWithoutCodeReportApprovalCommentInput>
    create: XOR<CodeReportCreateWithoutCodeReportApprovalCommentInput, CodeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
  }

  export type CodeReportUpdateWithoutCodeReportApprovalCommentInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutCodeReportApprovalCommentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type UserUpsertWithoutCodeReportApprovalInput = {
    update: XOR<UserUpdateWithoutCodeReportApprovalInput, UserUncheckedUpdateWithoutCodeReportApprovalInput>
    create: XOR<UserCreateWithoutCodeReportApprovalInput, UserUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type UserUpdateWithoutCodeReportApprovalInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCodeReportApprovalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type CodeReportCreateWithoutDailyReportImageInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutDailyReportImageInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutDailyReportImageInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutDailyReportImageInput, CodeReportUncheckedCreateWithoutDailyReportImageInput>
  }

  export type CodeReportUpsertWithoutDailyReportImageInput = {
    update: XOR<CodeReportUpdateWithoutDailyReportImageInput, CodeReportUncheckedUpdateWithoutDailyReportImageInput>
    create: XOR<CodeReportCreateWithoutDailyReportImageInput, CodeReportUncheckedCreateWithoutDailyReportImageInput>
  }

  export type CodeReportUpdateWithoutDailyReportImageInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutDailyReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportCreateWithoutDailyTaskInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutDailyTaskInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutDailyTaskInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutDailyTaskInput, CodeReportUncheckedCreateWithoutDailyTaskInput>
  }

  export type CodeReportUpsertWithoutDailyTaskInput = {
    update: XOR<CodeReportUpdateWithoutDailyTaskInput, CodeReportUncheckedUpdateWithoutDailyTaskInput>
    create: XOR<CodeReportCreateWithoutDailyTaskInput, CodeReportUncheckedCreateWithoutDailyTaskInput>
  }

  export type CodeReportUpdateWithoutDailyTaskInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutDailyTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportCreateWithoutMaterialInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutMaterialInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutMaterialInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutMaterialInput, CodeReportUncheckedCreateWithoutMaterialInput>
  }

  export type CodeReportUpsertWithoutMaterialInput = {
    update: XOR<CodeReportUpdateWithoutMaterialInput, CodeReportUncheckedUpdateWithoutMaterialInput>
    create: XOR<CodeReportCreateWithoutMaterialInput, CodeReportUncheckedCreateWithoutMaterialInput>
  }

  export type CodeReportUpdateWithoutMaterialInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutMaterialInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeProjectCreateWithoutProjectInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutProjectInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutProjectInput = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutProjectInput, CodeProjectUncheckedCreateWithoutProjectInput>
  }

  export type CodeProjectUpsertWithoutProjectInput = {
    update: XOR<CodeProjectUpdateWithoutProjectInput, CodeProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<CodeProjectCreateWithoutProjectInput, CodeProjectUncheckedCreateWithoutProjectInput>
  }

  export type CodeProjectUpdateWithoutProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type UserCreateWithoutProjectTaskInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectTaskInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectTaskInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectTaskInput, UserUncheckedCreateWithoutProjectTaskInput>
  }

  export type UserUpsertWithoutProjectTaskInput = {
    update: XOR<UserUpdateWithoutProjectTaskInput, UserUncheckedUpdateWithoutProjectTaskInput>
    create: XOR<UserCreateWithoutProjectTaskInput, UserUncheckedCreateWithoutProjectTaskInput>
  }

  export type UserUpdateWithoutProjectTaskInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutProjectTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type CodeReportCreateWithoutRequestForInformationInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutRequestForInformationInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutRequestForInformationInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutRequestForInformationInput, CodeReportUncheckedCreateWithoutRequestForInformationInput>
  }

  export type RequestForInformationAnswerCreateWithoutRequestForInformationInput = {
    Answer: string
    CreatedDate: Date | string
    IsDelete?: boolean
    User: UserCreateNestedOneWithoutRequestForInformationAnswerInput
  }

  export type RequestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    IsDelete?: boolean
  }

  export type RequestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput = {
    where: RequestForInformationAnswerWhereUniqueInput
    create: XOR<RequestForInformationAnswerCreateWithoutRequestForInformationInput, RequestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>
  }

  export type RequestForInformationAnswerCreateManyRequestForInformationInputEnvelope = {
    data: Enumerable<RequestForInformationAnswerCreateManyRequestForInformationInput>
    skipDuplicates?: boolean
  }

  export type RequestForInformationDocumentCreateWithoutRequestForInformationInput = {
    ImageUrl: string
    Name: string
  }

  export type RequestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type RequestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput = {
    where: RequestForInformationDocumentWhereUniqueInput
    create: XOR<RequestForInformationDocumentCreateWithoutRequestForInformationInput, RequestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>
  }

  export type RequestForInformationDocumentCreateManyRequestForInformationInputEnvelope = {
    data: Enumerable<RequestForInformationDocumentCreateManyRequestForInformationInput>
    skipDuplicates?: boolean
  }

  export type CodeReportUpsertWithoutRequestForInformationInput = {
    update: XOR<CodeReportUpdateWithoutRequestForInformationInput, CodeReportUncheckedUpdateWithoutRequestForInformationInput>
    create: XOR<CodeReportCreateWithoutRequestForInformationInput, CodeReportUncheckedCreateWithoutRequestForInformationInput>
  }

  export type CodeReportUpdateWithoutRequestForInformationInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutRequestForInformationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
  }

  export type RequestForInformationAnswerUpsertWithWhereUniqueWithoutRequestForInformationInput = {
    where: RequestForInformationAnswerWhereUniqueInput
    update: XOR<RequestForInformationAnswerUpdateWithoutRequestForInformationInput, RequestForInformationAnswerUncheckedUpdateWithoutRequestForInformationInput>
    create: XOR<RequestForInformationAnswerCreateWithoutRequestForInformationInput, RequestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>
  }

  export type RequestForInformationAnswerUpdateWithWhereUniqueWithoutRequestForInformationInput = {
    where: RequestForInformationAnswerWhereUniqueInput
    data: XOR<RequestForInformationAnswerUpdateWithoutRequestForInformationInput, RequestForInformationAnswerUncheckedUpdateWithoutRequestForInformationInput>
  }

  export type RequestForInformationAnswerUpdateManyWithWhereWithoutRequestForInformationInput = {
    where: RequestForInformationAnswerScalarWhereInput
    data: XOR<RequestForInformationAnswerUpdateManyMutationInput, RequestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationAnswerInput>
  }

  export type RequestForInformationAnswerScalarWhereInput = {
    AND?: Enumerable<RequestForInformationAnswerScalarWhereInput>
    OR?: Enumerable<RequestForInformationAnswerScalarWhereInput>
    NOT?: Enumerable<RequestForInformationAnswerScalarWhereInput>
    Id?: IntFilter | number
    Answer?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    RequestForInformationId?: IntFilter | number
    IsDelete?: BoolFilter | boolean
  }

  export type RequestForInformationDocumentUpsertWithWhereUniqueWithoutRequestForInformationInput = {
    where: RequestForInformationDocumentWhereUniqueInput
    update: XOR<RequestForInformationDocumentUpdateWithoutRequestForInformationInput, RequestForInformationDocumentUncheckedUpdateWithoutRequestForInformationInput>
    create: XOR<RequestForInformationDocumentCreateWithoutRequestForInformationInput, RequestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>
  }

  export type RequestForInformationDocumentUpdateWithWhereUniqueWithoutRequestForInformationInput = {
    where: RequestForInformationDocumentWhereUniqueInput
    data: XOR<RequestForInformationDocumentUpdateWithoutRequestForInformationInput, RequestForInformationDocumentUncheckedUpdateWithoutRequestForInformationInput>
  }

  export type RequestForInformationDocumentUpdateManyWithWhereWithoutRequestForInformationInput = {
    where: RequestForInformationDocumentScalarWhereInput
    data: XOR<RequestForInformationDocumentUpdateManyMutationInput, RequestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationDocumentInput>
  }

  export type RequestForInformationDocumentScalarWhereInput = {
    AND?: Enumerable<RequestForInformationDocumentScalarWhereInput>
    OR?: Enumerable<RequestForInformationDocumentScalarWhereInput>
    NOT?: Enumerable<RequestForInformationDocumentScalarWhereInput>
    Id?: IntFilter | number
    RequestForInformationId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
  }

  export type UserCreateWithoutRequestForInformationAnswerInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRequestForInformationAnswerInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRequestForInformationAnswerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestForInformationAnswerInput, UserUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type RequestForInformationCreateWithoutRequestForInformationAnswerInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    CodeReport: CodeReportCreateNestedOneWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationDocument?: RequestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationCreateOrConnectWithoutRequestForInformationAnswerInput = {
    where: RequestForInformationWhereUniqueInput
    create: XOR<RequestForInformationCreateWithoutRequestForInformationAnswerInput, RequestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type UserUpsertWithoutRequestForInformationAnswerInput = {
    update: XOR<UserUpdateWithoutRequestForInformationAnswerInput, UserUncheckedUpdateWithoutRequestForInformationAnswerInput>
    create: XOR<UserCreateWithoutRequestForInformationAnswerInput, UserUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type UserUpdateWithoutRequestForInformationAnswerInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutRequestForInformationAnswerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type RequestForInformationUpsertWithoutRequestForInformationAnswerInput = {
    update: XOR<RequestForInformationUpdateWithoutRequestForInformationAnswerInput, RequestForInformationUncheckedUpdateWithoutRequestForInformationAnswerInput>
    create: XOR<RequestForInformationCreateWithoutRequestForInformationAnswerInput, RequestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type RequestForInformationUpdateWithoutRequestForInformationAnswerInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: CodeReportUpdateOneRequiredWithoutRequestForInformationInput
    RequestForInformationDocument?: RequestForInformationDocumentUpdateManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedUpdateWithoutRequestForInformationAnswerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationDocument?: RequestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type RequestForInformationCreateWithoutRequestForInformationDocumentInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    CodeReport: CodeReportCreateNestedOneWithoutRequestForInformationInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type RequestForInformationCreateOrConnectWithoutRequestForInformationDocumentInput = {
    where: RequestForInformationWhereUniqueInput
    create: XOR<RequestForInformationCreateWithoutRequestForInformationDocumentInput, RequestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
  }

  export type RequestForInformationUpsertWithoutRequestForInformationDocumentInput = {
    update: XOR<RequestForInformationUpdateWithoutRequestForInformationDocumentInput, RequestForInformationUncheckedUpdateWithoutRequestForInformationDocumentInput>
    create: XOR<RequestForInformationCreateWithoutRequestForInformationDocumentInput, RequestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
  }

  export type RequestForInformationUpdateWithoutRequestForInformationDocumentInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: CodeReportUpdateOneRequiredWithoutRequestForInformationInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutRequestForInformationInput
  }

  export type RequestForInformationUncheckedUpdateWithoutRequestForInformationDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type CodeReportCreateWithoutStatusReportInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutStatusReportInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutStatusReportInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutStatusReportInput, CodeReportUncheckedCreateWithoutStatusReportInput>
  }

  export type StatusReportImageCreateWithoutStatusReportInput = {
    ImageUrl: string
    Name: string
  }

  export type StatusReportImageUncheckedCreateWithoutStatusReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type StatusReportImageCreateOrConnectWithoutStatusReportInput = {
    where: StatusReportImageWhereUniqueInput
    create: XOR<StatusReportImageCreateWithoutStatusReportInput, StatusReportImageUncheckedCreateWithoutStatusReportInput>
  }

  export type StatusReportImageCreateManyStatusReportInputEnvelope = {
    data: Enumerable<StatusReportImageCreateManyStatusReportInput>
    skipDuplicates?: boolean
  }

  export type CodeReportUpsertWithoutStatusReportInput = {
    update: XOR<CodeReportUpdateWithoutStatusReportInput, CodeReportUncheckedUpdateWithoutStatusReportInput>
    create: XOR<CodeReportCreateWithoutStatusReportInput, CodeReportUncheckedCreateWithoutStatusReportInput>
  }

  export type CodeReportUpdateWithoutStatusReportInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutStatusReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type StatusReportImageUpsertWithWhereUniqueWithoutStatusReportInput = {
    where: StatusReportImageWhereUniqueInput
    update: XOR<StatusReportImageUpdateWithoutStatusReportInput, StatusReportImageUncheckedUpdateWithoutStatusReportInput>
    create: XOR<StatusReportImageCreateWithoutStatusReportInput, StatusReportImageUncheckedCreateWithoutStatusReportInput>
  }

  export type StatusReportImageUpdateWithWhereUniqueWithoutStatusReportInput = {
    where: StatusReportImageWhereUniqueInput
    data: XOR<StatusReportImageUpdateWithoutStatusReportInput, StatusReportImageUncheckedUpdateWithoutStatusReportInput>
  }

  export type StatusReportImageUpdateManyWithWhereWithoutStatusReportInput = {
    where: StatusReportImageScalarWhereInput
    data: XOR<StatusReportImageUpdateManyMutationInput, StatusReportImageUncheckedUpdateManyWithoutStatusReportImageInput>
  }

  export type StatusReportImageScalarWhereInput = {
    AND?: Enumerable<StatusReportImageScalarWhereInput>
    OR?: Enumerable<StatusReportImageScalarWhereInput>
    NOT?: Enumerable<StatusReportImageScalarWhereInput>
    Id?: IntFilter | number
    StatusReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
  }

  export type StatusReportCreateWithoutStatusReportImageInput = {
    Status: string
    CodeReport: CodeReportCreateNestedOneWithoutStatusReportInput
  }

  export type StatusReportUncheckedCreateWithoutStatusReportImageInput = {
    Id?: number
    Status: string
    CodeReportId: number
  }

  export type StatusReportCreateOrConnectWithoutStatusReportImageInput = {
    where: StatusReportWhereUniqueInput
    create: XOR<StatusReportCreateWithoutStatusReportImageInput, StatusReportUncheckedCreateWithoutStatusReportImageInput>
  }

  export type StatusReportUpsertWithoutStatusReportImageInput = {
    update: XOR<StatusReportUpdateWithoutStatusReportImageInput, StatusReportUncheckedUpdateWithoutStatusReportImageInput>
    create: XOR<StatusReportCreateWithoutStatusReportImageInput, StatusReportUncheckedCreateWithoutStatusReportImageInput>
  }

  export type StatusReportUpdateWithoutStatusReportImageInput = {
    Status?: StringFieldUpdateOperationsInput | string
    CodeReport?: CodeReportUpdateOneRequiredWithoutStatusReportInput
  }

  export type StatusReportUncheckedUpdateWithoutStatusReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeReportCreateWithoutToolInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutToolInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutToolInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutToolInput, CodeReportUncheckedCreateWithoutToolInput>
  }

  export type CodeReportUpsertWithoutToolInput = {
    update: XOR<CodeReportUpdateWithoutToolInput, CodeReportUncheckedUpdateWithoutToolInput>
    create: XOR<CodeReportCreateWithoutToolInput, CodeReportUncheckedCreateWithoutToolInput>
  }

  export type CodeReportUpdateWithoutToolInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutToolInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportCreateWithoutWeatherInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutWeatherInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutWeatherInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutWeatherInput, CodeReportUncheckedCreateWithoutWeatherInput>
  }

  export type CodeReportUpsertWithoutWeatherInput = {
    update: XOR<CodeReportUpdateWithoutWeatherInput, CodeReportUncheckedUpdateWithoutWeatherInput>
    create: XOR<CodeReportCreateWithoutWeatherInput, CodeReportUncheckedCreateWithoutWeatherInput>
  }

  export type CodeReportUpdateWithoutWeatherInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutWeatherInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportCreateWithoutWorkerInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: UserCreateNestedOneWithoutCodeReportInput
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutWorkerInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutWorkerInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutWorkerInput, CodeReportUncheckedCreateWithoutWorkerInput>
  }

  export type CodeReportUpsertWithoutWorkerInput = {
    update: XOR<CodeReportUpdateWithoutWorkerInput, CodeReportUncheckedUpdateWithoutWorkerInput>
    create: XOR<CodeReportCreateWithoutWorkerInput, CodeReportUncheckedCreateWithoutWorkerInput>
  }

  export type CodeReportUpdateWithoutWorkerInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutWorkerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type UserCreateWithoutUserContactInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
  }

  export type UserUncheckedCreateWithoutUserContactInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
  }

  export type UserCreateOrConnectWithoutUserContactInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserContactInput, UserUncheckedCreateWithoutUserContactInput>
  }

  export type UserUpsertWithoutUserContactInput = {
    update: XOR<UserUpdateWithoutUserContactInput, UserUncheckedUpdateWithoutUserContactInput>
    create: XOR<UserCreateWithoutUserContactInput, UserUncheckedCreateWithoutUserContactInput>
  }

  export type UserUpdateWithoutUserContactInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
  }

  export type UserUncheckedUpdateWithoutUserContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
  }

  export type UserCreateWithoutCreateUserPositionInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    UserPosition?: UserPositionCreateNestedManyWithoutUser5Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreateUserPositionInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    UserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreateUserPositionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreateUserPositionInput, UserUncheckedCreateWithoutCreateUserPositionInput>
  }

  export type UserCreateWithoutUserPositionInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionCreateNestedManyWithoutUser4Input
    UserContact?: UserContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPositionInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: ClientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: ClientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedCreateNestedManyWithoutUser4Input
    UserContact?: UserContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPositionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPositionInput, UserUncheckedCreateWithoutUserPositionInput>
  }

  export type UserUpsertWithoutCreateUserPositionInput = {
    update: XOR<UserUpdateWithoutCreateUserPositionInput, UserUncheckedUpdateWithoutCreateUserPositionInput>
    create: XOR<UserCreateWithoutCreateUserPositionInput, UserUncheckedCreateWithoutCreateUserPositionInput>
  }

  export type UserUpdateWithoutCreateUserPositionInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    UserPosition?: UserPositionUpdateManyWithoutUser5Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCreateUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    UserPosition?: UserPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutUserPositionInput = {
    update: XOR<UserUpdateWithoutUserPositionInput, UserUncheckedUpdateWithoutUserPositionInput>
    create: XOR<UserCreateWithoutUserPositionInput, UserUncheckedCreateWithoutUserPositionInput>
  }

  export type UserUpdateWithoutUserPositionInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUpdateManyWithoutUserInput
    ClientContact?: ClientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutUserInput
    CodeReport?: CodeReportUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUpdateManyWithoutUser4Input
    UserContact?: UserContactUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: ClientUncheckedUpdateManyWithoutUserInput
    ClientContact?: ClientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: CodeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: ProjectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: RequestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: UserPositionUncheckedUpdateManyWithoutUser4Input
    UserContact?: UserContactUncheckedUpdateManyWithoutUserInput
  }

  export type ClientCreateWithoutUserInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    Contact?: ClientContactCreateNestedManyWithoutClientInput
    CodeProject?: CodeProjectCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    Contact?: ClientContactUncheckedCreateNestedManyWithoutClientInput
    CodeProject?: CodeProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateManyUserInputEnvelope = {
    data: Enumerable<ClientCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ClientContactCreateWithoutUserInput = {
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    Client: ClientCreateNestedOneWithoutContactInput
  }

  export type ClientContactUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    ClientId: number
  }

  export type ClientContactCreateOrConnectWithoutUserInput = {
    where: ClientContactWhereUniqueInput
    create: XOR<ClientContactCreateWithoutUserInput, ClientContactUncheckedCreateWithoutUserInput>
  }

  export type ClientContactCreateManyUserInputEnvelope = {
    data: Enumerable<ClientContactCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CodeProjectDocumentCreateWithoutUserInput = {
    Name: string
    Url: string
    CreatedDate?: Date | string
    CodeProject: CodeProjectCreateNestedOneWithoutCodeProjectDocumentInput
  }

  export type CodeProjectDocumentUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedDate?: Date | string
  }

  export type CodeProjectDocumentCreateOrConnectWithoutUserInput = {
    where: CodeProjectDocumentWhereUniqueInput
    create: XOR<CodeProjectDocumentCreateWithoutUserInput, CodeProjectDocumentUncheckedCreateWithoutUserInput>
  }

  export type CodeProjectDocumentCreateManyUserInputEnvelope = {
    data: Enumerable<CodeProjectDocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CodeProjectCreateWithoutUser1Input = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutUser1Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutUser1Input = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutUser1Input, CodeProjectUncheckedCreateWithoutUser1Input>
  }

  export type CodeProjectCreateManyUser1InputEnvelope = {
    data: Enumerable<CodeProjectCreateManyUser1Input>
    skipDuplicates?: boolean
  }

  export type CodeProjectCreateWithoutUser2Input = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User3?: UserCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutUser2Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutUser2Input = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutUser2Input, CodeProjectUncheckedCreateWithoutUser2Input>
  }

  export type CodeProjectCreateManyUser2InputEnvelope = {
    data: Enumerable<CodeProjectCreateManyUser2Input>
    skipDuplicates?: boolean
  }

  export type CodeProjectCreateWithoutUser3Input = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: ClientCreateNestedOneWithoutCodeProjectInput
    User1: UserCreateNestedOneWithoutCreateCodeProjectInput
    User2?: UserCreateNestedOneWithoutConfirmedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedCreateWithoutUser3Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: ProjectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type CodeProjectCreateOrConnectWithoutUser3Input = {
    where: CodeProjectWhereUniqueInput
    create: XOR<CodeProjectCreateWithoutUser3Input, CodeProjectUncheckedCreateWithoutUser3Input>
  }

  export type CodeProjectCreateManyUser3InputEnvelope = {
    data: Enumerable<CodeProjectCreateManyUser3Input>
    skipDuplicates?: boolean
  }

  export type CodeProjectUserCreateWithoutUserInput = {
    CodeProject: CodeProjectCreateNestedOneWithoutCodeProjectUserInput
  }

  export type CodeProjectUserUncheckedCreateWithoutUserInput = {
    Id?: number
    CodeProjectId: number
  }

  export type CodeProjectUserCreateOrConnectWithoutUserInput = {
    where: CodeProjectUserWhereUniqueInput
    create: XOR<CodeProjectUserCreateWithoutUserInput, CodeProjectUserUncheckedCreateWithoutUserInput>
  }

  export type CodeProjectUserCreateManyUserInputEnvelope = {
    data: Enumerable<CodeProjectUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CodeReportCreateWithoutUserInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    CodeProject: CodeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportCreateNestedOneWithoutCodeReportInput
    Tool?: ToolCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherCreateNestedOneWithoutCodeReportInput
    Material?: MaterialCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedCreateWithoutUserInput = {
    Id?: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: ToolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: WeatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: MaterialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: WorkerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type CodeReportCreateOrConnectWithoutUserInput = {
    where: CodeReportWhereUniqueInput
    create: XOR<CodeReportCreateWithoutUserInput, CodeReportUncheckedCreateWithoutUserInput>
  }

  export type CodeReportCreateManyUserInputEnvelope = {
    data: Enumerable<CodeReportCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CodeReportApprovalCreateWithoutUserInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReport: CodeReportCreateNestedOneWithoutCodeReportApprovalInput
    CodeReportComment: CodeReportCreateNestedOneWithoutCodeReportApprovalCommentInput
  }

  export type CodeReportApprovalUncheckedCreateWithoutUserInput = {
    Id?: number
    CodeReportId: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type CodeReportApprovalCreateOrConnectWithoutUserInput = {
    where: CodeReportApprovalWhereUniqueInput
    create: XOR<CodeReportApprovalCreateWithoutUserInput, CodeReportApprovalUncheckedCreateWithoutUserInput>
  }

  export type CodeReportApprovalCreateManyUserInputEnvelope = {
    data: Enumerable<CodeReportApprovalCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProjectTaskCreateWithoutUserInput = {
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
  }

  export type ProjectTaskUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
  }

  export type ProjectTaskCreateOrConnectWithoutUserInput = {
    where: ProjectTaskWhereUniqueInput
    create: XOR<ProjectTaskCreateWithoutUserInput, ProjectTaskUncheckedCreateWithoutUserInput>
  }

  export type ProjectTaskCreateManyUserInputEnvelope = {
    data: Enumerable<ProjectTaskCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestForInformationAnswerCreateWithoutUserInput = {
    Answer: string
    CreatedDate: Date | string
    IsDelete?: boolean
    RequestForInformation: RequestForInformationCreateNestedOneWithoutRequestForInformationAnswerInput
  }

  export type RequestForInformationAnswerUncheckedCreateWithoutUserInput = {
    Id?: number
    Answer: string
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type RequestForInformationAnswerCreateOrConnectWithoutUserInput = {
    where: RequestForInformationAnswerWhereUniqueInput
    create: XOR<RequestForInformationAnswerCreateWithoutUserInput, RequestForInformationAnswerUncheckedCreateWithoutUserInput>
  }

  export type RequestForInformationAnswerCreateManyUserInputEnvelope = {
    data: Enumerable<RequestForInformationAnswerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserPositionCreateWithoutUser4Input = {
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    User5: UserCreateNestedOneWithoutUserPositionInput
  }

  export type UserPositionUncheckedCreateWithoutUser4Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    UserId: number
  }

  export type UserPositionCreateOrConnectWithoutUser4Input = {
    where: UserPositionWhereUniqueInput
    create: XOR<UserPositionCreateWithoutUser4Input, UserPositionUncheckedCreateWithoutUser4Input>
  }

  export type UserPositionCreateManyUser4InputEnvelope = {
    data: Enumerable<UserPositionCreateManyUser4Input>
    skipDuplicates?: boolean
  }

  export type UserPositionCreateWithoutUser5Input = {
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    User4: UserCreateNestedOneWithoutCreateUserPositionInput
  }

  export type UserPositionUncheckedCreateWithoutUser5Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type UserPositionCreateOrConnectWithoutUser5Input = {
    where: UserPositionWhereUniqueInput
    create: XOR<UserPositionCreateWithoutUser5Input, UserPositionUncheckedCreateWithoutUser5Input>
  }

  export type UserPositionCreateManyUser5InputEnvelope = {
    data: Enumerable<UserPositionCreateManyUser5Input>
    skipDuplicates?: boolean
  }

  export type UserContactCreateWithoutUserInput = {
    PhoneNumber: string
    WhatsappAvailable: boolean
  }

  export type UserContactUncheckedCreateWithoutUserInput = {
    Id?: number
    PhoneNumber: string
    WhatsappAvailable: boolean
  }

  export type UserContactCreateOrConnectWithoutUserInput = {
    where: UserContactWhereUniqueInput
    create: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput>
  }

  export type UserContactCreateManyUserInputEnvelope = {
    data: Enumerable<UserContactCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateManyWithWhereWithoutUserInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientScalarWhereInput = {
    AND?: Enumerable<ClientScalarWhereInput>
    OR?: Enumerable<ClientScalarWhereInput>
    NOT?: Enumerable<ClientScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Address?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    PhoneNumber?: StringNullableFilter | string | null
    TaxIdentificationNumber?: StringNullableFilter | string | null
    IsDelete?: BoolFilter | boolean
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
  }

  export type ClientContactUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientContactWhereUniqueInput
    update: XOR<ClientContactUpdateWithoutUserInput, ClientContactUncheckedUpdateWithoutUserInput>
    create: XOR<ClientContactCreateWithoutUserInput, ClientContactUncheckedCreateWithoutUserInput>
  }

  export type ClientContactUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientContactWhereUniqueInput
    data: XOR<ClientContactUpdateWithoutUserInput, ClientContactUncheckedUpdateWithoutUserInput>
  }

  export type ClientContactUpdateManyWithWhereWithoutUserInput = {
    where: ClientContactScalarWhereInput
    data: XOR<ClientContactUpdateManyMutationInput, ClientContactUncheckedUpdateManyWithoutClientContactInput>
  }

  export type CodeProjectDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeProjectDocumentWhereUniqueInput
    update: XOR<CodeProjectDocumentUpdateWithoutUserInput, CodeProjectDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<CodeProjectDocumentCreateWithoutUserInput, CodeProjectDocumentUncheckedCreateWithoutUserInput>
  }

  export type CodeProjectDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeProjectDocumentWhereUniqueInput
    data: XOR<CodeProjectDocumentUpdateWithoutUserInput, CodeProjectDocumentUncheckedUpdateWithoutUserInput>
  }

  export type CodeProjectDocumentUpdateManyWithWhereWithoutUserInput = {
    where: CodeProjectDocumentScalarWhereInput
    data: XOR<CodeProjectDocumentUpdateManyMutationInput, CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectDocumentInput>
  }

  export type CodeProjectUpsertWithWhereUniqueWithoutUser1Input = {
    where: CodeProjectWhereUniqueInput
    update: XOR<CodeProjectUpdateWithoutUser1Input, CodeProjectUncheckedUpdateWithoutUser1Input>
    create: XOR<CodeProjectCreateWithoutUser1Input, CodeProjectUncheckedCreateWithoutUser1Input>
  }

  export type CodeProjectUpdateWithWhereUniqueWithoutUser1Input = {
    where: CodeProjectWhereUniqueInput
    data: XOR<CodeProjectUpdateWithoutUser1Input, CodeProjectUncheckedUpdateWithoutUser1Input>
  }

  export type CodeProjectUpdateManyWithWhereWithoutUser1Input = {
    where: CodeProjectScalarWhereInput
    data: XOR<CodeProjectUpdateManyMutationInput, CodeProjectUncheckedUpdateManyWithoutCreateCodeProjectInput>
  }

  export type CodeProjectUpsertWithWhereUniqueWithoutUser2Input = {
    where: CodeProjectWhereUniqueInput
    update: XOR<CodeProjectUpdateWithoutUser2Input, CodeProjectUncheckedUpdateWithoutUser2Input>
    create: XOR<CodeProjectCreateWithoutUser2Input, CodeProjectUncheckedCreateWithoutUser2Input>
  }

  export type CodeProjectUpdateWithWhereUniqueWithoutUser2Input = {
    where: CodeProjectWhereUniqueInput
    data: XOR<CodeProjectUpdateWithoutUser2Input, CodeProjectUncheckedUpdateWithoutUser2Input>
  }

  export type CodeProjectUpdateManyWithWhereWithoutUser2Input = {
    where: CodeProjectScalarWhereInput
    data: XOR<CodeProjectUpdateManyMutationInput, CodeProjectUncheckedUpdateManyWithoutConfirmedCodeProjectInput>
  }

  export type CodeProjectUpsertWithWhereUniqueWithoutUser3Input = {
    where: CodeProjectWhereUniqueInput
    update: XOR<CodeProjectUpdateWithoutUser3Input, CodeProjectUncheckedUpdateWithoutUser3Input>
    create: XOR<CodeProjectCreateWithoutUser3Input, CodeProjectUncheckedCreateWithoutUser3Input>
  }

  export type CodeProjectUpdateWithWhereUniqueWithoutUser3Input = {
    where: CodeProjectWhereUniqueInput
    data: XOR<CodeProjectUpdateWithoutUser3Input, CodeProjectUncheckedUpdateWithoutUser3Input>
  }

  export type CodeProjectUpdateManyWithWhereWithoutUser3Input = {
    where: CodeProjectScalarWhereInput
    data: XOR<CodeProjectUpdateManyMutationInput, CodeProjectUncheckedUpdateManyWithoutCompletedCodeProjectInput>
  }

  export type CodeProjectUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeProjectUserWhereUniqueInput
    update: XOR<CodeProjectUserUpdateWithoutUserInput, CodeProjectUserUncheckedUpdateWithoutUserInput>
    create: XOR<CodeProjectUserCreateWithoutUserInput, CodeProjectUserUncheckedCreateWithoutUserInput>
  }

  export type CodeProjectUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeProjectUserWhereUniqueInput
    data: XOR<CodeProjectUserUpdateWithoutUserInput, CodeProjectUserUncheckedUpdateWithoutUserInput>
  }

  export type CodeProjectUserUpdateManyWithWhereWithoutUserInput = {
    where: CodeProjectUserScalarWhereInput
    data: XOR<CodeProjectUserUpdateManyMutationInput, CodeProjectUserUncheckedUpdateManyWithoutCodeProjectUserInput>
  }

  export type CodeReportUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeReportWhereUniqueInput
    update: XOR<CodeReportUpdateWithoutUserInput, CodeReportUncheckedUpdateWithoutUserInput>
    create: XOR<CodeReportCreateWithoutUserInput, CodeReportUncheckedCreateWithoutUserInput>
  }

  export type CodeReportUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeReportWhereUniqueInput
    data: XOR<CodeReportUpdateWithoutUserInput, CodeReportUncheckedUpdateWithoutUserInput>
  }

  export type CodeReportUpdateManyWithWhereWithoutUserInput = {
    where: CodeReportScalarWhereInput
    data: XOR<CodeReportUpdateManyMutationInput, CodeReportUncheckedUpdateManyWithoutCodeReportInput>
  }

  export type CodeReportApprovalUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeReportApprovalWhereUniqueInput
    update: XOR<CodeReportApprovalUpdateWithoutUserInput, CodeReportApprovalUncheckedUpdateWithoutUserInput>
    create: XOR<CodeReportApprovalCreateWithoutUserInput, CodeReportApprovalUncheckedCreateWithoutUserInput>
  }

  export type CodeReportApprovalUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeReportApprovalWhereUniqueInput
    data: XOR<CodeReportApprovalUpdateWithoutUserInput, CodeReportApprovalUncheckedUpdateWithoutUserInput>
  }

  export type CodeReportApprovalUpdateManyWithWhereWithoutUserInput = {
    where: CodeReportApprovalScalarWhereInput
    data: XOR<CodeReportApprovalUpdateManyMutationInput, CodeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalInput>
  }

  export type ProjectTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectTaskWhereUniqueInput
    update: XOR<ProjectTaskUpdateWithoutUserInput, ProjectTaskUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectTaskCreateWithoutUserInput, ProjectTaskUncheckedCreateWithoutUserInput>
  }

  export type ProjectTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectTaskWhereUniqueInput
    data: XOR<ProjectTaskUpdateWithoutUserInput, ProjectTaskUncheckedUpdateWithoutUserInput>
  }

  export type ProjectTaskUpdateManyWithWhereWithoutUserInput = {
    where: ProjectTaskScalarWhereInput
    data: XOR<ProjectTaskUpdateManyMutationInput, ProjectTaskUncheckedUpdateManyWithoutProjectTaskInput>
  }

  export type ProjectTaskScalarWhereInput = {
    AND?: Enumerable<ProjectTaskScalarWhereInput>
    OR?: Enumerable<ProjectTaskScalarWhereInput>
    NOT?: Enumerable<ProjectTaskScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    ParentId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
  }

  export type RequestForInformationAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestForInformationAnswerWhereUniqueInput
    update: XOR<RequestForInformationAnswerUpdateWithoutUserInput, RequestForInformationAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<RequestForInformationAnswerCreateWithoutUserInput, RequestForInformationAnswerUncheckedCreateWithoutUserInput>
  }

  export type RequestForInformationAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestForInformationAnswerWhereUniqueInput
    data: XOR<RequestForInformationAnswerUpdateWithoutUserInput, RequestForInformationAnswerUncheckedUpdateWithoutUserInput>
  }

  export type RequestForInformationAnswerUpdateManyWithWhereWithoutUserInput = {
    where: RequestForInformationAnswerScalarWhereInput
    data: XOR<RequestForInformationAnswerUpdateManyMutationInput, RequestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationAnswerInput>
  }

  export type UserPositionUpsertWithWhereUniqueWithoutUser4Input = {
    where: UserPositionWhereUniqueInput
    update: XOR<UserPositionUpdateWithoutUser4Input, UserPositionUncheckedUpdateWithoutUser4Input>
    create: XOR<UserPositionCreateWithoutUser4Input, UserPositionUncheckedCreateWithoutUser4Input>
  }

  export type UserPositionUpdateWithWhereUniqueWithoutUser4Input = {
    where: UserPositionWhereUniqueInput
    data: XOR<UserPositionUpdateWithoutUser4Input, UserPositionUncheckedUpdateWithoutUser4Input>
  }

  export type UserPositionUpdateManyWithWhereWithoutUser4Input = {
    where: UserPositionScalarWhereInput
    data: XOR<UserPositionUpdateManyMutationInput, UserPositionUncheckedUpdateManyWithoutCreateUserPositionInput>
  }

  export type UserPositionScalarWhereInput = {
    AND?: Enumerable<UserPositionScalarWhereInput>
    OR?: Enumerable<UserPositionScalarWhereInput>
    NOT?: Enumerable<UserPositionScalarWhereInput>
    Id?: IntFilter | number
    Position?: IntFilter | number
    EffectiveDate?: DateTimeFilter | Date | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    UserId?: IntFilter | number
  }

  export type UserPositionUpsertWithWhereUniqueWithoutUser5Input = {
    where: UserPositionWhereUniqueInput
    update: XOR<UserPositionUpdateWithoutUser5Input, UserPositionUncheckedUpdateWithoutUser5Input>
    create: XOR<UserPositionCreateWithoutUser5Input, UserPositionUncheckedCreateWithoutUser5Input>
  }

  export type UserPositionUpdateWithWhereUniqueWithoutUser5Input = {
    where: UserPositionWhereUniqueInput
    data: XOR<UserPositionUpdateWithoutUser5Input, UserPositionUncheckedUpdateWithoutUser5Input>
  }

  export type UserPositionUpdateManyWithWhereWithoutUser5Input = {
    where: UserPositionScalarWhereInput
    data: XOR<UserPositionUpdateManyMutationInput, UserPositionUncheckedUpdateManyWithoutUserPositionInput>
  }

  export type UserContactUpsertWithWhereUniqueWithoutUserInput = {
    where: UserContactWhereUniqueInput
    update: XOR<UserContactUpdateWithoutUserInput, UserContactUncheckedUpdateWithoutUserInput>
    create: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput>
  }

  export type UserContactUpdateWithWhereUniqueWithoutUserInput = {
    where: UserContactWhereUniqueInput
    data: XOR<UserContactUpdateWithoutUserInput, UserContactUncheckedUpdateWithoutUserInput>
  }

  export type UserContactUpdateManyWithWhereWithoutUserInput = {
    where: UserContactScalarWhereInput
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyWithoutUserContactInput>
  }

  export type UserContactScalarWhereInput = {
    AND?: Enumerable<UserContactScalarWhereInput>
    OR?: Enumerable<UserContactScalarWhereInput>
    NOT?: Enumerable<UserContactScalarWhereInput>
    Id?: IntFilter | number
    PhoneNumber?: StringFilter | string
    UserId?: IntFilter | number
    WhatsappAvailable?: BoolFilter | boolean
  }

  export type ClientContactCreateManyClientInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type CodeProjectCreateManyClientInput = {
    Id?: number
    Name: string
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type ClientContactUpdateWithoutClientInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutClientContactInput
  }

  export type ClientContactUncheckedUpdateWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContactUncheckedUpdateManyWithoutContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeProjectUpdateWithoutClientInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateManyWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeProjectDocumentCreateManyCodeProjectInput = {
    Id?: number
    Name: string
    Url: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type CodeProjectUserCreateManyCodeProjectInput = {
    Id?: number
    UserId: number
  }

  export type CodeReportCreateManyCodeProjectInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
  }

  export type ProjectCreateManyCodeProjectInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type CodeProjectDocumentUpdateWithoutCodeProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutCodeProjectDocumentInput
  }

  export type CodeProjectDocumentUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeProjectUserUpdateWithoutCodeProjectInput = {
    User?: UserUpdateOneRequiredWithoutCodeProjectUserInput
  }

  export type CodeProjectUserUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeProjectUserUncheckedUpdateManyWithoutCodeProjectUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeReportUpdateWithoutCodeProjectInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateManyWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutCodeProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUncheckedUpdateManyWithoutProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type CodeReportApprovalCreateManyCodeReportInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type CodeReportApprovalCreateManyCodeReportCommentInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type DailyReportImageCreateManyCodeReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type DailyTaskCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
  }

  export type ToolCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
  }

  export type MaterialCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
  }

  export type WorkerCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
  }

  export type CodeReportApprovalUpdateWithoutCodeReportInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReportComment?: CodeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput
    User?: UserUpdateOneRequiredWithoutCodeReportApprovalInput
  }

  export type CodeReportApprovalUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeReportApprovalUpdateWithoutCodeReportCommentInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: CodeReportUpdateOneRequiredWithoutCodeReportApprovalInput
    User?: UserUpdateOneRequiredWithoutCodeReportApprovalInput
  }

  export type CodeReportApprovalUncheckedUpdateWithoutCodeReportCommentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalCommentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyReportImageUpdateWithoutCodeReportInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportImageUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type DailyReportImageUncheckedUpdateManyWithoutDailyReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type DailyTaskUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type DailyTaskUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type DailyTaskUncheckedUpdateManyWithoutDailyTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type ToolUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ToolUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ToolUncheckedUpdateManyWithoutToolInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialUncheckedUpdateManyWithoutMaterialInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerUncheckedUpdateManyWithoutWorkerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RequestForInformationAnswerCreateManyRequestForInformationInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    IsDelete?: boolean
  }

  export type RequestForInformationDocumentCreateManyRequestForInformationInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type RequestForInformationAnswerUpdateWithoutRequestForInformationInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutRequestForInformationAnswerInput
  }

  export type RequestForInformationAnswerUncheckedUpdateWithoutRequestForInformationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationAnswerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestForInformationDocumentUpdateWithoutRequestForInformationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type RequestForInformationDocumentUncheckedUpdateWithoutRequestForInformationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type RequestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusReportImageCreateManyStatusReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type StatusReportImageUpdateWithoutStatusReportInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusReportImageUncheckedUpdateWithoutStatusReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusReportImageUncheckedUpdateManyWithoutStatusReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateManyUserInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
  }

  export type ClientContactCreateManyUserInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    ClientId: number
  }

  export type CodeProjectDocumentCreateManyUserInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedDate?: Date | string
  }

  export type CodeProjectCreateManyUser1Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type CodeProjectCreateManyUser2Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type CodeProjectCreateManyUser3Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
  }

  export type CodeProjectUserCreateManyUserInput = {
    Id?: number
    CodeProjectId: number
  }

  export type CodeReportCreateManyUserInput = {
    Id?: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
  }

  export type CodeReportApprovalCreateManyUserInput = {
    Id?: number
    CodeReportId: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type ProjectTaskCreateManyUserInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
  }

  export type RequestForInformationAnswerCreateManyUserInput = {
    Id?: number
    Answer: string
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type UserPositionCreateManyUser4Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    UserId: number
  }

  export type UserPositionCreateManyUser5Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type UserContactCreateManyUserInput = {
    Id?: number
    PhoneNumber: string
    WhatsappAvailable: boolean
  }

  export type ClientUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ClientContactUpdateManyWithoutClientInput
    CodeProject?: CodeProjectUpdateManyWithoutClientInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ClientContactUncheckedUpdateManyWithoutClientInput
    CodeProject?: CodeProjectUncheckedUpdateManyWithoutClientInput
  }

  export type ClientUncheckedUpdateManyWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientContactUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Client?: ClientUpdateOneRequiredWithoutContactInput
  }

  export type ClientContactUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type ClientContactUncheckedUpdateManyWithoutClientContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeProjectDocumentUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeProjectDocumentInput
  }

  export type CodeProjectDocumentUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeProjectUpdateWithoutUser1Input = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutUser1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateManyWithoutCreateCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeProjectUpdateWithoutUser2Input = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User3?: UserUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutUser2Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateManyWithoutConfirmedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeProjectUpdateWithoutUser3Input = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: ClientUpdateOneRequiredWithoutCodeProjectInput
    User1?: UserUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: UserUpdateOneWithoutConfirmedCodeProjectInput
    CodeProjectDocument?: CodeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUpdateManyWithoutCodeProjectInput
    Project?: ProjectUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateWithoutUser3Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: CodeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: CodeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: CodeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: ProjectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type CodeProjectUncheckedUpdateManyWithoutCompletedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeProjectUserUpdateWithoutUserInput = {
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeProjectUserInput
  }

  export type CodeProjectUserUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeProjectId?: IntFieldUpdateOperationsInput | number
  }

  export type CodeReportUpdateWithoutUserInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeProject?: CodeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: CodeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUpdateOneWithoutCodeReportInput
    Tool?: ToolUpdateManyWithoutCodeReportInput
    Weather?: WeatherUpdateOneWithoutCodeReportInput
    Material?: MaterialUpdateManyWithoutCodeReportInput
    Worker?: WorkerUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUpdateOneWithoutCodeReportInput
  }

  export type CodeReportUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: CodeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: DailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: DailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: StatusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: ToolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: WeatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: MaterialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: WorkerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: RequestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type CodeReportApprovalUpdateWithoutUserInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: CodeReportUpdateOneRequiredWithoutCodeReportApprovalInput
    CodeReportComment?: CodeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput
  }

  export type CodeReportApprovalUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectTaskUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateManyWithoutProjectTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestForInformationAnswerUpdateWithoutUserInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformation?: RequestForInformationUpdateOneRequiredWithoutRequestForInformationAnswerInput
  }

  export type RequestForInformationAnswerUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPositionUpdateWithoutUser4Input = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User5?: UserUpdateOneRequiredWithoutUserPositionInput
  }

  export type UserPositionUncheckedUpdateWithoutUser4Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPositionUncheckedUpdateManyWithoutCreateUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPositionUpdateWithoutUser5Input = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User4?: UserUpdateOneRequiredWithoutCreateUserPositionInput
  }

  export type UserPositionUncheckedUpdateWithoutUser5Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPositionUncheckedUpdateManyWithoutUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserContactUpdateWithoutUserInput = {
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserContactUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserContactUncheckedUpdateManyWithoutUserContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}