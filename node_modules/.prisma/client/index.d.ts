
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model client
 */

export type client = {
  Id: number
  Name: string
  Address: string | null
  City: string | null
  PhoneNumber: string | null
  TaxIdentificationNumber: string | null
  IsDelete: boolean
  CreatedBy: number
  CreatedDate: Date
}

/**
 * Model userToken
 */

export type userToken = {
  Id: number
  UserId: number
  Token: string
}

/**
 * Model clientContact
 */

export type clientContact = {
  Id: number
  Name: string
  Position: string
  PhoneNumber: string
  Email: string
  CreatedBy: number
  CreatedDate: Date
  ClientId: number
}

/**
 * Model codeProject
 */

export type codeProject = {
  Id: number
  Name: string
  ClientId: number
  CreatedBy: number
  CreatedDate: Date
  ConfirmedDate: Date | null
  ConfirmedBy: number | null
  Address: string
  DocumentName: string
  IsCompleted: boolean
  CompletedDate: Date | null
  CompletedBy: number | null
  IsDelete: boolean
}

/**
 * Model codeProjectDocument
 */

export type codeProjectDocument = {
  Id: number
  Name: string
  Url: string
  CodeProjectId: number
  CreatedBy: number
  CreatedDate: Date
}

/**
 * Model codeProjectUser
 */

export type codeProjectUser = {
  Id: number
  UserId: number
  CodeProjectId: number
}

/**
 * Model codeReport
 */

export type codeReport = {
  Id: number
  CreatedBy: number
  CreatedDate: Date
  Date: Date
  CodeProjectId: number
  Type: number
  IsDelete: boolean
  Note: string
}

/**
 * Model codeReportApproval
 */

export type codeReportApproval = {
  Id: number
  CodeReportId: number
  CreatedBy: number
  CreatedDate: Date
  Comment: string
  Approval: number
  IsDelete: boolean
}

/**
 * Model dailyReportImage
 */

export type dailyReportImage = {
  Id: number
  CodeReportId: number
  ImageUrl: string
  Name: string
  Caption: string
}

/**
 * Model dailyTask
 */

export type dailyTask = {
  Id: number
  Name: string
  Description: string
  Unit: string
  Quantity: number
  ParentId: number
  CodeReportId: number
  Note: string
}

/**
 * Model material
 */

export type material = {
  Id: number
  Name: string
  Quantity: number
  Status: number
  Description: string
  Unit: string
  CodeReportId: number
}

/**
 * Model project
 */

export type project = {
  Id: number
  Name: string
  BudgetPrice: number
  Quantity: number
  Done: number
  IsDelete: boolean
  CodeProjectId: number
  ParentId: number
  EstimatedDuration: number
  Timeline: number
  Price: number
  Description: string
  Unit: string
}

/**
 * Model projectTask
 */

export type projectTask = {
  Id: number
  Name: string
  Description: string
  ParentId: number
  CreatedBy: number
  CreatedDate: Date
}

/**
 * Model requestForInformation
 */

export type requestForInformation = {
  Id: number
  CodeReportId: number
  Description: string
  Header: string
  AddressedFor: string
  IsDelete: boolean
}

/**
 * Model requestForInformationAnswer
 */

export type requestForInformationAnswer = {
  Id: number
  Answer: string
  CreatedBy: number
  CreatedDate: Date
  RequestForInformationId: number
  IsDelete: boolean
}

/**
 * Model requestForInformationDocument
 */

export type requestForInformationDocument = {
  Id: number
  RequestForInformationId: number
  ImageUrl: string
  Name: string
}

/**
 * Model statusReport
 */

export type statusReport = {
  Id: number
  Status: string
  CodeReportId: number
}

/**
 * Model statusReportImage
 */

export type statusReportImage = {
  Id: number
  StatusReportId: number
  ImageUrl: string
  Name: string
}

/**
 * Model tool
 */

export type tool = {
  Id: number
  Name: string
  Description: string
  Quantity: number
  CodeReportId: number
}

/**
 * Model weather
 */

export type weather = {
  Id: number
  WeatherId: number
  CodeReportId: number
}

/**
 * Model worker
 */

export type worker = {
  Id: number
  Name: string
  CodeReportId: number
  Quantity: number
}

/**
 * Model userContact
 */

export type userContact = {
  Id: number
  PhoneNumber: string
  UserId: number
  WhatsappAvailable: boolean
}

/**
 * Model userPosition
 */

export type userPosition = {
  Id: number
  Position: number
  EffectiveDate: Date
  CreatedBy: number
  CreatedDate: Date
  UserId: number
}

/**
 * Model user
 */

export type user = {
  Id: number
  Email: string
  FirstName: string
  LastName: string
  IsActive: boolean
  Password: string | null
  ImageUrl: string | null
  ThumbnailUrl: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clients
 * const clients = await prisma.client.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clients
   * const clients = await prisma.client.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.client`: Exposes CRUD operations for the **client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.clientDelegate<GlobalReject>;

  /**
   * `prisma.userToken`: Exposes CRUD operations for the **userToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTokens
    * const userTokens = await prisma.userToken.findMany()
    * ```
    */
  get userToken(): Prisma.userTokenDelegate<GlobalReject>;

  /**
   * `prisma.clientContact`: Exposes CRUD operations for the **clientContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContacts
    * const clientContacts = await prisma.clientContact.findMany()
    * ```
    */
  get clientContact(): Prisma.clientContactDelegate<GlobalReject>;

  /**
   * `prisma.codeProject`: Exposes CRUD operations for the **codeProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeProjects
    * const codeProjects = await prisma.codeProject.findMany()
    * ```
    */
  get codeProject(): Prisma.codeProjectDelegate<GlobalReject>;

  /**
   * `prisma.codeProjectDocument`: Exposes CRUD operations for the **codeProjectDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeProjectDocuments
    * const codeProjectDocuments = await prisma.codeProjectDocument.findMany()
    * ```
    */
  get codeProjectDocument(): Prisma.codeProjectDocumentDelegate<GlobalReject>;

  /**
   * `prisma.codeProjectUser`: Exposes CRUD operations for the **codeProjectUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeProjectUsers
    * const codeProjectUsers = await prisma.codeProjectUser.findMany()
    * ```
    */
  get codeProjectUser(): Prisma.codeProjectUserDelegate<GlobalReject>;

  /**
   * `prisma.codeReport`: Exposes CRUD operations for the **codeReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeReports
    * const codeReports = await prisma.codeReport.findMany()
    * ```
    */
  get codeReport(): Prisma.codeReportDelegate<GlobalReject>;

  /**
   * `prisma.codeReportApproval`: Exposes CRUD operations for the **codeReportApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeReportApprovals
    * const codeReportApprovals = await prisma.codeReportApproval.findMany()
    * ```
    */
  get codeReportApproval(): Prisma.codeReportApprovalDelegate<GlobalReject>;

  /**
   * `prisma.dailyReportImage`: Exposes CRUD operations for the **dailyReportImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyReportImages
    * const dailyReportImages = await prisma.dailyReportImage.findMany()
    * ```
    */
  get dailyReportImage(): Prisma.dailyReportImageDelegate<GlobalReject>;

  /**
   * `prisma.dailyTask`: Exposes CRUD operations for the **dailyTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyTasks
    * const dailyTasks = await prisma.dailyTask.findMany()
    * ```
    */
  get dailyTask(): Prisma.dailyTaskDelegate<GlobalReject>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.materialDelegate<GlobalReject>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.projectDelegate<GlobalReject>;

  /**
   * `prisma.projectTask`: Exposes CRUD operations for the **projectTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTasks
    * const projectTasks = await prisma.projectTask.findMany()
    * ```
    */
  get projectTask(): Prisma.projectTaskDelegate<GlobalReject>;

  /**
   * `prisma.requestForInformation`: Exposes CRUD operations for the **requestForInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestForInformations
    * const requestForInformations = await prisma.requestForInformation.findMany()
    * ```
    */
  get requestForInformation(): Prisma.requestForInformationDelegate<GlobalReject>;

  /**
   * `prisma.requestForInformationAnswer`: Exposes CRUD operations for the **requestForInformationAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestForInformationAnswers
    * const requestForInformationAnswers = await prisma.requestForInformationAnswer.findMany()
    * ```
    */
  get requestForInformationAnswer(): Prisma.requestForInformationAnswerDelegate<GlobalReject>;

  /**
   * `prisma.requestForInformationDocument`: Exposes CRUD operations for the **requestForInformationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestForInformationDocuments
    * const requestForInformationDocuments = await prisma.requestForInformationDocument.findMany()
    * ```
    */
  get requestForInformationDocument(): Prisma.requestForInformationDocumentDelegate<GlobalReject>;

  /**
   * `prisma.statusReport`: Exposes CRUD operations for the **statusReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusReports
    * const statusReports = await prisma.statusReport.findMany()
    * ```
    */
  get statusReport(): Prisma.statusReportDelegate<GlobalReject>;

  /**
   * `prisma.statusReportImage`: Exposes CRUD operations for the **statusReportImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusReportImages
    * const statusReportImages = await prisma.statusReportImage.findMany()
    * ```
    */
  get statusReportImage(): Prisma.statusReportImageDelegate<GlobalReject>;

  /**
   * `prisma.tool`: Exposes CRUD operations for the **tool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tools
    * const tools = await prisma.tool.findMany()
    * ```
    */
  get tool(): Prisma.toolDelegate<GlobalReject>;

  /**
   * `prisma.weather`: Exposes CRUD operations for the **weather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weathers
    * const weathers = await prisma.weather.findMany()
    * ```
    */
  get weather(): Prisma.weatherDelegate<GlobalReject>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.workerDelegate<GlobalReject>;

  /**
   * `prisma.userContact`: Exposes CRUD operations for the **userContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserContacts
    * const userContacts = await prisma.userContact.findMany()
    * ```
    */
  get userContact(): Prisma.userContactDelegate<GlobalReject>;

  /**
   * `prisma.userPosition`: Exposes CRUD operations for the **userPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPositions
    * const userPositions = await prisma.userPosition.findMany()
    * ```
    */
  get userPosition(): Prisma.userPositionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.28.0
   * Query Engine version: c838e79f39885bc8e1611849b1eb28b5bb5bc922
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    client: 'client',
    userToken: 'userToken',
    clientContact: 'clientContact',
    codeProject: 'codeProject',
    codeProjectDocument: 'codeProjectDocument',
    codeProjectUser: 'codeProjectUser',
    codeReport: 'codeReport',
    codeReportApproval: 'codeReportApproval',
    dailyReportImage: 'dailyReportImage',
    dailyTask: 'dailyTask',
    material: 'material',
    project: 'project',
    projectTask: 'projectTask',
    requestForInformation: 'requestForInformation',
    requestForInformationAnswer: 'requestForInformationAnswer',
    requestForInformationDocument: 'requestForInformationDocument',
    statusReport: 'statusReport',
    statusReportImage: 'statusReportImage',
    tool: 'tool',
    weather: 'weather',
    worker: 'worker',
    userContact: 'userContact',
    userPosition: 'userPosition',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
    max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
  }

  export type ClientSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
  }

  export type ClientMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Address: string | null
    City: string | null
    PhoneNumber: string | null
    TaxIdentificationNumber: string | null
    IsDelete: boolean | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Address: string | null
    City: string | null
    PhoneNumber: string | null
    TaxIdentificationNumber: string | null
    IsDelete: boolean | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ClientCountAggregateOutputType = {
    Id: number
    Name: number
    Address: number
    City: number
    PhoneNumber: number
    TaxIdentificationNumber: number
    IsDelete: number
    CreatedBy: number
    CreatedDate: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
  }

  export type ClientSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
  }

  export type ClientMinAggregateInputType = {
    Id?: true
    Name?: true
    Address?: true
    City?: true
    PhoneNumber?: true
    TaxIdentificationNumber?: true
    IsDelete?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ClientMaxAggregateInputType = {
    Id?: true
    Name?: true
    Address?: true
    City?: true
    PhoneNumber?: true
    TaxIdentificationNumber?: true
    IsDelete?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ClientCountAggregateInputType = {
    Id?: true
    Name?: true
    Address?: true
    City?: true
    PhoneNumber?: true
    TaxIdentificationNumber?: true
    IsDelete?: true
    CreatedBy?: true
    CreatedDate?: true
    _all?: true
  }

  export type ClientAggregateArgs = {
    /**
     * Filter which client to aggregate.
     * 
    **/
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     * 
    **/
    orderBy?: Enumerable<clientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }


    
    
  export type ClientGroupByArgs = {
    where?: clientWhereInput
    orderBy?: Enumerable<clientOrderByInput>
    by: Array<ClientScalarFieldEnum>
    having?: clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    Id: number
    Name: string
    Address: string | null
    City: string | null
    PhoneNumber: string | null
    TaxIdentificationNumber: string | null
    IsDelete: boolean
    CreatedBy: number
    CreatedDate: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Promise<
    Array<
      PickArray<ClientGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ClientGroupByOutputType[P]> 
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      > 
    >


  export type clientSelect = {
    Id?: boolean
    Name?: boolean
    Address?: boolean
    City?: boolean
    PhoneNumber?: boolean
    TaxIdentificationNumber?: boolean
    User?: boolean | userArgs
    IsDelete?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Contact?: boolean | clientContactFindManyArgs
    CodeProject?: boolean | codeProjectFindManyArgs
  }

  export type clientInclude = {
    User?: boolean | userArgs
    Contact?: boolean | clientContactFindManyArgs
    CodeProject?: boolean | codeProjectFindManyArgs
  }

  export type clientGetPayload<
    S extends boolean | null | undefined | clientArgs,
    U = keyof S
      > = S extends true
        ? client
    : S extends undefined
    ? never
    : S extends clientArgs | clientFindManyArgs
    ?'include' extends U
    ? client  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> :
        P extends 'Contact'
        ? Array < clientContactGetPayload<S['include'][P]>>  :
        P extends 'CodeProject'
        ? Array < codeProjectGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof client ?client [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> :
        P extends 'Contact'
        ? Array < clientContactGetPayload<S['select'][P]>>  :
        P extends 'CodeProject'
        ? Array < codeProjectGetPayload<S['select'][P]>>  : never
  } 
    : client
  : client


  type clientCountArgs = Merge<
    Omit<clientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }
  >

  export interface clientDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Client that matches the filter.
     * @param {clientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'client'> extends True ? CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>> : CheckSelect<T, Prisma__clientClient<client | null >, Prisma__clientClient<clientGetPayload<T> | null >>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'client'> extends True ? CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>> : CheckSelect<T, Prisma__clientClient<client | null >, Prisma__clientClient<clientGetPayload<T> | null >>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends clientFindManyArgs>(
      args?: SelectSubset<T, clientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<client>>, PrismaPromise<Array<clientGetPayload<T>>>>

    /**
     * Create a Client.
     * @param {clientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends clientCreateArgs>(
      args: SelectSubset<T, clientCreateArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Create many Clients.
     *     @param {clientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientCreateManyArgs>(
      args?: SelectSubset<T, clientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {clientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends clientDeleteArgs>(
      args: SelectSubset<T, clientDeleteArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Update one Client.
     * @param {clientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientUpdateArgs>(
      args: SelectSubset<T, clientUpdateArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Delete zero or more Clients.
     * @param {clientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientDeleteManyArgs>(
      args?: SelectSubset<T, clientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientUpdateManyArgs>(
      args: SelectSubset<T, clientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {clientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends clientUpsertArgs>(
      args: SelectSubset<T, clientUpsertArgs>
    ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientCountArgs>(
      args?: Subset<T, clientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    Contact<T extends clientContactFindManyArgs = {}>(args?: Subset<T, clientContactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientContact>>, PrismaPromise<Array<clientContactGetPayload<T>>>>;

    CodeProject<T extends codeProjectFindManyArgs = {}>(args?: Subset<T, codeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProject>>, PrismaPromise<Array<codeProjectGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * client findUnique
   */
  export type clientFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Throw an Error if a client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which client to fetch.
     * 
    **/
    where: clientWhereUniqueInput
  }


  /**
   * client findFirst
   */
  export type clientFindFirstArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Throw an Error if a client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which client to fetch.
     * 
    **/
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     * 
    **/
    orderBy?: Enumerable<clientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     * 
    **/
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     * 
    **/
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * client findMany
   */
  export type clientFindManyArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Filter, which clients to fetch.
     * 
    **/
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     * 
    **/
    orderBy?: Enumerable<clientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     * 
    **/
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * client create
   */
  export type clientCreateArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * The data needed to create a client.
     * 
    **/
    data: XOR<clientCreateInput, clientUncheckedCreateInput>
  }


  /**
   * client createMany
   */
  export type clientCreateManyArgs = {
    data: Enumerable<clientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * client update
   */
  export type clientUpdateArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * The data needed to update a client.
     * 
    **/
    data: XOR<clientUpdateInput, clientUncheckedUpdateInput>
    /**
     * Choose, which client to update.
     * 
    **/
    where: clientWhereUniqueInput
  }


  /**
   * client updateMany
   */
  export type clientUpdateManyArgs = {
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    where?: clientWhereInput
  }


  /**
   * client upsert
   */
  export type clientUpsertArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * The filter to search for the client to update in case it exists.
     * 
    **/
    where: clientWhereUniqueInput
    /**
     * In case the client found by the `where` argument doesn't exist, create a new client with this data.
     * 
    **/
    create: XOR<clientCreateInput, clientUncheckedCreateInput>
    /**
     * In case the client was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clientUpdateInput, clientUncheckedUpdateInput>
  }


  /**
   * client delete
   */
  export type clientDeleteArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
    /**
     * Filter which client to delete.
     * 
    **/
    where: clientWhereUniqueInput
  }


  /**
   * client deleteMany
   */
  export type clientDeleteManyArgs = {
    where?: clientWhereInput
  }


  /**
   * client without action
   */
  export type clientArgs = {
    /**
     * Select specific fields to fetch from the client
     * 
    **/
    select?: clientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientInclude | null
  }



  /**
   * Model userToken
   */


  export type AggregateUserToken = {
    _count: UserTokenCountAggregateOutputType | null
    count: UserTokenCountAggregateOutputType | null
    _avg: UserTokenAvgAggregateOutputType | null
    avg: UserTokenAvgAggregateOutputType | null
    _sum: UserTokenSumAggregateOutputType | null
    sum: UserTokenSumAggregateOutputType | null
    _min: UserTokenMinAggregateOutputType | null
    min: UserTokenMinAggregateOutputType | null
    _max: UserTokenMaxAggregateOutputType | null
    max: UserTokenMaxAggregateOutputType | null
  }

  export type UserTokenAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type UserTokenSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type UserTokenMinAggregateOutputType = {
    Id: number | null
    UserId: number | null
    Token: string | null
  }

  export type UserTokenMaxAggregateOutputType = {
    Id: number | null
    UserId: number | null
    Token: string | null
  }

  export type UserTokenCountAggregateOutputType = {
    Id: number
    UserId: number
    Token: number
    _all: number
  }


  export type UserTokenAvgAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type UserTokenSumAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type UserTokenMinAggregateInputType = {
    Id?: true
    UserId?: true
    Token?: true
  }

  export type UserTokenMaxAggregateInputType = {
    Id?: true
    UserId?: true
    Token?: true
  }

  export type UserTokenCountAggregateInputType = {
    Id?: true
    UserId?: true
    Token?: true
    _all?: true
  }

  export type UserTokenAggregateArgs = {
    /**
     * Filter which userToken to aggregate.
     * 
    **/
    where?: userTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<userTokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: userTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userTokens
    **/
    _count?: true | UserTokenCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTokenAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTokenSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTokenMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTokenMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserTokenMaxAggregateInputType
  }

  export type GetUserTokenAggregateType<T extends UserTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToken[P]>
      : GetScalarType<T[P], AggregateUserToken[P]>
  }


    
    
  export type UserTokenGroupByArgs = {
    where?: userTokenWhereInput
    orderBy?: Enumerable<userTokenOrderByInput>
    by: Array<UserTokenScalarFieldEnum>
    having?: userTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTokenCountAggregateInputType | true
    _avg?: UserTokenAvgAggregateInputType
    _sum?: UserTokenSumAggregateInputType
    _min?: UserTokenMinAggregateInputType
    _max?: UserTokenMaxAggregateInputType
  }


  export type UserTokenGroupByOutputType = {
    Id: number
    UserId: number
    Token: string
    _count: UserTokenCountAggregateOutputType | null
    _avg: UserTokenAvgAggregateOutputType | null
    _sum: UserTokenSumAggregateOutputType | null
    _min: UserTokenMinAggregateOutputType | null
    _max: UserTokenMaxAggregateOutputType | null
  }

  type GetUserTokenGroupByPayload<T extends UserTokenGroupByArgs> = Promise<
    Array<
      PickArray<UserTokenGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserTokenGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserTokenGroupByOutputType[P]> 
            : GetScalarType<T[P], UserTokenGroupByOutputType[P]>
        }
      > 
    >


  export type userTokenSelect = {
    Id?: boolean
    UserId?: boolean
    Token?: boolean
    User?: boolean | userArgs
  }

  export type userTokenInclude = {
    User?: boolean | userArgs
  }

  export type userTokenGetPayload<
    S extends boolean | null | undefined | userTokenArgs,
    U = keyof S
      > = S extends true
        ? userToken
    : S extends undefined
    ? never
    : S extends userTokenArgs | userTokenFindManyArgs
    ?'include' extends U
    ? userToken  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof userToken ?userToken [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> | null : never
  } 
    : userToken
  : userToken


  type userTokenCountArgs = Merge<
    Omit<userTokenFindManyArgs, 'select' | 'include'> & {
      select?: UserTokenCountAggregateInputType | true
    }
  >

  export interface userTokenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserToken that matches the filter.
     * @param {userTokenFindUniqueArgs} args - Arguments to find a UserToken
     * @example
     * // Get one UserToken
     * const userToken = await prisma.userToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'userToken'> extends True ? CheckSelect<T, Prisma__userTokenClient<userToken>, Prisma__userTokenClient<userTokenGetPayload<T>>> : CheckSelect<T, Prisma__userTokenClient<userToken | null >, Prisma__userTokenClient<userTokenGetPayload<T> | null >>

    /**
     * Find the first UserToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokenFindFirstArgs} args - Arguments to find a UserToken
     * @example
     * // Get one UserToken
     * const userToken = await prisma.userToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'userToken'> extends True ? CheckSelect<T, Prisma__userTokenClient<userToken>, Prisma__userTokenClient<userTokenGetPayload<T>>> : CheckSelect<T, Prisma__userTokenClient<userToken | null >, Prisma__userTokenClient<userTokenGetPayload<T> | null >>

    /**
     * Find zero or more UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTokens
     * const userTokens = await prisma.userToken.findMany()
     * 
     * // Get first 10 UserTokens
     * const userTokens = await prisma.userToken.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userTokenWithIdOnly = await prisma.userToken.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends userTokenFindManyArgs>(
      args?: SelectSubset<T, userTokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<userToken>>, PrismaPromise<Array<userTokenGetPayload<T>>>>

    /**
     * Create a UserToken.
     * @param {userTokenCreateArgs} args - Arguments to create a UserToken.
     * @example
     * // Create one UserToken
     * const UserToken = await prisma.userToken.create({
     *   data: {
     *     // ... data to create a UserToken
     *   }
     * })
     * 
    **/
    create<T extends userTokenCreateArgs>(
      args: SelectSubset<T, userTokenCreateArgs>
    ): CheckSelect<T, Prisma__userTokenClient<userToken>, Prisma__userTokenClient<userTokenGetPayload<T>>>

    /**
     * Create many UserTokens.
     *     @param {userTokenCreateManyArgs} args - Arguments to create many UserTokens.
     *     @example
     *     // Create many UserTokens
     *     const userToken = await prisma.userToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userTokenCreateManyArgs>(
      args?: SelectSubset<T, userTokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserToken.
     * @param {userTokenDeleteArgs} args - Arguments to delete one UserToken.
     * @example
     * // Delete one UserToken
     * const UserToken = await prisma.userToken.delete({
     *   where: {
     *     // ... filter to delete one UserToken
     *   }
     * })
     * 
    **/
    delete<T extends userTokenDeleteArgs>(
      args: SelectSubset<T, userTokenDeleteArgs>
    ): CheckSelect<T, Prisma__userTokenClient<userToken>, Prisma__userTokenClient<userTokenGetPayload<T>>>

    /**
     * Update one UserToken.
     * @param {userTokenUpdateArgs} args - Arguments to update one UserToken.
     * @example
     * // Update one UserToken
     * const userToken = await prisma.userToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userTokenUpdateArgs>(
      args: SelectSubset<T, userTokenUpdateArgs>
    ): CheckSelect<T, Prisma__userTokenClient<userToken>, Prisma__userTokenClient<userTokenGetPayload<T>>>

    /**
     * Delete zero or more UserTokens.
     * @param {userTokenDeleteManyArgs} args - Arguments to filter UserTokens to delete.
     * @example
     * // Delete a few UserTokens
     * const { count } = await prisma.userToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userTokenDeleteManyArgs>(
      args?: SelectSubset<T, userTokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTokens
     * const userToken = await prisma.userToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userTokenUpdateManyArgs>(
      args: SelectSubset<T, userTokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToken.
     * @param {userTokenUpsertArgs} args - Arguments to update or create a UserToken.
     * @example
     * // Update or create a UserToken
     * const userToken = await prisma.userToken.upsert({
     *   create: {
     *     // ... data to create a UserToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToken we want to update
     *   }
     * })
    **/
    upsert<T extends userTokenUpsertArgs>(
      args: SelectSubset<T, userTokenUpsertArgs>
    ): CheckSelect<T, Prisma__userTokenClient<userToken>, Prisma__userTokenClient<userTokenGetPayload<T>>>

    /**
     * Count the number of UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokenCountArgs} args - Arguments to filter UserTokens to count.
     * @example
     * // Count the number of UserTokens
     * const count = await prisma.userToken.count({
     *   where: {
     *     // ... the filter for the UserTokens we want to count
     *   }
     * })
    **/
    count<T extends userTokenCountArgs>(
      args?: Subset<T, userTokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTokenAggregateArgs>(args: Subset<T, UserTokenAggregateArgs>): PrismaPromise<GetUserTokenAggregateType<T>>

    /**
     * Group by UserToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTokenGroupByArgs['orderBy'] }
        : { orderBy?: UserTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTokenGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for userToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userTokenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * userToken findUnique
   */
  export type userTokenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
    /**
     * Throw an Error if a userToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which userToken to fetch.
     * 
    **/
    where: userTokenWhereUniqueInput
  }


  /**
   * userToken findFirst
   */
  export type userTokenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
    /**
     * Throw an Error if a userToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which userToken to fetch.
     * 
    **/
    where?: userTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<userTokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userTokens.
     * 
    **/
    cursor?: userTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userTokens.
     * 
    **/
    distinct?: Enumerable<UserTokenScalarFieldEnum>
  }


  /**
   * userToken findMany
   */
  export type userTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
    /**
     * Filter, which userTokens to fetch.
     * 
    **/
    where?: userTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<userTokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userTokens.
     * 
    **/
    cursor?: userTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserTokenScalarFieldEnum>
  }


  /**
   * userToken create
   */
  export type userTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
    /**
     * The data needed to create a userToken.
     * 
    **/
    data: XOR<userTokenCreateInput, userTokenUncheckedCreateInput>
  }


  /**
   * userToken createMany
   */
  export type userTokenCreateManyArgs = {
    data: Enumerable<userTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * userToken update
   */
  export type userTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
    /**
     * The data needed to update a userToken.
     * 
    **/
    data: XOR<userTokenUpdateInput, userTokenUncheckedUpdateInput>
    /**
     * Choose, which userToken to update.
     * 
    **/
    where: userTokenWhereUniqueInput
  }


  /**
   * userToken updateMany
   */
  export type userTokenUpdateManyArgs = {
    data: XOR<userTokenUpdateManyMutationInput, userTokenUncheckedUpdateManyInput>
    where?: userTokenWhereInput
  }


  /**
   * userToken upsert
   */
  export type userTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
    /**
     * The filter to search for the userToken to update in case it exists.
     * 
    **/
    where: userTokenWhereUniqueInput
    /**
     * In case the userToken found by the `where` argument doesn't exist, create a new userToken with this data.
     * 
    **/
    create: XOR<userTokenCreateInput, userTokenUncheckedCreateInput>
    /**
     * In case the userToken was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<userTokenUpdateInput, userTokenUncheckedUpdateInput>
  }


  /**
   * userToken delete
   */
  export type userTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
    /**
     * Filter which userToken to delete.
     * 
    **/
    where: userTokenWhereUniqueInput
  }


  /**
   * userToken deleteMany
   */
  export type userTokenDeleteManyArgs = {
    where?: userTokenWhereInput
  }


  /**
   * userToken without action
   */
  export type userTokenArgs = {
    /**
     * Select specific fields to fetch from the userToken
     * 
    **/
    select?: userTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userTokenInclude | null
  }



  /**
   * Model clientContact
   */


  export type AggregateClientContact = {
    _count: ClientContactCountAggregateOutputType | null
    count: ClientContactCountAggregateOutputType | null
    _avg: ClientContactAvgAggregateOutputType | null
    avg: ClientContactAvgAggregateOutputType | null
    _sum: ClientContactSumAggregateOutputType | null
    sum: ClientContactSumAggregateOutputType | null
    _min: ClientContactMinAggregateOutputType | null
    min: ClientContactMinAggregateOutputType | null
    _max: ClientContactMaxAggregateOutputType | null
    max: ClientContactMaxAggregateOutputType | null
  }

  export type ClientContactAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    ClientId: number | null
  }

  export type ClientContactSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    ClientId: number | null
  }

  export type ClientContactMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Position: string | null
    PhoneNumber: string | null
    Email: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ClientId: number | null
  }

  export type ClientContactMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Position: string | null
    PhoneNumber: string | null
    Email: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ClientId: number | null
  }

  export type ClientContactCountAggregateOutputType = {
    Id: number
    Name: number
    Position: number
    PhoneNumber: number
    Email: number
    CreatedBy: number
    CreatedDate: number
    ClientId: number
    _all: number
  }


  export type ClientContactAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
    ClientId?: true
  }

  export type ClientContactSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
    ClientId?: true
  }

  export type ClientContactMinAggregateInputType = {
    Id?: true
    Name?: true
    Position?: true
    PhoneNumber?: true
    Email?: true
    CreatedBy?: true
    CreatedDate?: true
    ClientId?: true
  }

  export type ClientContactMaxAggregateInputType = {
    Id?: true
    Name?: true
    Position?: true
    PhoneNumber?: true
    Email?: true
    CreatedBy?: true
    CreatedDate?: true
    ClientId?: true
  }

  export type ClientContactCountAggregateInputType = {
    Id?: true
    Name?: true
    Position?: true
    PhoneNumber?: true
    Email?: true
    CreatedBy?: true
    CreatedDate?: true
    ClientId?: true
    _all?: true
  }

  export type ClientContactAggregateArgs = {
    /**
     * Filter which clientContact to aggregate.
     * 
    **/
    where?: clientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<clientContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientContacts
    **/
    _count?: true | ClientContactCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ClientContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientContactAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ClientContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientContactSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ClientContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContactMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ClientContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContactMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ClientContactMaxAggregateInputType
  }

  export type GetClientContactAggregateType<T extends ClientContactAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContact[P]>
      : GetScalarType<T[P], AggregateClientContact[P]>
  }


    
    
  export type ClientContactGroupByArgs = {
    where?: clientContactWhereInput
    orderBy?: Enumerable<clientContactOrderByInput>
    by: Array<ClientContactScalarFieldEnum>
    having?: clientContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContactCountAggregateInputType | true
    _avg?: ClientContactAvgAggregateInputType
    _sum?: ClientContactSumAggregateInputType
    _min?: ClientContactMinAggregateInputType
    _max?: ClientContactMaxAggregateInputType
  }


  export type ClientContactGroupByOutputType = {
    Id: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate: Date
    ClientId: number
    _count: ClientContactCountAggregateOutputType | null
    _avg: ClientContactAvgAggregateOutputType | null
    _sum: ClientContactSumAggregateOutputType | null
    _min: ClientContactMinAggregateOutputType | null
    _max: ClientContactMaxAggregateOutputType | null
  }

  type GetClientContactGroupByPayload<T extends ClientContactGroupByArgs> = Promise<
    Array<
      PickArray<ClientContactGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ClientContactGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ClientContactGroupByOutputType[P]> 
            : GetScalarType<T[P], ClientContactGroupByOutputType[P]>
        }
      > 
    >


  export type clientContactSelect = {
    Id?: boolean
    Name?: boolean
    Position?: boolean
    PhoneNumber?: boolean
    Email?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Client?: boolean | clientArgs
    ClientId?: boolean
    User?: boolean | userArgs
  }

  export type clientContactInclude = {
    Client?: boolean | clientArgs
    User?: boolean | userArgs
  }

  export type clientContactGetPayload<
    S extends boolean | null | undefined | clientContactArgs,
    U = keyof S
      > = S extends true
        ? clientContact
    : S extends undefined
    ? never
    : S extends clientContactArgs | clientContactFindManyArgs
    ?'include' extends U
    ? clientContact  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Client'
        ? clientGetPayload<S['include'][P]> :
        P extends 'User'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof clientContact ?clientContact [P]
  : 
          P extends 'Client'
        ? clientGetPayload<S['select'][P]> :
        P extends 'User'
        ? userGetPayload<S['select'][P]> : never
  } 
    : clientContact
  : clientContact


  type clientContactCountArgs = Merge<
    Omit<clientContactFindManyArgs, 'select' | 'include'> & {
      select?: ClientContactCountAggregateInputType | true
    }
  >

  export interface clientContactDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ClientContact that matches the filter.
     * @param {clientContactFindUniqueArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientContactFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clientContactFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'clientContact'> extends True ? CheckSelect<T, Prisma__clientContactClient<clientContact>, Prisma__clientContactClient<clientContactGetPayload<T>>> : CheckSelect<T, Prisma__clientContactClient<clientContact | null >, Prisma__clientContactClient<clientContactGetPayload<T> | null >>

    /**
     * Find the first ClientContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientContactFindFirstArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientContactFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clientContactFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'clientContact'> extends True ? CheckSelect<T, Prisma__clientContactClient<clientContact>, Prisma__clientContactClient<clientContactGetPayload<T>>> : CheckSelect<T, Prisma__clientContactClient<clientContact | null >, Prisma__clientContactClient<clientContactGetPayload<T> | null >>

    /**
     * Find zero or more ClientContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContacts
     * const clientContacts = await prisma.clientContact.findMany()
     * 
     * // Get first 10 ClientContacts
     * const clientContacts = await prisma.clientContact.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const clientContactWithIdOnly = await prisma.clientContact.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends clientContactFindManyArgs>(
      args?: SelectSubset<T, clientContactFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<clientContact>>, PrismaPromise<Array<clientContactGetPayload<T>>>>

    /**
     * Create a ClientContact.
     * @param {clientContactCreateArgs} args - Arguments to create a ClientContact.
     * @example
     * // Create one ClientContact
     * const ClientContact = await prisma.clientContact.create({
     *   data: {
     *     // ... data to create a ClientContact
     *   }
     * })
     * 
    **/
    create<T extends clientContactCreateArgs>(
      args: SelectSubset<T, clientContactCreateArgs>
    ): CheckSelect<T, Prisma__clientContactClient<clientContact>, Prisma__clientContactClient<clientContactGetPayload<T>>>

    /**
     * Create many ClientContacts.
     *     @param {clientContactCreateManyArgs} args - Arguments to create many ClientContacts.
     *     @example
     *     // Create many ClientContacts
     *     const clientContact = await prisma.clientContact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientContactCreateManyArgs>(
      args?: SelectSubset<T, clientContactCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContact.
     * @param {clientContactDeleteArgs} args - Arguments to delete one ClientContact.
     * @example
     * // Delete one ClientContact
     * const ClientContact = await prisma.clientContact.delete({
     *   where: {
     *     // ... filter to delete one ClientContact
     *   }
     * })
     * 
    **/
    delete<T extends clientContactDeleteArgs>(
      args: SelectSubset<T, clientContactDeleteArgs>
    ): CheckSelect<T, Prisma__clientContactClient<clientContact>, Prisma__clientContactClient<clientContactGetPayload<T>>>

    /**
     * Update one ClientContact.
     * @param {clientContactUpdateArgs} args - Arguments to update one ClientContact.
     * @example
     * // Update one ClientContact
     * const clientContact = await prisma.clientContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientContactUpdateArgs>(
      args: SelectSubset<T, clientContactUpdateArgs>
    ): CheckSelect<T, Prisma__clientContactClient<clientContact>, Prisma__clientContactClient<clientContactGetPayload<T>>>

    /**
     * Delete zero or more ClientContacts.
     * @param {clientContactDeleteManyArgs} args - Arguments to filter ClientContacts to delete.
     * @example
     * // Delete a few ClientContacts
     * const { count } = await prisma.clientContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientContactDeleteManyArgs>(
      args?: SelectSubset<T, clientContactDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContacts
     * const clientContact = await prisma.clientContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientContactUpdateManyArgs>(
      args: SelectSubset<T, clientContactUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContact.
     * @param {clientContactUpsertArgs} args - Arguments to update or create a ClientContact.
     * @example
     * // Update or create a ClientContact
     * const clientContact = await prisma.clientContact.upsert({
     *   create: {
     *     // ... data to create a ClientContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContact we want to update
     *   }
     * })
    **/
    upsert<T extends clientContactUpsertArgs>(
      args: SelectSubset<T, clientContactUpsertArgs>
    ): CheckSelect<T, Prisma__clientContactClient<clientContact>, Prisma__clientContactClient<clientContactGetPayload<T>>>

    /**
     * Count the number of ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientContactCountArgs} args - Arguments to filter ClientContacts to count.
     * @example
     * // Count the number of ClientContacts
     * const count = await prisma.clientContact.count({
     *   where: {
     *     // ... the filter for the ClientContacts we want to count
     *   }
     * })
    **/
    count<T extends clientContactCountArgs>(
      args?: Subset<T, clientContactCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContactAggregateArgs>(args: Subset<T, ClientContactAggregateArgs>): PrismaPromise<GetClientContactAggregateType<T>>

    /**
     * Group by ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContactGroupByArgs['orderBy'] }
        : { orderBy?: ClientContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContactGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientContactClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Client<T extends clientArgs = {}>(args?: Subset<T, clientArgs>): CheckSelect<T, Prisma__clientClient<client | null >, Prisma__clientClient<clientGetPayload<T> | null >>;

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * clientContact findUnique
   */
  export type clientContactFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
    /**
     * Throw an Error if a clientContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientContact to fetch.
     * 
    **/
    where: clientContactWhereUniqueInput
  }


  /**
   * clientContact findFirst
   */
  export type clientContactFindFirstArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
    /**
     * Throw an Error if a clientContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientContact to fetch.
     * 
    **/
    where?: clientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<clientContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientContacts.
     * 
    **/
    cursor?: clientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientContacts.
     * 
    **/
    distinct?: Enumerable<ClientContactScalarFieldEnum>
  }


  /**
   * clientContact findMany
   */
  export type clientContactFindManyArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
    /**
     * Filter, which clientContacts to fetch.
     * 
    **/
    where?: clientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<clientContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientContacts.
     * 
    **/
    cursor?: clientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientContacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientContactScalarFieldEnum>
  }


  /**
   * clientContact create
   */
  export type clientContactCreateArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
    /**
     * The data needed to create a clientContact.
     * 
    **/
    data: XOR<clientContactCreateInput, clientContactUncheckedCreateInput>
  }


  /**
   * clientContact createMany
   */
  export type clientContactCreateManyArgs = {
    data: Enumerable<clientContactCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * clientContact update
   */
  export type clientContactUpdateArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
    /**
     * The data needed to update a clientContact.
     * 
    **/
    data: XOR<clientContactUpdateInput, clientContactUncheckedUpdateInput>
    /**
     * Choose, which clientContact to update.
     * 
    **/
    where: clientContactWhereUniqueInput
  }


  /**
   * clientContact updateMany
   */
  export type clientContactUpdateManyArgs = {
    data: XOR<clientContactUpdateManyMutationInput, clientContactUncheckedUpdateManyInput>
    where?: clientContactWhereInput
  }


  /**
   * clientContact upsert
   */
  export type clientContactUpsertArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
    /**
     * The filter to search for the clientContact to update in case it exists.
     * 
    **/
    where: clientContactWhereUniqueInput
    /**
     * In case the clientContact found by the `where` argument doesn't exist, create a new clientContact with this data.
     * 
    **/
    create: XOR<clientContactCreateInput, clientContactUncheckedCreateInput>
    /**
     * In case the clientContact was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clientContactUpdateInput, clientContactUncheckedUpdateInput>
  }


  /**
   * clientContact delete
   */
  export type clientContactDeleteArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
    /**
     * Filter which clientContact to delete.
     * 
    **/
    where: clientContactWhereUniqueInput
  }


  /**
   * clientContact deleteMany
   */
  export type clientContactDeleteManyArgs = {
    where?: clientContactWhereInput
  }


  /**
   * clientContact without action
   */
  export type clientContactArgs = {
    /**
     * Select specific fields to fetch from the clientContact
     * 
    **/
    select?: clientContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientContactInclude | null
  }



  /**
   * Model codeProject
   */


  export type AggregateCodeProject = {
    _count: CodeProjectCountAggregateOutputType | null
    count: CodeProjectCountAggregateOutputType | null
    _avg: CodeProjectAvgAggregateOutputType | null
    avg: CodeProjectAvgAggregateOutputType | null
    _sum: CodeProjectSumAggregateOutputType | null
    sum: CodeProjectSumAggregateOutputType | null
    _min: CodeProjectMinAggregateOutputType | null
    min: CodeProjectMinAggregateOutputType | null
    _max: CodeProjectMaxAggregateOutputType | null
    max: CodeProjectMaxAggregateOutputType | null
  }

  export type CodeProjectAvgAggregateOutputType = {
    Id: number | null
    ClientId: number | null
    CreatedBy: number | null
    ConfirmedBy: number | null
    CompletedBy: number | null
  }

  export type CodeProjectSumAggregateOutputType = {
    Id: number | null
    ClientId: number | null
    CreatedBy: number | null
    ConfirmedBy: number | null
    CompletedBy: number | null
  }

  export type CodeProjectMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    ClientId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ConfirmedDate: Date | null
    ConfirmedBy: number | null
    Address: string | null
    DocumentName: string | null
    IsCompleted: boolean | null
    CompletedDate: Date | null
    CompletedBy: number | null
    IsDelete: boolean | null
  }

  export type CodeProjectMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    ClientId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    ConfirmedDate: Date | null
    ConfirmedBy: number | null
    Address: string | null
    DocumentName: string | null
    IsCompleted: boolean | null
    CompletedDate: Date | null
    CompletedBy: number | null
    IsDelete: boolean | null
  }

  export type CodeProjectCountAggregateOutputType = {
    Id: number
    Name: number
    ClientId: number
    CreatedBy: number
    CreatedDate: number
    ConfirmedDate: number
    ConfirmedBy: number
    Address: number
    DocumentName: number
    IsCompleted: number
    CompletedDate: number
    CompletedBy: number
    IsDelete: number
    _all: number
  }


  export type CodeProjectAvgAggregateInputType = {
    Id?: true
    ClientId?: true
    CreatedBy?: true
    ConfirmedBy?: true
    CompletedBy?: true
  }

  export type CodeProjectSumAggregateInputType = {
    Id?: true
    ClientId?: true
    CreatedBy?: true
    ConfirmedBy?: true
    CompletedBy?: true
  }

  export type CodeProjectMinAggregateInputType = {
    Id?: true
    Name?: true
    ClientId?: true
    CreatedBy?: true
    CreatedDate?: true
    ConfirmedDate?: true
    ConfirmedBy?: true
    Address?: true
    DocumentName?: true
    IsCompleted?: true
    CompletedDate?: true
    CompletedBy?: true
    IsDelete?: true
  }

  export type CodeProjectMaxAggregateInputType = {
    Id?: true
    Name?: true
    ClientId?: true
    CreatedBy?: true
    CreatedDate?: true
    ConfirmedDate?: true
    ConfirmedBy?: true
    Address?: true
    DocumentName?: true
    IsCompleted?: true
    CompletedDate?: true
    CompletedBy?: true
    IsDelete?: true
  }

  export type CodeProjectCountAggregateInputType = {
    Id?: true
    Name?: true
    ClientId?: true
    CreatedBy?: true
    CreatedDate?: true
    ConfirmedDate?: true
    ConfirmedBy?: true
    Address?: true
    DocumentName?: true
    IsCompleted?: true
    CompletedDate?: true
    CompletedBy?: true
    IsDelete?: true
    _all?: true
  }

  export type CodeProjectAggregateArgs = {
    /**
     * Filter which codeProject to aggregate.
     * 
    **/
    where?: codeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjects to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: codeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned codeProjects
    **/
    _count?: true | CodeProjectCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeProjectAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeProjectSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeProjectMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeProjectMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeProjectMaxAggregateInputType
  }

  export type GetCodeProjectAggregateType<T extends CodeProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeProject[P]>
      : GetScalarType<T[P], AggregateCodeProject[P]>
  }


    
    
  export type CodeProjectGroupByArgs = {
    where?: codeProjectWhereInput
    orderBy?: Enumerable<codeProjectOrderByInput>
    by: Array<CodeProjectScalarFieldEnum>
    having?: codeProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeProjectCountAggregateInputType | true
    _avg?: CodeProjectAvgAggregateInputType
    _sum?: CodeProjectSumAggregateInputType
    _min?: CodeProjectMinAggregateInputType
    _max?: CodeProjectMaxAggregateInputType
  }


  export type CodeProjectGroupByOutputType = {
    Id: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate: Date
    ConfirmedDate: Date | null
    ConfirmedBy: number | null
    Address: string
    DocumentName: string
    IsCompleted: boolean
    CompletedDate: Date | null
    CompletedBy: number | null
    IsDelete: boolean
    _count: CodeProjectCountAggregateOutputType | null
    _avg: CodeProjectAvgAggregateOutputType | null
    _sum: CodeProjectSumAggregateOutputType | null
    _min: CodeProjectMinAggregateOutputType | null
    _max: CodeProjectMaxAggregateOutputType | null
  }

  type GetCodeProjectGroupByPayload<T extends CodeProjectGroupByArgs> = Promise<
    Array<
      PickArray<CodeProjectGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeProjectGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeProjectGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeProjectGroupByOutputType[P]>
        }
      > 
    >


  export type codeProjectSelect = {
    Id?: boolean
    Name?: boolean
    ClientId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    ConfirmedDate?: boolean
    ConfirmedBy?: boolean
    Address?: boolean
    DocumentName?: boolean
    IsCompleted?: boolean
    CompletedDate?: boolean
    CompletedBy?: boolean
    IsDelete?: boolean
    Client?: boolean | clientArgs
    User1?: boolean | userArgs
    User2?: boolean | userArgs
    User3?: boolean | userArgs
    CodeProjectDocument?: boolean | codeProjectDocumentFindManyArgs
    CodeProjectUser?: boolean | codeProjectUserFindManyArgs
    CodeReport?: boolean | codeReportFindManyArgs
    Project?: boolean | projectFindManyArgs
  }

  export type codeProjectInclude = {
    Client?: boolean | clientArgs
    User1?: boolean | userArgs
    User2?: boolean | userArgs
    User3?: boolean | userArgs
    CodeProjectDocument?: boolean | codeProjectDocumentFindManyArgs
    CodeProjectUser?: boolean | codeProjectUserFindManyArgs
    CodeReport?: boolean | codeReportFindManyArgs
    Project?: boolean | projectFindManyArgs
  }

  export type codeProjectGetPayload<
    S extends boolean | null | undefined | codeProjectArgs,
    U = keyof S
      > = S extends true
        ? codeProject
    : S extends undefined
    ? never
    : S extends codeProjectArgs | codeProjectFindManyArgs
    ?'include' extends U
    ? codeProject  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Client'
        ? clientGetPayload<S['include'][P]> :
        P extends 'User1'
        ? userGetPayload<S['include'][P]> :
        P extends 'User2'
        ? userGetPayload<S['include'][P]> | null :
        P extends 'User3'
        ? userGetPayload<S['include'][P]> | null :
        P extends 'CodeProjectDocument'
        ? Array < codeProjectDocumentGetPayload<S['include'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < codeProjectUserGetPayload<S['include'][P]>>  :
        P extends 'CodeReport'
        ? Array < codeReportGetPayload<S['include'][P]>>  :
        P extends 'Project'
        ? Array < projectGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof codeProject ?codeProject [P]
  : 
          P extends 'Client'
        ? clientGetPayload<S['select'][P]> :
        P extends 'User1'
        ? userGetPayload<S['select'][P]> :
        P extends 'User2'
        ? userGetPayload<S['select'][P]> | null :
        P extends 'User3'
        ? userGetPayload<S['select'][P]> | null :
        P extends 'CodeProjectDocument'
        ? Array < codeProjectDocumentGetPayload<S['select'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < codeProjectUserGetPayload<S['select'][P]>>  :
        P extends 'CodeReport'
        ? Array < codeReportGetPayload<S['select'][P]>>  :
        P extends 'Project'
        ? Array < projectGetPayload<S['select'][P]>>  : never
  } 
    : codeProject
  : codeProject


  type codeProjectCountArgs = Merge<
    Omit<codeProjectFindManyArgs, 'select' | 'include'> & {
      select?: CodeProjectCountAggregateInputType | true
    }
  >

  export interface codeProjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeProject that matches the filter.
     * @param {codeProjectFindUniqueArgs} args - Arguments to find a CodeProject
     * @example
     * // Get one CodeProject
     * const codeProject = await prisma.codeProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends codeProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, codeProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'codeProject'> extends True ? CheckSelect<T, Prisma__codeProjectClient<codeProject>, Prisma__codeProjectClient<codeProjectGetPayload<T>>> : CheckSelect<T, Prisma__codeProjectClient<codeProject | null >, Prisma__codeProjectClient<codeProjectGetPayload<T> | null >>

    /**
     * Find the first CodeProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectFindFirstArgs} args - Arguments to find a CodeProject
     * @example
     * // Get one CodeProject
     * const codeProject = await prisma.codeProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends codeProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, codeProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'codeProject'> extends True ? CheckSelect<T, Prisma__codeProjectClient<codeProject>, Prisma__codeProjectClient<codeProjectGetPayload<T>>> : CheckSelect<T, Prisma__codeProjectClient<codeProject | null >, Prisma__codeProjectClient<codeProjectGetPayload<T> | null >>

    /**
     * Find zero or more CodeProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeProjects
     * const codeProjects = await prisma.codeProject.findMany()
     * 
     * // Get first 10 CodeProjects
     * const codeProjects = await prisma.codeProject.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeProjectWithIdOnly = await prisma.codeProject.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends codeProjectFindManyArgs>(
      args?: SelectSubset<T, codeProjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<codeProject>>, PrismaPromise<Array<codeProjectGetPayload<T>>>>

    /**
     * Create a CodeProject.
     * @param {codeProjectCreateArgs} args - Arguments to create a CodeProject.
     * @example
     * // Create one CodeProject
     * const CodeProject = await prisma.codeProject.create({
     *   data: {
     *     // ... data to create a CodeProject
     *   }
     * })
     * 
    **/
    create<T extends codeProjectCreateArgs>(
      args: SelectSubset<T, codeProjectCreateArgs>
    ): CheckSelect<T, Prisma__codeProjectClient<codeProject>, Prisma__codeProjectClient<codeProjectGetPayload<T>>>

    /**
     * Create many CodeProjects.
     *     @param {codeProjectCreateManyArgs} args - Arguments to create many CodeProjects.
     *     @example
     *     // Create many CodeProjects
     *     const codeProject = await prisma.codeProject.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends codeProjectCreateManyArgs>(
      args?: SelectSubset<T, codeProjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeProject.
     * @param {codeProjectDeleteArgs} args - Arguments to delete one CodeProject.
     * @example
     * // Delete one CodeProject
     * const CodeProject = await prisma.codeProject.delete({
     *   where: {
     *     // ... filter to delete one CodeProject
     *   }
     * })
     * 
    **/
    delete<T extends codeProjectDeleteArgs>(
      args: SelectSubset<T, codeProjectDeleteArgs>
    ): CheckSelect<T, Prisma__codeProjectClient<codeProject>, Prisma__codeProjectClient<codeProjectGetPayload<T>>>

    /**
     * Update one CodeProject.
     * @param {codeProjectUpdateArgs} args - Arguments to update one CodeProject.
     * @example
     * // Update one CodeProject
     * const codeProject = await prisma.codeProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends codeProjectUpdateArgs>(
      args: SelectSubset<T, codeProjectUpdateArgs>
    ): CheckSelect<T, Prisma__codeProjectClient<codeProject>, Prisma__codeProjectClient<codeProjectGetPayload<T>>>

    /**
     * Delete zero or more CodeProjects.
     * @param {codeProjectDeleteManyArgs} args - Arguments to filter CodeProjects to delete.
     * @example
     * // Delete a few CodeProjects
     * const { count } = await prisma.codeProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends codeProjectDeleteManyArgs>(
      args?: SelectSubset<T, codeProjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeProjects
     * const codeProject = await prisma.codeProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends codeProjectUpdateManyArgs>(
      args: SelectSubset<T, codeProjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeProject.
     * @param {codeProjectUpsertArgs} args - Arguments to update or create a CodeProject.
     * @example
     * // Update or create a CodeProject
     * const codeProject = await prisma.codeProject.upsert({
     *   create: {
     *     // ... data to create a CodeProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeProject we want to update
     *   }
     * })
    **/
    upsert<T extends codeProjectUpsertArgs>(
      args: SelectSubset<T, codeProjectUpsertArgs>
    ): CheckSelect<T, Prisma__codeProjectClient<codeProject>, Prisma__codeProjectClient<codeProjectGetPayload<T>>>

    /**
     * Count the number of CodeProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectCountArgs} args - Arguments to filter CodeProjects to count.
     * @example
     * // Count the number of CodeProjects
     * const count = await prisma.codeProject.count({
     *   where: {
     *     // ... the filter for the CodeProjects we want to count
     *   }
     * })
    **/
    count<T extends codeProjectCountArgs>(
      args?: Subset<T, codeProjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeProjectAggregateArgs>(args: Subset<T, CodeProjectAggregateArgs>): PrismaPromise<GetCodeProjectAggregateType<T>>

    /**
     * Group by CodeProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeProjectGroupByArgs['orderBy'] }
        : { orderBy?: CodeProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeProjectGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for codeProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__codeProjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Client<T extends clientArgs = {}>(args?: Subset<T, clientArgs>): CheckSelect<T, Prisma__clientClient<client | null >, Prisma__clientClient<clientGetPayload<T> | null >>;

    User1<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    User2<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    User3<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    CodeProjectDocument<T extends codeProjectDocumentFindManyArgs = {}>(args?: Subset<T, codeProjectDocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProjectDocument>>, PrismaPromise<Array<codeProjectDocumentGetPayload<T>>>>;

    CodeProjectUser<T extends codeProjectUserFindManyArgs = {}>(args?: Subset<T, codeProjectUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProjectUser>>, PrismaPromise<Array<codeProjectUserGetPayload<T>>>>;

    CodeReport<T extends codeReportFindManyArgs = {}>(args?: Subset<T, codeReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeReport>>, PrismaPromise<Array<codeReportGetPayload<T>>>>;

    Project<T extends projectFindManyArgs = {}>(args?: Subset<T, projectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<project>>, PrismaPromise<Array<projectGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * codeProject findUnique
   */
  export type codeProjectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
    /**
     * Throw an Error if a codeProject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeProject to fetch.
     * 
    **/
    where: codeProjectWhereUniqueInput
  }


  /**
   * codeProject findFirst
   */
  export type codeProjectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
    /**
     * Throw an Error if a codeProject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeProject to fetch.
     * 
    **/
    where?: codeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjects to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codeProjects.
     * 
    **/
    cursor?: codeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codeProjects.
     * 
    **/
    distinct?: Enumerable<CodeProjectScalarFieldEnum>
  }


  /**
   * codeProject findMany
   */
  export type codeProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
    /**
     * Filter, which codeProjects to fetch.
     * 
    **/
    where?: codeProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjects to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing codeProjects.
     * 
    **/
    cursor?: codeProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeProjectScalarFieldEnum>
  }


  /**
   * codeProject create
   */
  export type codeProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
    /**
     * The data needed to create a codeProject.
     * 
    **/
    data: XOR<codeProjectCreateInput, codeProjectUncheckedCreateInput>
  }


  /**
   * codeProject createMany
   */
  export type codeProjectCreateManyArgs = {
    data: Enumerable<codeProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * codeProject update
   */
  export type codeProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
    /**
     * The data needed to update a codeProject.
     * 
    **/
    data: XOR<codeProjectUpdateInput, codeProjectUncheckedUpdateInput>
    /**
     * Choose, which codeProject to update.
     * 
    **/
    where: codeProjectWhereUniqueInput
  }


  /**
   * codeProject updateMany
   */
  export type codeProjectUpdateManyArgs = {
    data: XOR<codeProjectUpdateManyMutationInput, codeProjectUncheckedUpdateManyInput>
    where?: codeProjectWhereInput
  }


  /**
   * codeProject upsert
   */
  export type codeProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
    /**
     * The filter to search for the codeProject to update in case it exists.
     * 
    **/
    where: codeProjectWhereUniqueInput
    /**
     * In case the codeProject found by the `where` argument doesn't exist, create a new codeProject with this data.
     * 
    **/
    create: XOR<codeProjectCreateInput, codeProjectUncheckedCreateInput>
    /**
     * In case the codeProject was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<codeProjectUpdateInput, codeProjectUncheckedUpdateInput>
  }


  /**
   * codeProject delete
   */
  export type codeProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
    /**
     * Filter which codeProject to delete.
     * 
    **/
    where: codeProjectWhereUniqueInput
  }


  /**
   * codeProject deleteMany
   */
  export type codeProjectDeleteManyArgs = {
    where?: codeProjectWhereInput
  }


  /**
   * codeProject without action
   */
  export type codeProjectArgs = {
    /**
     * Select specific fields to fetch from the codeProject
     * 
    **/
    select?: codeProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectInclude | null
  }



  /**
   * Model codeProjectDocument
   */


  export type AggregateCodeProjectDocument = {
    _count: CodeProjectDocumentCountAggregateOutputType | null
    count: CodeProjectDocumentCountAggregateOutputType | null
    _avg: CodeProjectDocumentAvgAggregateOutputType | null
    avg: CodeProjectDocumentAvgAggregateOutputType | null
    _sum: CodeProjectDocumentSumAggregateOutputType | null
    sum: CodeProjectDocumentSumAggregateOutputType | null
    _min: CodeProjectDocumentMinAggregateOutputType | null
    min: CodeProjectDocumentMinAggregateOutputType | null
    _max: CodeProjectDocumentMaxAggregateOutputType | null
    max: CodeProjectDocumentMaxAggregateOutputType | null
  }

  export type CodeProjectDocumentAvgAggregateOutputType = {
    Id: number | null
    CodeProjectId: number | null
    CreatedBy: number | null
  }

  export type CodeProjectDocumentSumAggregateOutputType = {
    Id: number | null
    CodeProjectId: number | null
    CreatedBy: number | null
  }

  export type CodeProjectDocumentMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Url: string | null
    CodeProjectId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type CodeProjectDocumentMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Url: string | null
    CodeProjectId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type CodeProjectDocumentCountAggregateOutputType = {
    Id: number
    Name: number
    Url: number
    CodeProjectId: number
    CreatedBy: number
    CreatedDate: number
    _all: number
  }


  export type CodeProjectDocumentAvgAggregateInputType = {
    Id?: true
    CodeProjectId?: true
    CreatedBy?: true
  }

  export type CodeProjectDocumentSumAggregateInputType = {
    Id?: true
    CodeProjectId?: true
    CreatedBy?: true
  }

  export type CodeProjectDocumentMinAggregateInputType = {
    Id?: true
    Name?: true
    Url?: true
    CodeProjectId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type CodeProjectDocumentMaxAggregateInputType = {
    Id?: true
    Name?: true
    Url?: true
    CodeProjectId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type CodeProjectDocumentCountAggregateInputType = {
    Id?: true
    Name?: true
    Url?: true
    CodeProjectId?: true
    CreatedBy?: true
    CreatedDate?: true
    _all?: true
  }

  export type CodeProjectDocumentAggregateArgs = {
    /**
     * Filter which codeProjectDocument to aggregate.
     * 
    **/
    where?: codeProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjectDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: codeProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjectDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjectDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned codeProjectDocuments
    **/
    _count?: true | CodeProjectDocumentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeProjectDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeProjectDocumentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeProjectDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeProjectDocumentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeProjectDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeProjectDocumentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeProjectDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeProjectDocumentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeProjectDocumentMaxAggregateInputType
  }

  export type GetCodeProjectDocumentAggregateType<T extends CodeProjectDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeProjectDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeProjectDocument[P]>
      : GetScalarType<T[P], AggregateCodeProjectDocument[P]>
  }


    
    
  export type CodeProjectDocumentGroupByArgs = {
    where?: codeProjectDocumentWhereInput
    orderBy?: Enumerable<codeProjectDocumentOrderByInput>
    by: Array<CodeProjectDocumentScalarFieldEnum>
    having?: codeProjectDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeProjectDocumentCountAggregateInputType | true
    _avg?: CodeProjectDocumentAvgAggregateInputType
    _sum?: CodeProjectDocumentSumAggregateInputType
    _min?: CodeProjectDocumentMinAggregateInputType
    _max?: CodeProjectDocumentMaxAggregateInputType
  }


  export type CodeProjectDocumentGroupByOutputType = {
    Id: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedBy: number
    CreatedDate: Date
    _count: CodeProjectDocumentCountAggregateOutputType | null
    _avg: CodeProjectDocumentAvgAggregateOutputType | null
    _sum: CodeProjectDocumentSumAggregateOutputType | null
    _min: CodeProjectDocumentMinAggregateOutputType | null
    _max: CodeProjectDocumentMaxAggregateOutputType | null
  }

  type GetCodeProjectDocumentGroupByPayload<T extends CodeProjectDocumentGroupByArgs> = Promise<
    Array<
      PickArray<CodeProjectDocumentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeProjectDocumentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeProjectDocumentGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeProjectDocumentGroupByOutputType[P]>
        }
      > 
    >


  export type codeProjectDocumentSelect = {
    Id?: boolean
    Name?: boolean
    Url?: boolean
    CodeProjectId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    User?: boolean | userArgs
    CodeProject?: boolean | codeProjectArgs
  }

  export type codeProjectDocumentInclude = {
    User?: boolean | userArgs
    CodeProject?: boolean | codeProjectArgs
  }

  export type codeProjectDocumentGetPayload<
    S extends boolean | null | undefined | codeProjectDocumentArgs,
    U = keyof S
      > = S extends true
        ? codeProjectDocument
    : S extends undefined
    ? never
    : S extends codeProjectDocumentArgs | codeProjectDocumentFindManyArgs
    ?'include' extends U
    ? codeProjectDocument  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> :
        P extends 'CodeProject'
        ? codeProjectGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof codeProjectDocument ?codeProjectDocument [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> :
        P extends 'CodeProject'
        ? codeProjectGetPayload<S['select'][P]> : never
  } 
    : codeProjectDocument
  : codeProjectDocument


  type codeProjectDocumentCountArgs = Merge<
    Omit<codeProjectDocumentFindManyArgs, 'select' | 'include'> & {
      select?: CodeProjectDocumentCountAggregateInputType | true
    }
  >

  export interface codeProjectDocumentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeProjectDocument that matches the filter.
     * @param {codeProjectDocumentFindUniqueArgs} args - Arguments to find a CodeProjectDocument
     * @example
     * // Get one CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends codeProjectDocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, codeProjectDocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'codeProjectDocument'> extends True ? CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument>, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T>>> : CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument | null >, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T> | null >>

    /**
     * Find the first CodeProjectDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectDocumentFindFirstArgs} args - Arguments to find a CodeProjectDocument
     * @example
     * // Get one CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends codeProjectDocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, codeProjectDocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'codeProjectDocument'> extends True ? CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument>, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T>>> : CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument | null >, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T> | null >>

    /**
     * Find zero or more CodeProjectDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeProjectDocuments
     * const codeProjectDocuments = await prisma.codeProjectDocument.findMany()
     * 
     * // Get first 10 CodeProjectDocuments
     * const codeProjectDocuments = await prisma.codeProjectDocument.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeProjectDocumentWithIdOnly = await prisma.codeProjectDocument.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends codeProjectDocumentFindManyArgs>(
      args?: SelectSubset<T, codeProjectDocumentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<codeProjectDocument>>, PrismaPromise<Array<codeProjectDocumentGetPayload<T>>>>

    /**
     * Create a CodeProjectDocument.
     * @param {codeProjectDocumentCreateArgs} args - Arguments to create a CodeProjectDocument.
     * @example
     * // Create one CodeProjectDocument
     * const CodeProjectDocument = await prisma.codeProjectDocument.create({
     *   data: {
     *     // ... data to create a CodeProjectDocument
     *   }
     * })
     * 
    **/
    create<T extends codeProjectDocumentCreateArgs>(
      args: SelectSubset<T, codeProjectDocumentCreateArgs>
    ): CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument>, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T>>>

    /**
     * Create many CodeProjectDocuments.
     *     @param {codeProjectDocumentCreateManyArgs} args - Arguments to create many CodeProjectDocuments.
     *     @example
     *     // Create many CodeProjectDocuments
     *     const codeProjectDocument = await prisma.codeProjectDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends codeProjectDocumentCreateManyArgs>(
      args?: SelectSubset<T, codeProjectDocumentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeProjectDocument.
     * @param {codeProjectDocumentDeleteArgs} args - Arguments to delete one CodeProjectDocument.
     * @example
     * // Delete one CodeProjectDocument
     * const CodeProjectDocument = await prisma.codeProjectDocument.delete({
     *   where: {
     *     // ... filter to delete one CodeProjectDocument
     *   }
     * })
     * 
    **/
    delete<T extends codeProjectDocumentDeleteArgs>(
      args: SelectSubset<T, codeProjectDocumentDeleteArgs>
    ): CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument>, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T>>>

    /**
     * Update one CodeProjectDocument.
     * @param {codeProjectDocumentUpdateArgs} args - Arguments to update one CodeProjectDocument.
     * @example
     * // Update one CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends codeProjectDocumentUpdateArgs>(
      args: SelectSubset<T, codeProjectDocumentUpdateArgs>
    ): CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument>, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T>>>

    /**
     * Delete zero or more CodeProjectDocuments.
     * @param {codeProjectDocumentDeleteManyArgs} args - Arguments to filter CodeProjectDocuments to delete.
     * @example
     * // Delete a few CodeProjectDocuments
     * const { count } = await prisma.codeProjectDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends codeProjectDocumentDeleteManyArgs>(
      args?: SelectSubset<T, codeProjectDocumentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeProjectDocuments
     * const codeProjectDocument = await prisma.codeProjectDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends codeProjectDocumentUpdateManyArgs>(
      args: SelectSubset<T, codeProjectDocumentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeProjectDocument.
     * @param {codeProjectDocumentUpsertArgs} args - Arguments to update or create a CodeProjectDocument.
     * @example
     * // Update or create a CodeProjectDocument
     * const codeProjectDocument = await prisma.codeProjectDocument.upsert({
     *   create: {
     *     // ... data to create a CodeProjectDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeProjectDocument we want to update
     *   }
     * })
    **/
    upsert<T extends codeProjectDocumentUpsertArgs>(
      args: SelectSubset<T, codeProjectDocumentUpsertArgs>
    ): CheckSelect<T, Prisma__codeProjectDocumentClient<codeProjectDocument>, Prisma__codeProjectDocumentClient<codeProjectDocumentGetPayload<T>>>

    /**
     * Count the number of CodeProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectDocumentCountArgs} args - Arguments to filter CodeProjectDocuments to count.
     * @example
     * // Count the number of CodeProjectDocuments
     * const count = await prisma.codeProjectDocument.count({
     *   where: {
     *     // ... the filter for the CodeProjectDocuments we want to count
     *   }
     * })
    **/
    count<T extends codeProjectDocumentCountArgs>(
      args?: Subset<T, codeProjectDocumentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeProjectDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeProjectDocumentAggregateArgs>(args: Subset<T, CodeProjectDocumentAggregateArgs>): PrismaPromise<GetCodeProjectDocumentAggregateType<T>>

    /**
     * Group by CodeProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeProjectDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeProjectDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CodeProjectDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeProjectDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeProjectDocumentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for codeProjectDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__codeProjectDocumentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    CodeProject<T extends codeProjectArgs = {}>(args?: Subset<T, codeProjectArgs>): CheckSelect<T, Prisma__codeProjectClient<codeProject | null >, Prisma__codeProjectClient<codeProjectGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * codeProjectDocument findUnique
   */
  export type codeProjectDocumentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
    /**
     * Throw an Error if a codeProjectDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeProjectDocument to fetch.
     * 
    **/
    where: codeProjectDocumentWhereUniqueInput
  }


  /**
   * codeProjectDocument findFirst
   */
  export type codeProjectDocumentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
    /**
     * Throw an Error if a codeProjectDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeProjectDocument to fetch.
     * 
    **/
    where?: codeProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjectDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codeProjectDocuments.
     * 
    **/
    cursor?: codeProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjectDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjectDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codeProjectDocuments.
     * 
    **/
    distinct?: Enumerable<CodeProjectDocumentScalarFieldEnum>
  }


  /**
   * codeProjectDocument findMany
   */
  export type codeProjectDocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
    /**
     * Filter, which codeProjectDocuments to fetch.
     * 
    **/
    where?: codeProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjectDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing codeProjectDocuments.
     * 
    **/
    cursor?: codeProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjectDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjectDocuments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeProjectDocumentScalarFieldEnum>
  }


  /**
   * codeProjectDocument create
   */
  export type codeProjectDocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
    /**
     * The data needed to create a codeProjectDocument.
     * 
    **/
    data: XOR<codeProjectDocumentCreateInput, codeProjectDocumentUncheckedCreateInput>
  }


  /**
   * codeProjectDocument createMany
   */
  export type codeProjectDocumentCreateManyArgs = {
    data: Enumerable<codeProjectDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * codeProjectDocument update
   */
  export type codeProjectDocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
    /**
     * The data needed to update a codeProjectDocument.
     * 
    **/
    data: XOR<codeProjectDocumentUpdateInput, codeProjectDocumentUncheckedUpdateInput>
    /**
     * Choose, which codeProjectDocument to update.
     * 
    **/
    where: codeProjectDocumentWhereUniqueInput
  }


  /**
   * codeProjectDocument updateMany
   */
  export type codeProjectDocumentUpdateManyArgs = {
    data: XOR<codeProjectDocumentUpdateManyMutationInput, codeProjectDocumentUncheckedUpdateManyInput>
    where?: codeProjectDocumentWhereInput
  }


  /**
   * codeProjectDocument upsert
   */
  export type codeProjectDocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
    /**
     * The filter to search for the codeProjectDocument to update in case it exists.
     * 
    **/
    where: codeProjectDocumentWhereUniqueInput
    /**
     * In case the codeProjectDocument found by the `where` argument doesn't exist, create a new codeProjectDocument with this data.
     * 
    **/
    create: XOR<codeProjectDocumentCreateInput, codeProjectDocumentUncheckedCreateInput>
    /**
     * In case the codeProjectDocument was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<codeProjectDocumentUpdateInput, codeProjectDocumentUncheckedUpdateInput>
  }


  /**
   * codeProjectDocument delete
   */
  export type codeProjectDocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
    /**
     * Filter which codeProjectDocument to delete.
     * 
    **/
    where: codeProjectDocumentWhereUniqueInput
  }


  /**
   * codeProjectDocument deleteMany
   */
  export type codeProjectDocumentDeleteManyArgs = {
    where?: codeProjectDocumentWhereInput
  }


  /**
   * codeProjectDocument without action
   */
  export type codeProjectDocumentArgs = {
    /**
     * Select specific fields to fetch from the codeProjectDocument
     * 
    **/
    select?: codeProjectDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectDocumentInclude | null
  }



  /**
   * Model codeProjectUser
   */


  export type AggregateCodeProjectUser = {
    _count: CodeProjectUserCountAggregateOutputType | null
    count: CodeProjectUserCountAggregateOutputType | null
    _avg: CodeProjectUserAvgAggregateOutputType | null
    avg: CodeProjectUserAvgAggregateOutputType | null
    _sum: CodeProjectUserSumAggregateOutputType | null
    sum: CodeProjectUserSumAggregateOutputType | null
    _min: CodeProjectUserMinAggregateOutputType | null
    min: CodeProjectUserMinAggregateOutputType | null
    _max: CodeProjectUserMaxAggregateOutputType | null
    max: CodeProjectUserMaxAggregateOutputType | null
  }

  export type CodeProjectUserAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserMinAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserMaxAggregateOutputType = {
    Id: number | null
    UserId: number | null
    CodeProjectId: number | null
  }

  export type CodeProjectUserCountAggregateOutputType = {
    Id: number
    UserId: number
    CodeProjectId: number
    _all: number
  }


  export type CodeProjectUserAvgAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserSumAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserMinAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserMaxAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
  }

  export type CodeProjectUserCountAggregateInputType = {
    Id?: true
    UserId?: true
    CodeProjectId?: true
    _all?: true
  }

  export type CodeProjectUserAggregateArgs = {
    /**
     * Filter which codeProjectUser to aggregate.
     * 
    **/
    where?: codeProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjectUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: codeProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjectUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjectUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned codeProjectUsers
    **/
    _count?: true | CodeProjectUserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeProjectUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeProjectUserAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeProjectUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeProjectUserSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeProjectUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeProjectUserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeProjectUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeProjectUserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeProjectUserMaxAggregateInputType
  }

  export type GetCodeProjectUserAggregateType<T extends CodeProjectUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeProjectUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeProjectUser[P]>
      : GetScalarType<T[P], AggregateCodeProjectUser[P]>
  }


    
    
  export type CodeProjectUserGroupByArgs = {
    where?: codeProjectUserWhereInput
    orderBy?: Enumerable<codeProjectUserOrderByInput>
    by: Array<CodeProjectUserScalarFieldEnum>
    having?: codeProjectUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeProjectUserCountAggregateInputType | true
    _avg?: CodeProjectUserAvgAggregateInputType
    _sum?: CodeProjectUserSumAggregateInputType
    _min?: CodeProjectUserMinAggregateInputType
    _max?: CodeProjectUserMaxAggregateInputType
  }


  export type CodeProjectUserGroupByOutputType = {
    Id: number
    UserId: number
    CodeProjectId: number
    _count: CodeProjectUserCountAggregateOutputType | null
    _avg: CodeProjectUserAvgAggregateOutputType | null
    _sum: CodeProjectUserSumAggregateOutputType | null
    _min: CodeProjectUserMinAggregateOutputType | null
    _max: CodeProjectUserMaxAggregateOutputType | null
  }

  type GetCodeProjectUserGroupByPayload<T extends CodeProjectUserGroupByArgs> = Promise<
    Array<
      PickArray<CodeProjectUserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeProjectUserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeProjectUserGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeProjectUserGroupByOutputType[P]>
        }
      > 
    >


  export type codeProjectUserSelect = {
    Id?: boolean
    UserId?: boolean
    CodeProjectId?: boolean
    User?: boolean | userArgs
    CodeProject?: boolean | codeProjectArgs
  }

  export type codeProjectUserInclude = {
    User?: boolean | userArgs
    CodeProject?: boolean | codeProjectArgs
  }

  export type codeProjectUserGetPayload<
    S extends boolean | null | undefined | codeProjectUserArgs,
    U = keyof S
      > = S extends true
        ? codeProjectUser
    : S extends undefined
    ? never
    : S extends codeProjectUserArgs | codeProjectUserFindManyArgs
    ?'include' extends U
    ? codeProjectUser  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> :
        P extends 'CodeProject'
        ? codeProjectGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof codeProjectUser ?codeProjectUser [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> :
        P extends 'CodeProject'
        ? codeProjectGetPayload<S['select'][P]> : never
  } 
    : codeProjectUser
  : codeProjectUser


  type codeProjectUserCountArgs = Merge<
    Omit<codeProjectUserFindManyArgs, 'select' | 'include'> & {
      select?: CodeProjectUserCountAggregateInputType | true
    }
  >

  export interface codeProjectUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeProjectUser that matches the filter.
     * @param {codeProjectUserFindUniqueArgs} args - Arguments to find a CodeProjectUser
     * @example
     * // Get one CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends codeProjectUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, codeProjectUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'codeProjectUser'> extends True ? CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser>, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T>>> : CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser | null >, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T> | null >>

    /**
     * Find the first CodeProjectUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectUserFindFirstArgs} args - Arguments to find a CodeProjectUser
     * @example
     * // Get one CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends codeProjectUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, codeProjectUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'codeProjectUser'> extends True ? CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser>, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T>>> : CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser | null >, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T> | null >>

    /**
     * Find zero or more CodeProjectUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeProjectUsers
     * const codeProjectUsers = await prisma.codeProjectUser.findMany()
     * 
     * // Get first 10 CodeProjectUsers
     * const codeProjectUsers = await prisma.codeProjectUser.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeProjectUserWithIdOnly = await prisma.codeProjectUser.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends codeProjectUserFindManyArgs>(
      args?: SelectSubset<T, codeProjectUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<codeProjectUser>>, PrismaPromise<Array<codeProjectUserGetPayload<T>>>>

    /**
     * Create a CodeProjectUser.
     * @param {codeProjectUserCreateArgs} args - Arguments to create a CodeProjectUser.
     * @example
     * // Create one CodeProjectUser
     * const CodeProjectUser = await prisma.codeProjectUser.create({
     *   data: {
     *     // ... data to create a CodeProjectUser
     *   }
     * })
     * 
    **/
    create<T extends codeProjectUserCreateArgs>(
      args: SelectSubset<T, codeProjectUserCreateArgs>
    ): CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser>, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T>>>

    /**
     * Create many CodeProjectUsers.
     *     @param {codeProjectUserCreateManyArgs} args - Arguments to create many CodeProjectUsers.
     *     @example
     *     // Create many CodeProjectUsers
     *     const codeProjectUser = await prisma.codeProjectUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends codeProjectUserCreateManyArgs>(
      args?: SelectSubset<T, codeProjectUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeProjectUser.
     * @param {codeProjectUserDeleteArgs} args - Arguments to delete one CodeProjectUser.
     * @example
     * // Delete one CodeProjectUser
     * const CodeProjectUser = await prisma.codeProjectUser.delete({
     *   where: {
     *     // ... filter to delete one CodeProjectUser
     *   }
     * })
     * 
    **/
    delete<T extends codeProjectUserDeleteArgs>(
      args: SelectSubset<T, codeProjectUserDeleteArgs>
    ): CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser>, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T>>>

    /**
     * Update one CodeProjectUser.
     * @param {codeProjectUserUpdateArgs} args - Arguments to update one CodeProjectUser.
     * @example
     * // Update one CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends codeProjectUserUpdateArgs>(
      args: SelectSubset<T, codeProjectUserUpdateArgs>
    ): CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser>, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T>>>

    /**
     * Delete zero or more CodeProjectUsers.
     * @param {codeProjectUserDeleteManyArgs} args - Arguments to filter CodeProjectUsers to delete.
     * @example
     * // Delete a few CodeProjectUsers
     * const { count } = await prisma.codeProjectUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends codeProjectUserDeleteManyArgs>(
      args?: SelectSubset<T, codeProjectUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeProjectUsers
     * const codeProjectUser = await prisma.codeProjectUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends codeProjectUserUpdateManyArgs>(
      args: SelectSubset<T, codeProjectUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeProjectUser.
     * @param {codeProjectUserUpsertArgs} args - Arguments to update or create a CodeProjectUser.
     * @example
     * // Update or create a CodeProjectUser
     * const codeProjectUser = await prisma.codeProjectUser.upsert({
     *   create: {
     *     // ... data to create a CodeProjectUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeProjectUser we want to update
     *   }
     * })
    **/
    upsert<T extends codeProjectUserUpsertArgs>(
      args: SelectSubset<T, codeProjectUserUpsertArgs>
    ): CheckSelect<T, Prisma__codeProjectUserClient<codeProjectUser>, Prisma__codeProjectUserClient<codeProjectUserGetPayload<T>>>

    /**
     * Count the number of CodeProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeProjectUserCountArgs} args - Arguments to filter CodeProjectUsers to count.
     * @example
     * // Count the number of CodeProjectUsers
     * const count = await prisma.codeProjectUser.count({
     *   where: {
     *     // ... the filter for the CodeProjectUsers we want to count
     *   }
     * })
    **/
    count<T extends codeProjectUserCountArgs>(
      args?: Subset<T, codeProjectUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeProjectUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeProjectUserAggregateArgs>(args: Subset<T, CodeProjectUserAggregateArgs>): PrismaPromise<GetCodeProjectUserAggregateType<T>>

    /**
     * Group by CodeProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeProjectUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeProjectUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeProjectUserGroupByArgs['orderBy'] }
        : { orderBy?: CodeProjectUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeProjectUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeProjectUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for codeProjectUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__codeProjectUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    CodeProject<T extends codeProjectArgs = {}>(args?: Subset<T, codeProjectArgs>): CheckSelect<T, Prisma__codeProjectClient<codeProject | null >, Prisma__codeProjectClient<codeProjectGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * codeProjectUser findUnique
   */
  export type codeProjectUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
    /**
     * Throw an Error if a codeProjectUser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeProjectUser to fetch.
     * 
    **/
    where: codeProjectUserWhereUniqueInput
  }


  /**
   * codeProjectUser findFirst
   */
  export type codeProjectUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
    /**
     * Throw an Error if a codeProjectUser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeProjectUser to fetch.
     * 
    **/
    where?: codeProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjectUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codeProjectUsers.
     * 
    **/
    cursor?: codeProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjectUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjectUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codeProjectUsers.
     * 
    **/
    distinct?: Enumerable<CodeProjectUserScalarFieldEnum>
  }


  /**
   * codeProjectUser findMany
   */
  export type codeProjectUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
    /**
     * Filter, which codeProjectUsers to fetch.
     * 
    **/
    where?: codeProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeProjectUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<codeProjectUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing codeProjectUsers.
     * 
    **/
    cursor?: codeProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeProjectUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeProjectUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeProjectUserScalarFieldEnum>
  }


  /**
   * codeProjectUser create
   */
  export type codeProjectUserCreateArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
    /**
     * The data needed to create a codeProjectUser.
     * 
    **/
    data: XOR<codeProjectUserCreateInput, codeProjectUserUncheckedCreateInput>
  }


  /**
   * codeProjectUser createMany
   */
  export type codeProjectUserCreateManyArgs = {
    data: Enumerable<codeProjectUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * codeProjectUser update
   */
  export type codeProjectUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
    /**
     * The data needed to update a codeProjectUser.
     * 
    **/
    data: XOR<codeProjectUserUpdateInput, codeProjectUserUncheckedUpdateInput>
    /**
     * Choose, which codeProjectUser to update.
     * 
    **/
    where: codeProjectUserWhereUniqueInput
  }


  /**
   * codeProjectUser updateMany
   */
  export type codeProjectUserUpdateManyArgs = {
    data: XOR<codeProjectUserUpdateManyMutationInput, codeProjectUserUncheckedUpdateManyInput>
    where?: codeProjectUserWhereInput
  }


  /**
   * codeProjectUser upsert
   */
  export type codeProjectUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
    /**
     * The filter to search for the codeProjectUser to update in case it exists.
     * 
    **/
    where: codeProjectUserWhereUniqueInput
    /**
     * In case the codeProjectUser found by the `where` argument doesn't exist, create a new codeProjectUser with this data.
     * 
    **/
    create: XOR<codeProjectUserCreateInput, codeProjectUserUncheckedCreateInput>
    /**
     * In case the codeProjectUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<codeProjectUserUpdateInput, codeProjectUserUncheckedUpdateInput>
  }


  /**
   * codeProjectUser delete
   */
  export type codeProjectUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
    /**
     * Filter which codeProjectUser to delete.
     * 
    **/
    where: codeProjectUserWhereUniqueInput
  }


  /**
   * codeProjectUser deleteMany
   */
  export type codeProjectUserDeleteManyArgs = {
    where?: codeProjectUserWhereInput
  }


  /**
   * codeProjectUser without action
   */
  export type codeProjectUserArgs = {
    /**
     * Select specific fields to fetch from the codeProjectUser
     * 
    **/
    select?: codeProjectUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeProjectUserInclude | null
  }



  /**
   * Model codeReport
   */


  export type AggregateCodeReport = {
    _count: CodeReportCountAggregateOutputType | null
    count: CodeReportCountAggregateOutputType | null
    _avg: CodeReportAvgAggregateOutputType | null
    avg: CodeReportAvgAggregateOutputType | null
    _sum: CodeReportSumAggregateOutputType | null
    sum: CodeReportSumAggregateOutputType | null
    _min: CodeReportMinAggregateOutputType | null
    min: CodeReportMinAggregateOutputType | null
    _max: CodeReportMaxAggregateOutputType | null
    max: CodeReportMaxAggregateOutputType | null
  }

  export type CodeReportAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CodeProjectId: number | null
    Type: number | null
  }

  export type CodeReportSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CodeProjectId: number | null
    Type: number | null
  }

  export type CodeReportMinAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Date: Date | null
    CodeProjectId: number | null
    Type: number | null
    IsDelete: boolean | null
    Note: string | null
  }

  export type CodeReportMaxAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Date: Date | null
    CodeProjectId: number | null
    Type: number | null
    IsDelete: boolean | null
    Note: string | null
  }

  export type CodeReportCountAggregateOutputType = {
    Id: number
    CreatedBy: number
    CreatedDate: number
    Date: number
    CodeProjectId: number
    Type: number
    IsDelete: number
    Note: number
    _all: number
  }


  export type CodeReportAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CodeProjectId?: true
    Type?: true
  }

  export type CodeReportSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CodeProjectId?: true
    Type?: true
  }

  export type CodeReportMinAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CreatedDate?: true
    Date?: true
    CodeProjectId?: true
    Type?: true
    IsDelete?: true
    Note?: true
  }

  export type CodeReportMaxAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CreatedDate?: true
    Date?: true
    CodeProjectId?: true
    Type?: true
    IsDelete?: true
    Note?: true
  }

  export type CodeReportCountAggregateInputType = {
    Id?: true
    CreatedBy?: true
    CreatedDate?: true
    Date?: true
    CodeProjectId?: true
    Type?: true
    IsDelete?: true
    Note?: true
    _all?: true
  }

  export type CodeReportAggregateArgs = {
    /**
     * Filter which codeReport to aggregate.
     * 
    **/
    where?: codeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeReports to fetch.
     * 
    **/
    orderBy?: Enumerable<codeReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: codeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned codeReports
    **/
    _count?: true | CodeReportCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeReportAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeReportSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeReportMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeReportMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeReportMaxAggregateInputType
  }

  export type GetCodeReportAggregateType<T extends CodeReportAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeReport[P]>
      : GetScalarType<T[P], AggregateCodeReport[P]>
  }


    
    
  export type CodeReportGroupByArgs = {
    where?: codeReportWhereInput
    orderBy?: Enumerable<codeReportOrderByInput>
    by: Array<CodeReportScalarFieldEnum>
    having?: codeReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeReportCountAggregateInputType | true
    _avg?: CodeReportAvgAggregateInputType
    _sum?: CodeReportSumAggregateInputType
    _min?: CodeReportMinAggregateInputType
    _max?: CodeReportMaxAggregateInputType
  }


  export type CodeReportGroupByOutputType = {
    Id: number
    CreatedBy: number
    CreatedDate: Date
    Date: Date
    CodeProjectId: number
    Type: number
    IsDelete: boolean
    Note: string
    _count: CodeReportCountAggregateOutputType | null
    _avg: CodeReportAvgAggregateOutputType | null
    _sum: CodeReportSumAggregateOutputType | null
    _min: CodeReportMinAggregateOutputType | null
    _max: CodeReportMaxAggregateOutputType | null
  }

  type GetCodeReportGroupByPayload<T extends CodeReportGroupByArgs> = Promise<
    Array<
      PickArray<CodeReportGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeReportGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeReportGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeReportGroupByOutputType[P]>
        }
      > 
    >


  export type codeReportSelect = {
    Id?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Date?: boolean
    CodeProjectId?: boolean
    Type?: boolean
    IsDelete?: boolean
    Note?: boolean
    User?: boolean | userArgs
    CodeProject?: boolean | codeProjectArgs
    CodeReportApproval?: boolean | codeReportApprovalFindManyArgs
    CodeReportApprovalComment?: boolean | codeReportApprovalFindManyArgs
    DailyReportImage?: boolean | dailyReportImageFindManyArgs
    DailyTask?: boolean | dailyTaskFindManyArgs
    StatusReport?: boolean | statusReportArgs
    Tool?: boolean | toolFindManyArgs
    Weather?: boolean | weatherArgs
    Material?: boolean | materialFindManyArgs
    Worker?: boolean | workerFindManyArgs
    RequestForInformation?: boolean | requestForInformationArgs
  }

  export type codeReportInclude = {
    User?: boolean | userArgs
    CodeProject?: boolean | codeProjectArgs
    CodeReportApproval?: boolean | codeReportApprovalFindManyArgs
    CodeReportApprovalComment?: boolean | codeReportApprovalFindManyArgs
    DailyReportImage?: boolean | dailyReportImageFindManyArgs
    DailyTask?: boolean | dailyTaskFindManyArgs
    StatusReport?: boolean | statusReportArgs
    Tool?: boolean | toolFindManyArgs
    Weather?: boolean | weatherArgs
    Material?: boolean | materialFindManyArgs
    Worker?: boolean | workerFindManyArgs
    RequestForInformation?: boolean | requestForInformationArgs
  }

  export type codeReportGetPayload<
    S extends boolean | null | undefined | codeReportArgs,
    U = keyof S
      > = S extends true
        ? codeReport
    : S extends undefined
    ? never
    : S extends codeReportArgs | codeReportFindManyArgs
    ?'include' extends U
    ? codeReport  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> :
        P extends 'CodeProject'
        ? codeProjectGetPayload<S['include'][P]> :
        P extends 'CodeReportApproval'
        ? Array < codeReportApprovalGetPayload<S['include'][P]>>  :
        P extends 'CodeReportApprovalComment'
        ? Array < codeReportApprovalGetPayload<S['include'][P]>>  :
        P extends 'DailyReportImage'
        ? Array < dailyReportImageGetPayload<S['include'][P]>>  :
        P extends 'DailyTask'
        ? Array < dailyTaskGetPayload<S['include'][P]>>  :
        P extends 'StatusReport'
        ? statusReportGetPayload<S['include'][P]> | null :
        P extends 'Tool'
        ? Array < toolGetPayload<S['include'][P]>>  :
        P extends 'Weather'
        ? weatherGetPayload<S['include'][P]> | null :
        P extends 'Material'
        ? Array < materialGetPayload<S['include'][P]>>  :
        P extends 'Worker'
        ? Array < workerGetPayload<S['include'][P]>>  :
        P extends 'RequestForInformation'
        ? requestForInformationGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof codeReport ?codeReport [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> :
        P extends 'CodeProject'
        ? codeProjectGetPayload<S['select'][P]> :
        P extends 'CodeReportApproval'
        ? Array < codeReportApprovalGetPayload<S['select'][P]>>  :
        P extends 'CodeReportApprovalComment'
        ? Array < codeReportApprovalGetPayload<S['select'][P]>>  :
        P extends 'DailyReportImage'
        ? Array < dailyReportImageGetPayload<S['select'][P]>>  :
        P extends 'DailyTask'
        ? Array < dailyTaskGetPayload<S['select'][P]>>  :
        P extends 'StatusReport'
        ? statusReportGetPayload<S['select'][P]> | null :
        P extends 'Tool'
        ? Array < toolGetPayload<S['select'][P]>>  :
        P extends 'Weather'
        ? weatherGetPayload<S['select'][P]> | null :
        P extends 'Material'
        ? Array < materialGetPayload<S['select'][P]>>  :
        P extends 'Worker'
        ? Array < workerGetPayload<S['select'][P]>>  :
        P extends 'RequestForInformation'
        ? requestForInformationGetPayload<S['select'][P]> | null : never
  } 
    : codeReport
  : codeReport


  type codeReportCountArgs = Merge<
    Omit<codeReportFindManyArgs, 'select' | 'include'> & {
      select?: CodeReportCountAggregateInputType | true
    }
  >

  export interface codeReportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeReport that matches the filter.
     * @param {codeReportFindUniqueArgs} args - Arguments to find a CodeReport
     * @example
     * // Get one CodeReport
     * const codeReport = await prisma.codeReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends codeReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, codeReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'codeReport'> extends True ? CheckSelect<T, Prisma__codeReportClient<codeReport>, Prisma__codeReportClient<codeReportGetPayload<T>>> : CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>

    /**
     * Find the first CodeReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportFindFirstArgs} args - Arguments to find a CodeReport
     * @example
     * // Get one CodeReport
     * const codeReport = await prisma.codeReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends codeReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, codeReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'codeReport'> extends True ? CheckSelect<T, Prisma__codeReportClient<codeReport>, Prisma__codeReportClient<codeReportGetPayload<T>>> : CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>

    /**
     * Find zero or more CodeReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeReports
     * const codeReports = await prisma.codeReport.findMany()
     * 
     * // Get first 10 CodeReports
     * const codeReports = await prisma.codeReport.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeReportWithIdOnly = await prisma.codeReport.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends codeReportFindManyArgs>(
      args?: SelectSubset<T, codeReportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<codeReport>>, PrismaPromise<Array<codeReportGetPayload<T>>>>

    /**
     * Create a CodeReport.
     * @param {codeReportCreateArgs} args - Arguments to create a CodeReport.
     * @example
     * // Create one CodeReport
     * const CodeReport = await prisma.codeReport.create({
     *   data: {
     *     // ... data to create a CodeReport
     *   }
     * })
     * 
    **/
    create<T extends codeReportCreateArgs>(
      args: SelectSubset<T, codeReportCreateArgs>
    ): CheckSelect<T, Prisma__codeReportClient<codeReport>, Prisma__codeReportClient<codeReportGetPayload<T>>>

    /**
     * Create many CodeReports.
     *     @param {codeReportCreateManyArgs} args - Arguments to create many CodeReports.
     *     @example
     *     // Create many CodeReports
     *     const codeReport = await prisma.codeReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends codeReportCreateManyArgs>(
      args?: SelectSubset<T, codeReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeReport.
     * @param {codeReportDeleteArgs} args - Arguments to delete one CodeReport.
     * @example
     * // Delete one CodeReport
     * const CodeReport = await prisma.codeReport.delete({
     *   where: {
     *     // ... filter to delete one CodeReport
     *   }
     * })
     * 
    **/
    delete<T extends codeReportDeleteArgs>(
      args: SelectSubset<T, codeReportDeleteArgs>
    ): CheckSelect<T, Prisma__codeReportClient<codeReport>, Prisma__codeReportClient<codeReportGetPayload<T>>>

    /**
     * Update one CodeReport.
     * @param {codeReportUpdateArgs} args - Arguments to update one CodeReport.
     * @example
     * // Update one CodeReport
     * const codeReport = await prisma.codeReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends codeReportUpdateArgs>(
      args: SelectSubset<T, codeReportUpdateArgs>
    ): CheckSelect<T, Prisma__codeReportClient<codeReport>, Prisma__codeReportClient<codeReportGetPayload<T>>>

    /**
     * Delete zero or more CodeReports.
     * @param {codeReportDeleteManyArgs} args - Arguments to filter CodeReports to delete.
     * @example
     * // Delete a few CodeReports
     * const { count } = await prisma.codeReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends codeReportDeleteManyArgs>(
      args?: SelectSubset<T, codeReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeReports
     * const codeReport = await prisma.codeReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends codeReportUpdateManyArgs>(
      args: SelectSubset<T, codeReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeReport.
     * @param {codeReportUpsertArgs} args - Arguments to update or create a CodeReport.
     * @example
     * // Update or create a CodeReport
     * const codeReport = await prisma.codeReport.upsert({
     *   create: {
     *     // ... data to create a CodeReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeReport we want to update
     *   }
     * })
    **/
    upsert<T extends codeReportUpsertArgs>(
      args: SelectSubset<T, codeReportUpsertArgs>
    ): CheckSelect<T, Prisma__codeReportClient<codeReport>, Prisma__codeReportClient<codeReportGetPayload<T>>>

    /**
     * Count the number of CodeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportCountArgs} args - Arguments to filter CodeReports to count.
     * @example
     * // Count the number of CodeReports
     * const count = await prisma.codeReport.count({
     *   where: {
     *     // ... the filter for the CodeReports we want to count
     *   }
     * })
    **/
    count<T extends codeReportCountArgs>(
      args?: Subset<T, codeReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeReportAggregateArgs>(args: Subset<T, CodeReportAggregateArgs>): PrismaPromise<GetCodeReportAggregateType<T>>

    /**
     * Group by CodeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeReportGroupByArgs['orderBy'] }
        : { orderBy?: CodeReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeReportGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for codeReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__codeReportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    CodeProject<T extends codeProjectArgs = {}>(args?: Subset<T, codeProjectArgs>): CheckSelect<T, Prisma__codeProjectClient<codeProject | null >, Prisma__codeProjectClient<codeProjectGetPayload<T> | null >>;

    CodeReportApproval<T extends codeReportApprovalFindManyArgs = {}>(args?: Subset<T, codeReportApprovalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeReportApproval>>, PrismaPromise<Array<codeReportApprovalGetPayload<T>>>>;

    CodeReportApprovalComment<T extends codeReportApprovalFindManyArgs = {}>(args?: Subset<T, codeReportApprovalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeReportApproval>>, PrismaPromise<Array<codeReportApprovalGetPayload<T>>>>;

    DailyReportImage<T extends dailyReportImageFindManyArgs = {}>(args?: Subset<T, dailyReportImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<dailyReportImage>>, PrismaPromise<Array<dailyReportImageGetPayload<T>>>>;

    DailyTask<T extends dailyTaskFindManyArgs = {}>(args?: Subset<T, dailyTaskFindManyArgs>): CheckSelect<T, PrismaPromise<Array<dailyTask>>, PrismaPromise<Array<dailyTaskGetPayload<T>>>>;

    StatusReport<T extends statusReportArgs = {}>(args?: Subset<T, statusReportArgs>): CheckSelect<T, Prisma__statusReportClient<statusReport | null >, Prisma__statusReportClient<statusReportGetPayload<T> | null >>;

    Tool<T extends toolFindManyArgs = {}>(args?: Subset<T, toolFindManyArgs>): CheckSelect<T, PrismaPromise<Array<tool>>, PrismaPromise<Array<toolGetPayload<T>>>>;

    Weather<T extends weatherArgs = {}>(args?: Subset<T, weatherArgs>): CheckSelect<T, Prisma__weatherClient<weather | null >, Prisma__weatherClient<weatherGetPayload<T> | null >>;

    Material<T extends materialFindManyArgs = {}>(args?: Subset<T, materialFindManyArgs>): CheckSelect<T, PrismaPromise<Array<material>>, PrismaPromise<Array<materialGetPayload<T>>>>;

    Worker<T extends workerFindManyArgs = {}>(args?: Subset<T, workerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<worker>>, PrismaPromise<Array<workerGetPayload<T>>>>;

    RequestForInformation<T extends requestForInformationArgs = {}>(args?: Subset<T, requestForInformationArgs>): CheckSelect<T, Prisma__requestForInformationClient<requestForInformation | null >, Prisma__requestForInformationClient<requestForInformationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * codeReport findUnique
   */
  export type codeReportFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
    /**
     * Throw an Error if a codeReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeReport to fetch.
     * 
    **/
    where: codeReportWhereUniqueInput
  }


  /**
   * codeReport findFirst
   */
  export type codeReportFindFirstArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
    /**
     * Throw an Error if a codeReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeReport to fetch.
     * 
    **/
    where?: codeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeReports to fetch.
     * 
    **/
    orderBy?: Enumerable<codeReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codeReports.
     * 
    **/
    cursor?: codeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codeReports.
     * 
    **/
    distinct?: Enumerable<CodeReportScalarFieldEnum>
  }


  /**
   * codeReport findMany
   */
  export type codeReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
    /**
     * Filter, which codeReports to fetch.
     * 
    **/
    where?: codeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeReports to fetch.
     * 
    **/
    orderBy?: Enumerable<codeReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing codeReports.
     * 
    **/
    cursor?: codeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeReports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeReportScalarFieldEnum>
  }


  /**
   * codeReport create
   */
  export type codeReportCreateArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
    /**
     * The data needed to create a codeReport.
     * 
    **/
    data: XOR<codeReportCreateInput, codeReportUncheckedCreateInput>
  }


  /**
   * codeReport createMany
   */
  export type codeReportCreateManyArgs = {
    data: Enumerable<codeReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * codeReport update
   */
  export type codeReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
    /**
     * The data needed to update a codeReport.
     * 
    **/
    data: XOR<codeReportUpdateInput, codeReportUncheckedUpdateInput>
    /**
     * Choose, which codeReport to update.
     * 
    **/
    where: codeReportWhereUniqueInput
  }


  /**
   * codeReport updateMany
   */
  export type codeReportUpdateManyArgs = {
    data: XOR<codeReportUpdateManyMutationInput, codeReportUncheckedUpdateManyInput>
    where?: codeReportWhereInput
  }


  /**
   * codeReport upsert
   */
  export type codeReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
    /**
     * The filter to search for the codeReport to update in case it exists.
     * 
    **/
    where: codeReportWhereUniqueInput
    /**
     * In case the codeReport found by the `where` argument doesn't exist, create a new codeReport with this data.
     * 
    **/
    create: XOR<codeReportCreateInput, codeReportUncheckedCreateInput>
    /**
     * In case the codeReport was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<codeReportUpdateInput, codeReportUncheckedUpdateInput>
  }


  /**
   * codeReport delete
   */
  export type codeReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
    /**
     * Filter which codeReport to delete.
     * 
    **/
    where: codeReportWhereUniqueInput
  }


  /**
   * codeReport deleteMany
   */
  export type codeReportDeleteManyArgs = {
    where?: codeReportWhereInput
  }


  /**
   * codeReport without action
   */
  export type codeReportArgs = {
    /**
     * Select specific fields to fetch from the codeReport
     * 
    **/
    select?: codeReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportInclude | null
  }



  /**
   * Model codeReportApproval
   */


  export type AggregateCodeReportApproval = {
    _count: CodeReportApprovalCountAggregateOutputType | null
    count: CodeReportApprovalCountAggregateOutputType | null
    _avg: CodeReportApprovalAvgAggregateOutputType | null
    avg: CodeReportApprovalAvgAggregateOutputType | null
    _sum: CodeReportApprovalSumAggregateOutputType | null
    sum: CodeReportApprovalSumAggregateOutputType | null
    _min: CodeReportApprovalMinAggregateOutputType | null
    min: CodeReportApprovalMinAggregateOutputType | null
    _max: CodeReportApprovalMaxAggregateOutputType | null
    max: CodeReportApprovalMaxAggregateOutputType | null
  }

  export type CodeReportApprovalAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    Approval: number | null
  }

  export type CodeReportApprovalSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    Approval: number | null
  }

  export type CodeReportApprovalMinAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Comment: string | null
    Approval: number | null
    IsDelete: boolean | null
  }

  export type CodeReportApprovalMaxAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
    Comment: string | null
    Approval: number | null
    IsDelete: boolean | null
  }

  export type CodeReportApprovalCountAggregateOutputType = {
    Id: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate: number
    Comment: number
    Approval: number
    IsDelete: number
    _all: number
  }


  export type CodeReportApprovalAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    Approval?: true
  }

  export type CodeReportApprovalSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    Approval?: true
  }

  export type CodeReportApprovalMinAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    CreatedDate?: true
    Comment?: true
    Approval?: true
    IsDelete?: true
  }

  export type CodeReportApprovalMaxAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    CreatedDate?: true
    Comment?: true
    Approval?: true
    IsDelete?: true
  }

  export type CodeReportApprovalCountAggregateInputType = {
    Id?: true
    CodeReportId?: true
    CreatedBy?: true
    CreatedDate?: true
    Comment?: true
    Approval?: true
    IsDelete?: true
    _all?: true
  }

  export type CodeReportApprovalAggregateArgs = {
    /**
     * Filter which codeReportApproval to aggregate.
     * 
    **/
    where?: codeReportApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeReportApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<codeReportApprovalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: codeReportApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeReportApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeReportApprovals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned codeReportApprovals
    **/
    _count?: true | CodeReportApprovalCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CodeReportApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodeReportApprovalAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CodeReportApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodeReportApprovalSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CodeReportApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeReportApprovalMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CodeReportApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeReportApprovalMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CodeReportApprovalMaxAggregateInputType
  }

  export type GetCodeReportApprovalAggregateType<T extends CodeReportApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeReportApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeReportApproval[P]>
      : GetScalarType<T[P], AggregateCodeReportApproval[P]>
  }


    
    
  export type CodeReportApprovalGroupByArgs = {
    where?: codeReportApprovalWhereInput
    orderBy?: Enumerable<codeReportApprovalOrderByInput>
    by: Array<CodeReportApprovalScalarFieldEnum>
    having?: codeReportApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeReportApprovalCountAggregateInputType | true
    _avg?: CodeReportApprovalAvgAggregateInputType
    _sum?: CodeReportApprovalSumAggregateInputType
    _min?: CodeReportApprovalMinAggregateInputType
    _max?: CodeReportApprovalMaxAggregateInputType
  }


  export type CodeReportApprovalGroupByOutputType = {
    Id: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate: Date
    Comment: string
    Approval: number
    IsDelete: boolean
    _count: CodeReportApprovalCountAggregateOutputType | null
    _avg: CodeReportApprovalAvgAggregateOutputType | null
    _sum: CodeReportApprovalSumAggregateOutputType | null
    _min: CodeReportApprovalMinAggregateOutputType | null
    _max: CodeReportApprovalMaxAggregateOutputType | null
  }

  type GetCodeReportApprovalGroupByPayload<T extends CodeReportApprovalGroupByArgs> = Promise<
    Array<
      PickArray<CodeReportApprovalGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CodeReportApprovalGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CodeReportApprovalGroupByOutputType[P]> 
            : GetScalarType<T[P], CodeReportApprovalGroupByOutputType[P]>
        }
      > 
    >


  export type codeReportApprovalSelect = {
    Id?: boolean
    CodeReportId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    Comment?: boolean
    Approval?: boolean
    IsDelete?: boolean
    CodeReport?: boolean | codeReportArgs
    CodeReportComment?: boolean | codeReportArgs
    User?: boolean | userArgs
  }

  export type codeReportApprovalInclude = {
    CodeReport?: boolean | codeReportArgs
    CodeReportComment?: boolean | codeReportArgs
    User?: boolean | userArgs
  }

  export type codeReportApprovalGetPayload<
    S extends boolean | null | undefined | codeReportApprovalArgs,
    U = keyof S
      > = S extends true
        ? codeReportApproval
    : S extends undefined
    ? never
    : S extends codeReportApprovalArgs | codeReportApprovalFindManyArgs
    ?'include' extends U
    ? codeReportApproval  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> :
        P extends 'CodeReportComment'
        ? codeReportGetPayload<S['include'][P]> :
        P extends 'User'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof codeReportApproval ?codeReportApproval [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> :
        P extends 'CodeReportComment'
        ? codeReportGetPayload<S['select'][P]> :
        P extends 'User'
        ? userGetPayload<S['select'][P]> : never
  } 
    : codeReportApproval
  : codeReportApproval


  type codeReportApprovalCountArgs = Merge<
    Omit<codeReportApprovalFindManyArgs, 'select' | 'include'> & {
      select?: CodeReportApprovalCountAggregateInputType | true
    }
  >

  export interface codeReportApprovalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CodeReportApproval that matches the filter.
     * @param {codeReportApprovalFindUniqueArgs} args - Arguments to find a CodeReportApproval
     * @example
     * // Get one CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends codeReportApprovalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, codeReportApprovalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'codeReportApproval'> extends True ? CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval>, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T>>> : CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval | null >, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T> | null >>

    /**
     * Find the first CodeReportApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportApprovalFindFirstArgs} args - Arguments to find a CodeReportApproval
     * @example
     * // Get one CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends codeReportApprovalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, codeReportApprovalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'codeReportApproval'> extends True ? CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval>, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T>>> : CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval | null >, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T> | null >>

    /**
     * Find zero or more CodeReportApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportApprovalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeReportApprovals
     * const codeReportApprovals = await prisma.codeReportApproval.findMany()
     * 
     * // Get first 10 CodeReportApprovals
     * const codeReportApprovals = await prisma.codeReportApproval.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codeReportApprovalWithIdOnly = await prisma.codeReportApproval.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends codeReportApprovalFindManyArgs>(
      args?: SelectSubset<T, codeReportApprovalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<codeReportApproval>>, PrismaPromise<Array<codeReportApprovalGetPayload<T>>>>

    /**
     * Create a CodeReportApproval.
     * @param {codeReportApprovalCreateArgs} args - Arguments to create a CodeReportApproval.
     * @example
     * // Create one CodeReportApproval
     * const CodeReportApproval = await prisma.codeReportApproval.create({
     *   data: {
     *     // ... data to create a CodeReportApproval
     *   }
     * })
     * 
    **/
    create<T extends codeReportApprovalCreateArgs>(
      args: SelectSubset<T, codeReportApprovalCreateArgs>
    ): CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval>, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T>>>

    /**
     * Create many CodeReportApprovals.
     *     @param {codeReportApprovalCreateManyArgs} args - Arguments to create many CodeReportApprovals.
     *     @example
     *     // Create many CodeReportApprovals
     *     const codeReportApproval = await prisma.codeReportApproval.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends codeReportApprovalCreateManyArgs>(
      args?: SelectSubset<T, codeReportApprovalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CodeReportApproval.
     * @param {codeReportApprovalDeleteArgs} args - Arguments to delete one CodeReportApproval.
     * @example
     * // Delete one CodeReportApproval
     * const CodeReportApproval = await prisma.codeReportApproval.delete({
     *   where: {
     *     // ... filter to delete one CodeReportApproval
     *   }
     * })
     * 
    **/
    delete<T extends codeReportApprovalDeleteArgs>(
      args: SelectSubset<T, codeReportApprovalDeleteArgs>
    ): CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval>, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T>>>

    /**
     * Update one CodeReportApproval.
     * @param {codeReportApprovalUpdateArgs} args - Arguments to update one CodeReportApproval.
     * @example
     * // Update one CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends codeReportApprovalUpdateArgs>(
      args: SelectSubset<T, codeReportApprovalUpdateArgs>
    ): CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval>, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T>>>

    /**
     * Delete zero or more CodeReportApprovals.
     * @param {codeReportApprovalDeleteManyArgs} args - Arguments to filter CodeReportApprovals to delete.
     * @example
     * // Delete a few CodeReportApprovals
     * const { count } = await prisma.codeReportApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends codeReportApprovalDeleteManyArgs>(
      args?: SelectSubset<T, codeReportApprovalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeReportApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeReportApprovals
     * const codeReportApproval = await prisma.codeReportApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends codeReportApprovalUpdateManyArgs>(
      args: SelectSubset<T, codeReportApprovalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeReportApproval.
     * @param {codeReportApprovalUpsertArgs} args - Arguments to update or create a CodeReportApproval.
     * @example
     * // Update or create a CodeReportApproval
     * const codeReportApproval = await prisma.codeReportApproval.upsert({
     *   create: {
     *     // ... data to create a CodeReportApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeReportApproval we want to update
     *   }
     * })
    **/
    upsert<T extends codeReportApprovalUpsertArgs>(
      args: SelectSubset<T, codeReportApprovalUpsertArgs>
    ): CheckSelect<T, Prisma__codeReportApprovalClient<codeReportApproval>, Prisma__codeReportApprovalClient<codeReportApprovalGetPayload<T>>>

    /**
     * Count the number of CodeReportApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codeReportApprovalCountArgs} args - Arguments to filter CodeReportApprovals to count.
     * @example
     * // Count the number of CodeReportApprovals
     * const count = await prisma.codeReportApproval.count({
     *   where: {
     *     // ... the filter for the CodeReportApprovals we want to count
     *   }
     * })
    **/
    count<T extends codeReportApprovalCountArgs>(
      args?: Subset<T, codeReportApprovalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeReportApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeReportApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeReportApprovalAggregateArgs>(args: Subset<T, CodeReportApprovalAggregateArgs>): PrismaPromise<GetCodeReportApprovalAggregateType<T>>

    /**
     * Group by CodeReportApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeReportApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeReportApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeReportApprovalGroupByArgs['orderBy'] }
        : { orderBy?: CodeReportApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeReportApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeReportApprovalGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for codeReportApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__codeReportApprovalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    CodeReportComment<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * codeReportApproval findUnique
   */
  export type codeReportApprovalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
    /**
     * Throw an Error if a codeReportApproval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeReportApproval to fetch.
     * 
    **/
    where: codeReportApprovalWhereUniqueInput
  }


  /**
   * codeReportApproval findFirst
   */
  export type codeReportApprovalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
    /**
     * Throw an Error if a codeReportApproval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which codeReportApproval to fetch.
     * 
    **/
    where?: codeReportApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeReportApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<codeReportApprovalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codeReportApprovals.
     * 
    **/
    cursor?: codeReportApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeReportApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeReportApprovals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codeReportApprovals.
     * 
    **/
    distinct?: Enumerable<CodeReportApprovalScalarFieldEnum>
  }


  /**
   * codeReportApproval findMany
   */
  export type codeReportApprovalFindManyArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
    /**
     * Filter, which codeReportApprovals to fetch.
     * 
    **/
    where?: codeReportApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codeReportApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<codeReportApprovalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing codeReportApprovals.
     * 
    **/
    cursor?: codeReportApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codeReportApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codeReportApprovals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CodeReportApprovalScalarFieldEnum>
  }


  /**
   * codeReportApproval create
   */
  export type codeReportApprovalCreateArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
    /**
     * The data needed to create a codeReportApproval.
     * 
    **/
    data: XOR<codeReportApprovalCreateInput, codeReportApprovalUncheckedCreateInput>
  }


  /**
   * codeReportApproval createMany
   */
  export type codeReportApprovalCreateManyArgs = {
    data: Enumerable<codeReportApprovalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * codeReportApproval update
   */
  export type codeReportApprovalUpdateArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
    /**
     * The data needed to update a codeReportApproval.
     * 
    **/
    data: XOR<codeReportApprovalUpdateInput, codeReportApprovalUncheckedUpdateInput>
    /**
     * Choose, which codeReportApproval to update.
     * 
    **/
    where: codeReportApprovalWhereUniqueInput
  }


  /**
   * codeReportApproval updateMany
   */
  export type codeReportApprovalUpdateManyArgs = {
    data: XOR<codeReportApprovalUpdateManyMutationInput, codeReportApprovalUncheckedUpdateManyInput>
    where?: codeReportApprovalWhereInput
  }


  /**
   * codeReportApproval upsert
   */
  export type codeReportApprovalUpsertArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
    /**
     * The filter to search for the codeReportApproval to update in case it exists.
     * 
    **/
    where: codeReportApprovalWhereUniqueInput
    /**
     * In case the codeReportApproval found by the `where` argument doesn't exist, create a new codeReportApproval with this data.
     * 
    **/
    create: XOR<codeReportApprovalCreateInput, codeReportApprovalUncheckedCreateInput>
    /**
     * In case the codeReportApproval was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<codeReportApprovalUpdateInput, codeReportApprovalUncheckedUpdateInput>
  }


  /**
   * codeReportApproval delete
   */
  export type codeReportApprovalDeleteArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
    /**
     * Filter which codeReportApproval to delete.
     * 
    **/
    where: codeReportApprovalWhereUniqueInput
  }


  /**
   * codeReportApproval deleteMany
   */
  export type codeReportApprovalDeleteManyArgs = {
    where?: codeReportApprovalWhereInput
  }


  /**
   * codeReportApproval without action
   */
  export type codeReportApprovalArgs = {
    /**
     * Select specific fields to fetch from the codeReportApproval
     * 
    **/
    select?: codeReportApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: codeReportApprovalInclude | null
  }



  /**
   * Model dailyReportImage
   */


  export type AggregateDailyReportImage = {
    _count: DailyReportImageCountAggregateOutputType | null
    count: DailyReportImageCountAggregateOutputType | null
    _avg: DailyReportImageAvgAggregateOutputType | null
    avg: DailyReportImageAvgAggregateOutputType | null
    _sum: DailyReportImageSumAggregateOutputType | null
    sum: DailyReportImageSumAggregateOutputType | null
    _min: DailyReportImageMinAggregateOutputType | null
    min: DailyReportImageMinAggregateOutputType | null
    _max: DailyReportImageMaxAggregateOutputType | null
    max: DailyReportImageMaxAggregateOutputType | null
  }

  export type DailyReportImageAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type DailyReportImageSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type DailyReportImageMinAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    ImageUrl: string | null
    Name: string | null
    Caption: string | null
  }

  export type DailyReportImageMaxAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    ImageUrl: string | null
    Name: string | null
    Caption: string | null
  }

  export type DailyReportImageCountAggregateOutputType = {
    Id: number
    CodeReportId: number
    ImageUrl: number
    Name: number
    Caption: number
    _all: number
  }


  export type DailyReportImageAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type DailyReportImageSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type DailyReportImageMinAggregateInputType = {
    Id?: true
    CodeReportId?: true
    ImageUrl?: true
    Name?: true
    Caption?: true
  }

  export type DailyReportImageMaxAggregateInputType = {
    Id?: true
    CodeReportId?: true
    ImageUrl?: true
    Name?: true
    Caption?: true
  }

  export type DailyReportImageCountAggregateInputType = {
    Id?: true
    CodeReportId?: true
    ImageUrl?: true
    Name?: true
    Caption?: true
    _all?: true
  }

  export type DailyReportImageAggregateArgs = {
    /**
     * Filter which dailyReportImage to aggregate.
     * 
    **/
    where?: dailyReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dailyReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<dailyReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dailyReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dailyReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dailyReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dailyReportImages
    **/
    _count?: true | DailyReportImageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | DailyReportImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyReportImageAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: DailyReportImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyReportImageSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: DailyReportImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyReportImageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: DailyReportImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyReportImageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: DailyReportImageMaxAggregateInputType
  }

  export type GetDailyReportImageAggregateType<T extends DailyReportImageAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyReportImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyReportImage[P]>
      : GetScalarType<T[P], AggregateDailyReportImage[P]>
  }


    
    
  export type DailyReportImageGroupByArgs = {
    where?: dailyReportImageWhereInput
    orderBy?: Enumerable<dailyReportImageOrderByInput>
    by: Array<DailyReportImageScalarFieldEnum>
    having?: dailyReportImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyReportImageCountAggregateInputType | true
    _avg?: DailyReportImageAvgAggregateInputType
    _sum?: DailyReportImageSumAggregateInputType
    _min?: DailyReportImageMinAggregateInputType
    _max?: DailyReportImageMaxAggregateInputType
  }


  export type DailyReportImageGroupByOutputType = {
    Id: number
    CodeReportId: number
    ImageUrl: string
    Name: string
    Caption: string
    _count: DailyReportImageCountAggregateOutputType | null
    _avg: DailyReportImageAvgAggregateOutputType | null
    _sum: DailyReportImageSumAggregateOutputType | null
    _min: DailyReportImageMinAggregateOutputType | null
    _max: DailyReportImageMaxAggregateOutputType | null
  }

  type GetDailyReportImageGroupByPayload<T extends DailyReportImageGroupByArgs> = Promise<
    Array<
      PickArray<DailyReportImageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof DailyReportImageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], DailyReportImageGroupByOutputType[P]> 
            : GetScalarType<T[P], DailyReportImageGroupByOutputType[P]>
        }
      > 
    >


  export type dailyReportImageSelect = {
    Id?: boolean
    CodeReportId?: boolean
    ImageUrl?: boolean
    Name?: boolean
    Caption?: boolean
    CodeReport?: boolean | codeReportArgs
  }

  export type dailyReportImageInclude = {
    CodeReport?: boolean | codeReportArgs
  }

  export type dailyReportImageGetPayload<
    S extends boolean | null | undefined | dailyReportImageArgs,
    U = keyof S
      > = S extends true
        ? dailyReportImage
    : S extends undefined
    ? never
    : S extends dailyReportImageArgs | dailyReportImageFindManyArgs
    ?'include' extends U
    ? dailyReportImage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof dailyReportImage ?dailyReportImage [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> : never
  } 
    : dailyReportImage
  : dailyReportImage


  type dailyReportImageCountArgs = Merge<
    Omit<dailyReportImageFindManyArgs, 'select' | 'include'> & {
      select?: DailyReportImageCountAggregateInputType | true
    }
  >

  export interface dailyReportImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DailyReportImage that matches the filter.
     * @param {dailyReportImageFindUniqueArgs} args - Arguments to find a DailyReportImage
     * @example
     * // Get one DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dailyReportImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dailyReportImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dailyReportImage'> extends True ? CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage>, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T>>> : CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage | null >, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T> | null >>

    /**
     * Find the first DailyReportImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyReportImageFindFirstArgs} args - Arguments to find a DailyReportImage
     * @example
     * // Get one DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dailyReportImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dailyReportImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dailyReportImage'> extends True ? CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage>, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T>>> : CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage | null >, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T> | null >>

    /**
     * Find zero or more DailyReportImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyReportImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyReportImages
     * const dailyReportImages = await prisma.dailyReportImage.findMany()
     * 
     * // Get first 10 DailyReportImages
     * const dailyReportImages = await prisma.dailyReportImage.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dailyReportImageWithIdOnly = await prisma.dailyReportImage.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends dailyReportImageFindManyArgs>(
      args?: SelectSubset<T, dailyReportImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<dailyReportImage>>, PrismaPromise<Array<dailyReportImageGetPayload<T>>>>

    /**
     * Create a DailyReportImage.
     * @param {dailyReportImageCreateArgs} args - Arguments to create a DailyReportImage.
     * @example
     * // Create one DailyReportImage
     * const DailyReportImage = await prisma.dailyReportImage.create({
     *   data: {
     *     // ... data to create a DailyReportImage
     *   }
     * })
     * 
    **/
    create<T extends dailyReportImageCreateArgs>(
      args: SelectSubset<T, dailyReportImageCreateArgs>
    ): CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage>, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T>>>

    /**
     * Create many DailyReportImages.
     *     @param {dailyReportImageCreateManyArgs} args - Arguments to create many DailyReportImages.
     *     @example
     *     // Create many DailyReportImages
     *     const dailyReportImage = await prisma.dailyReportImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dailyReportImageCreateManyArgs>(
      args?: SelectSubset<T, dailyReportImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DailyReportImage.
     * @param {dailyReportImageDeleteArgs} args - Arguments to delete one DailyReportImage.
     * @example
     * // Delete one DailyReportImage
     * const DailyReportImage = await prisma.dailyReportImage.delete({
     *   where: {
     *     // ... filter to delete one DailyReportImage
     *   }
     * })
     * 
    **/
    delete<T extends dailyReportImageDeleteArgs>(
      args: SelectSubset<T, dailyReportImageDeleteArgs>
    ): CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage>, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T>>>

    /**
     * Update one DailyReportImage.
     * @param {dailyReportImageUpdateArgs} args - Arguments to update one DailyReportImage.
     * @example
     * // Update one DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dailyReportImageUpdateArgs>(
      args: SelectSubset<T, dailyReportImageUpdateArgs>
    ): CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage>, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T>>>

    /**
     * Delete zero or more DailyReportImages.
     * @param {dailyReportImageDeleteManyArgs} args - Arguments to filter DailyReportImages to delete.
     * @example
     * // Delete a few DailyReportImages
     * const { count } = await prisma.dailyReportImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dailyReportImageDeleteManyArgs>(
      args?: SelectSubset<T, dailyReportImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyReportImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyReportImages
     * const dailyReportImage = await prisma.dailyReportImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dailyReportImageUpdateManyArgs>(
      args: SelectSubset<T, dailyReportImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyReportImage.
     * @param {dailyReportImageUpsertArgs} args - Arguments to update or create a DailyReportImage.
     * @example
     * // Update or create a DailyReportImage
     * const dailyReportImage = await prisma.dailyReportImage.upsert({
     *   create: {
     *     // ... data to create a DailyReportImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyReportImage we want to update
     *   }
     * })
    **/
    upsert<T extends dailyReportImageUpsertArgs>(
      args: SelectSubset<T, dailyReportImageUpsertArgs>
    ): CheckSelect<T, Prisma__dailyReportImageClient<dailyReportImage>, Prisma__dailyReportImageClient<dailyReportImageGetPayload<T>>>

    /**
     * Count the number of DailyReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyReportImageCountArgs} args - Arguments to filter DailyReportImages to count.
     * @example
     * // Count the number of DailyReportImages
     * const count = await prisma.dailyReportImage.count({
     *   where: {
     *     // ... the filter for the DailyReportImages we want to count
     *   }
     * })
    **/
    count<T extends dailyReportImageCountArgs>(
      args?: Subset<T, dailyReportImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyReportImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyReportImageAggregateArgs>(args: Subset<T, DailyReportImageAggregateArgs>): PrismaPromise<GetDailyReportImageAggregateType<T>>

    /**
     * Group by DailyReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyReportImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyReportImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyReportImageGroupByArgs['orderBy'] }
        : { orderBy?: DailyReportImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyReportImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyReportImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for dailyReportImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dailyReportImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * dailyReportImage findUnique
   */
  export type dailyReportImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
    /**
     * Throw an Error if a dailyReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which dailyReportImage to fetch.
     * 
    **/
    where: dailyReportImageWhereUniqueInput
  }


  /**
   * dailyReportImage findFirst
   */
  export type dailyReportImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
    /**
     * Throw an Error if a dailyReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which dailyReportImage to fetch.
     * 
    **/
    where?: dailyReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dailyReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<dailyReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dailyReportImages.
     * 
    **/
    cursor?: dailyReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dailyReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dailyReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dailyReportImages.
     * 
    **/
    distinct?: Enumerable<DailyReportImageScalarFieldEnum>
  }


  /**
   * dailyReportImage findMany
   */
  export type dailyReportImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
    /**
     * Filter, which dailyReportImages to fetch.
     * 
    **/
    where?: dailyReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dailyReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<dailyReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dailyReportImages.
     * 
    **/
    cursor?: dailyReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dailyReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dailyReportImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DailyReportImageScalarFieldEnum>
  }


  /**
   * dailyReportImage create
   */
  export type dailyReportImageCreateArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
    /**
     * The data needed to create a dailyReportImage.
     * 
    **/
    data: XOR<dailyReportImageCreateInput, dailyReportImageUncheckedCreateInput>
  }


  /**
   * dailyReportImage createMany
   */
  export type dailyReportImageCreateManyArgs = {
    data: Enumerable<dailyReportImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dailyReportImage update
   */
  export type dailyReportImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
    /**
     * The data needed to update a dailyReportImage.
     * 
    **/
    data: XOR<dailyReportImageUpdateInput, dailyReportImageUncheckedUpdateInput>
    /**
     * Choose, which dailyReportImage to update.
     * 
    **/
    where: dailyReportImageWhereUniqueInput
  }


  /**
   * dailyReportImage updateMany
   */
  export type dailyReportImageUpdateManyArgs = {
    data: XOR<dailyReportImageUpdateManyMutationInput, dailyReportImageUncheckedUpdateManyInput>
    where?: dailyReportImageWhereInput
  }


  /**
   * dailyReportImage upsert
   */
  export type dailyReportImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
    /**
     * The filter to search for the dailyReportImage to update in case it exists.
     * 
    **/
    where: dailyReportImageWhereUniqueInput
    /**
     * In case the dailyReportImage found by the `where` argument doesn't exist, create a new dailyReportImage with this data.
     * 
    **/
    create: XOR<dailyReportImageCreateInput, dailyReportImageUncheckedCreateInput>
    /**
     * In case the dailyReportImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dailyReportImageUpdateInput, dailyReportImageUncheckedUpdateInput>
  }


  /**
   * dailyReportImage delete
   */
  export type dailyReportImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
    /**
     * Filter which dailyReportImage to delete.
     * 
    **/
    where: dailyReportImageWhereUniqueInput
  }


  /**
   * dailyReportImage deleteMany
   */
  export type dailyReportImageDeleteManyArgs = {
    where?: dailyReportImageWhereInput
  }


  /**
   * dailyReportImage without action
   */
  export type dailyReportImageArgs = {
    /**
     * Select specific fields to fetch from the dailyReportImage
     * 
    **/
    select?: dailyReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyReportImageInclude | null
  }



  /**
   * Model dailyTask
   */


  export type AggregateDailyTask = {
    _count: DailyTaskCountAggregateOutputType | null
    count: DailyTaskCountAggregateOutputType | null
    _avg: DailyTaskAvgAggregateOutputType | null
    avg: DailyTaskAvgAggregateOutputType | null
    _sum: DailyTaskSumAggregateOutputType | null
    sum: DailyTaskSumAggregateOutputType | null
    _min: DailyTaskMinAggregateOutputType | null
    min: DailyTaskMinAggregateOutputType | null
    _max: DailyTaskMaxAggregateOutputType | null
    max: DailyTaskMaxAggregateOutputType | null
  }

  export type DailyTaskAvgAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
  }

  export type DailyTaskSumAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
  }

  export type DailyTaskMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Unit: string | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
    Note: string | null
  }

  export type DailyTaskMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Unit: string | null
    Quantity: number | null
    ParentId: number | null
    CodeReportId: number | null
    Note: string | null
  }

  export type DailyTaskCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    Unit: number
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: number
    _all: number
  }


  export type DailyTaskAvgAggregateInputType = {
    Id?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
  }

  export type DailyTaskSumAggregateInputType = {
    Id?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
  }

  export type DailyTaskMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Unit?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
    Note?: true
  }

  export type DailyTaskMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Unit?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
    Note?: true
  }

  export type DailyTaskCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Unit?: true
    Quantity?: true
    ParentId?: true
    CodeReportId?: true
    Note?: true
    _all?: true
  }

  export type DailyTaskAggregateArgs = {
    /**
     * Filter which dailyTask to aggregate.
     * 
    **/
    where?: dailyTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dailyTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<dailyTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: dailyTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dailyTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dailyTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dailyTasks
    **/
    _count?: true | DailyTaskCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | DailyTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyTaskAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: DailyTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyTaskSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: DailyTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyTaskMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: DailyTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyTaskMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: DailyTaskMaxAggregateInputType
  }

  export type GetDailyTaskAggregateType<T extends DailyTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyTask[P]>
      : GetScalarType<T[P], AggregateDailyTask[P]>
  }


    
    
  export type DailyTaskGroupByArgs = {
    where?: dailyTaskWhereInput
    orderBy?: Enumerable<dailyTaskOrderByInput>
    by: Array<DailyTaskScalarFieldEnum>
    having?: dailyTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyTaskCountAggregateInputType | true
    _avg?: DailyTaskAvgAggregateInputType
    _sum?: DailyTaskSumAggregateInputType
    _min?: DailyTaskMinAggregateInputType
    _max?: DailyTaskMaxAggregateInputType
  }


  export type DailyTaskGroupByOutputType = {
    Id: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: string
    _count: DailyTaskCountAggregateOutputType | null
    _avg: DailyTaskAvgAggregateOutputType | null
    _sum: DailyTaskSumAggregateOutputType | null
    _min: DailyTaskMinAggregateOutputType | null
    _max: DailyTaskMaxAggregateOutputType | null
  }

  type GetDailyTaskGroupByPayload<T extends DailyTaskGroupByArgs> = Promise<
    Array<
      PickArray<DailyTaskGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof DailyTaskGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], DailyTaskGroupByOutputType[P]> 
            : GetScalarType<T[P], DailyTaskGroupByOutputType[P]>
        }
      > 
    >


  export type dailyTaskSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    Unit?: boolean
    Quantity?: boolean
    ParentId?: boolean
    CodeReportId?: boolean
    Note?: boolean
    CodeReport?: boolean | codeReportArgs
  }

  export type dailyTaskInclude = {
    CodeReport?: boolean | codeReportArgs
  }

  export type dailyTaskGetPayload<
    S extends boolean | null | undefined | dailyTaskArgs,
    U = keyof S
      > = S extends true
        ? dailyTask
    : S extends undefined
    ? never
    : S extends dailyTaskArgs | dailyTaskFindManyArgs
    ?'include' extends U
    ? dailyTask  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof dailyTask ?dailyTask [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> : never
  } 
    : dailyTask
  : dailyTask


  type dailyTaskCountArgs = Merge<
    Omit<dailyTaskFindManyArgs, 'select' | 'include'> & {
      select?: DailyTaskCountAggregateInputType | true
    }
  >

  export interface dailyTaskDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DailyTask that matches the filter.
     * @param {dailyTaskFindUniqueArgs} args - Arguments to find a DailyTask
     * @example
     * // Get one DailyTask
     * const dailyTask = await prisma.dailyTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dailyTaskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dailyTaskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dailyTask'> extends True ? CheckSelect<T, Prisma__dailyTaskClient<dailyTask>, Prisma__dailyTaskClient<dailyTaskGetPayload<T>>> : CheckSelect<T, Prisma__dailyTaskClient<dailyTask | null >, Prisma__dailyTaskClient<dailyTaskGetPayload<T> | null >>

    /**
     * Find the first DailyTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyTaskFindFirstArgs} args - Arguments to find a DailyTask
     * @example
     * // Get one DailyTask
     * const dailyTask = await prisma.dailyTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dailyTaskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dailyTaskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dailyTask'> extends True ? CheckSelect<T, Prisma__dailyTaskClient<dailyTask>, Prisma__dailyTaskClient<dailyTaskGetPayload<T>>> : CheckSelect<T, Prisma__dailyTaskClient<dailyTask | null >, Prisma__dailyTaskClient<dailyTaskGetPayload<T> | null >>

    /**
     * Find zero or more DailyTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyTaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyTasks
     * const dailyTasks = await prisma.dailyTask.findMany()
     * 
     * // Get first 10 DailyTasks
     * const dailyTasks = await prisma.dailyTask.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const dailyTaskWithIdOnly = await prisma.dailyTask.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends dailyTaskFindManyArgs>(
      args?: SelectSubset<T, dailyTaskFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<dailyTask>>, PrismaPromise<Array<dailyTaskGetPayload<T>>>>

    /**
     * Create a DailyTask.
     * @param {dailyTaskCreateArgs} args - Arguments to create a DailyTask.
     * @example
     * // Create one DailyTask
     * const DailyTask = await prisma.dailyTask.create({
     *   data: {
     *     // ... data to create a DailyTask
     *   }
     * })
     * 
    **/
    create<T extends dailyTaskCreateArgs>(
      args: SelectSubset<T, dailyTaskCreateArgs>
    ): CheckSelect<T, Prisma__dailyTaskClient<dailyTask>, Prisma__dailyTaskClient<dailyTaskGetPayload<T>>>

    /**
     * Create many DailyTasks.
     *     @param {dailyTaskCreateManyArgs} args - Arguments to create many DailyTasks.
     *     @example
     *     // Create many DailyTasks
     *     const dailyTask = await prisma.dailyTask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dailyTaskCreateManyArgs>(
      args?: SelectSubset<T, dailyTaskCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DailyTask.
     * @param {dailyTaskDeleteArgs} args - Arguments to delete one DailyTask.
     * @example
     * // Delete one DailyTask
     * const DailyTask = await prisma.dailyTask.delete({
     *   where: {
     *     // ... filter to delete one DailyTask
     *   }
     * })
     * 
    **/
    delete<T extends dailyTaskDeleteArgs>(
      args: SelectSubset<T, dailyTaskDeleteArgs>
    ): CheckSelect<T, Prisma__dailyTaskClient<dailyTask>, Prisma__dailyTaskClient<dailyTaskGetPayload<T>>>

    /**
     * Update one DailyTask.
     * @param {dailyTaskUpdateArgs} args - Arguments to update one DailyTask.
     * @example
     * // Update one DailyTask
     * const dailyTask = await prisma.dailyTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dailyTaskUpdateArgs>(
      args: SelectSubset<T, dailyTaskUpdateArgs>
    ): CheckSelect<T, Prisma__dailyTaskClient<dailyTask>, Prisma__dailyTaskClient<dailyTaskGetPayload<T>>>

    /**
     * Delete zero or more DailyTasks.
     * @param {dailyTaskDeleteManyArgs} args - Arguments to filter DailyTasks to delete.
     * @example
     * // Delete a few DailyTasks
     * const { count } = await prisma.dailyTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dailyTaskDeleteManyArgs>(
      args?: SelectSubset<T, dailyTaskDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyTasks
     * const dailyTask = await prisma.dailyTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dailyTaskUpdateManyArgs>(
      args: SelectSubset<T, dailyTaskUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyTask.
     * @param {dailyTaskUpsertArgs} args - Arguments to update or create a DailyTask.
     * @example
     * // Update or create a DailyTask
     * const dailyTask = await prisma.dailyTask.upsert({
     *   create: {
     *     // ... data to create a DailyTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyTask we want to update
     *   }
     * })
    **/
    upsert<T extends dailyTaskUpsertArgs>(
      args: SelectSubset<T, dailyTaskUpsertArgs>
    ): CheckSelect<T, Prisma__dailyTaskClient<dailyTask>, Prisma__dailyTaskClient<dailyTaskGetPayload<T>>>

    /**
     * Count the number of DailyTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dailyTaskCountArgs} args - Arguments to filter DailyTasks to count.
     * @example
     * // Count the number of DailyTasks
     * const count = await prisma.dailyTask.count({
     *   where: {
     *     // ... the filter for the DailyTasks we want to count
     *   }
     * })
    **/
    count<T extends dailyTaskCountArgs>(
      args?: Subset<T, dailyTaskCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyTaskAggregateArgs>(args: Subset<T, DailyTaskAggregateArgs>): PrismaPromise<GetDailyTaskAggregateType<T>>

    /**
     * Group by DailyTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyTaskGroupByArgs['orderBy'] }
        : { orderBy?: DailyTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyTaskGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for dailyTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dailyTaskClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * dailyTask findUnique
   */
  export type dailyTaskFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
    /**
     * Throw an Error if a dailyTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which dailyTask to fetch.
     * 
    **/
    where: dailyTaskWhereUniqueInput
  }


  /**
   * dailyTask findFirst
   */
  export type dailyTaskFindFirstArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
    /**
     * Throw an Error if a dailyTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which dailyTask to fetch.
     * 
    **/
    where?: dailyTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dailyTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<dailyTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dailyTasks.
     * 
    **/
    cursor?: dailyTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dailyTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dailyTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dailyTasks.
     * 
    **/
    distinct?: Enumerable<DailyTaskScalarFieldEnum>
  }


  /**
   * dailyTask findMany
   */
  export type dailyTaskFindManyArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
    /**
     * Filter, which dailyTasks to fetch.
     * 
    **/
    where?: dailyTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dailyTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<dailyTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dailyTasks.
     * 
    **/
    cursor?: dailyTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dailyTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dailyTasks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DailyTaskScalarFieldEnum>
  }


  /**
   * dailyTask create
   */
  export type dailyTaskCreateArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
    /**
     * The data needed to create a dailyTask.
     * 
    **/
    data: XOR<dailyTaskCreateInput, dailyTaskUncheckedCreateInput>
  }


  /**
   * dailyTask createMany
   */
  export type dailyTaskCreateManyArgs = {
    data: Enumerable<dailyTaskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dailyTask update
   */
  export type dailyTaskUpdateArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
    /**
     * The data needed to update a dailyTask.
     * 
    **/
    data: XOR<dailyTaskUpdateInput, dailyTaskUncheckedUpdateInput>
    /**
     * Choose, which dailyTask to update.
     * 
    **/
    where: dailyTaskWhereUniqueInput
  }


  /**
   * dailyTask updateMany
   */
  export type dailyTaskUpdateManyArgs = {
    data: XOR<dailyTaskUpdateManyMutationInput, dailyTaskUncheckedUpdateManyInput>
    where?: dailyTaskWhereInput
  }


  /**
   * dailyTask upsert
   */
  export type dailyTaskUpsertArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
    /**
     * The filter to search for the dailyTask to update in case it exists.
     * 
    **/
    where: dailyTaskWhereUniqueInput
    /**
     * In case the dailyTask found by the `where` argument doesn't exist, create a new dailyTask with this data.
     * 
    **/
    create: XOR<dailyTaskCreateInput, dailyTaskUncheckedCreateInput>
    /**
     * In case the dailyTask was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<dailyTaskUpdateInput, dailyTaskUncheckedUpdateInput>
  }


  /**
   * dailyTask delete
   */
  export type dailyTaskDeleteArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
    /**
     * Filter which dailyTask to delete.
     * 
    **/
    where: dailyTaskWhereUniqueInput
  }


  /**
   * dailyTask deleteMany
   */
  export type dailyTaskDeleteManyArgs = {
    where?: dailyTaskWhereInput
  }


  /**
   * dailyTask without action
   */
  export type dailyTaskArgs = {
    /**
     * Select specific fields to fetch from the dailyTask
     * 
    **/
    select?: dailyTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: dailyTaskInclude | null
  }



  /**
   * Model material
   */


  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
    max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    Status: number | null
    CodeReportId: number | null
  }

  export type MaterialSumAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    Status: number | null
    CodeReportId: number | null
  }

  export type MaterialMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Quantity: number | null
    Status: number | null
    Description: string | null
    Unit: string | null
    CodeReportId: number | null
  }

  export type MaterialMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Quantity: number | null
    Status: number | null
    Description: string | null
    Unit: string | null
    CodeReportId: number | null
  }

  export type MaterialCountAggregateOutputType = {
    Id: number
    Name: number
    Quantity: number
    Status: number
    Description: number
    Unit: number
    CodeReportId: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    Id?: true
    Quantity?: true
    Status?: true
    CodeReportId?: true
  }

  export type MaterialSumAggregateInputType = {
    Id?: true
    Quantity?: true
    Status?: true
    CodeReportId?: true
  }

  export type MaterialMinAggregateInputType = {
    Id?: true
    Name?: true
    Quantity?: true
    Status?: true
    Description?: true
    Unit?: true
    CodeReportId?: true
  }

  export type MaterialMaxAggregateInputType = {
    Id?: true
    Name?: true
    Quantity?: true
    Status?: true
    Description?: true
    Unit?: true
    CodeReportId?: true
  }

  export type MaterialCountAggregateInputType = {
    Id?: true
    Name?: true
    Quantity?: true
    Status?: true
    Description?: true
    Unit?: true
    CodeReportId?: true
    _all?: true
  }

  export type MaterialAggregateArgs = {
    /**
     * Filter which material to aggregate.
     * 
    **/
    where?: materialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materials to fetch.
     * 
    **/
    orderBy?: Enumerable<materialOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: materialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }


    
    
  export type MaterialGroupByArgs = {
    where?: materialWhereInput
    orderBy?: Enumerable<materialOrderByInput>
    by: Array<MaterialScalarFieldEnum>
    having?: materialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }


  export type MaterialGroupByOutputType = {
    Id: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReportId: number
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Promise<
    Array<
      PickArray<MaterialGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MaterialGroupByOutputType[P]> 
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      > 
    >


  export type materialSelect = {
    Id?: boolean
    Name?: boolean
    Quantity?: boolean
    Status?: boolean
    Description?: boolean
    Unit?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | codeReportArgs
  }

  export type materialInclude = {
    CodeReport?: boolean | codeReportArgs
  }

  export type materialGetPayload<
    S extends boolean | null | undefined | materialArgs,
    U = keyof S
      > = S extends true
        ? material
    : S extends undefined
    ? never
    : S extends materialArgs | materialFindManyArgs
    ?'include' extends U
    ? material  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof material ?material [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> : never
  } 
    : material
  : material


  type materialCountArgs = Merge<
    Omit<materialFindManyArgs, 'select' | 'include'> & {
      select?: MaterialCountAggregateInputType | true
    }
  >

  export interface materialDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Material that matches the filter.
     * @param {materialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends materialFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, materialFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'material'> extends True ? CheckSelect<T, Prisma__materialClient<material>, Prisma__materialClient<materialGetPayload<T>>> : CheckSelect<T, Prisma__materialClient<material | null >, Prisma__materialClient<materialGetPayload<T> | null >>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends materialFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, materialFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'material'> extends True ? CheckSelect<T, Prisma__materialClient<material>, Prisma__materialClient<materialGetPayload<T>>> : CheckSelect<T, Prisma__materialClient<material | null >, Prisma__materialClient<materialGetPayload<T> | null >>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends materialFindManyArgs>(
      args?: SelectSubset<T, materialFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<material>>, PrismaPromise<Array<materialGetPayload<T>>>>

    /**
     * Create a Material.
     * @param {materialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
    **/
    create<T extends materialCreateArgs>(
      args: SelectSubset<T, materialCreateArgs>
    ): CheckSelect<T, Prisma__materialClient<material>, Prisma__materialClient<materialGetPayload<T>>>

    /**
     * Create many Materials.
     *     @param {materialCreateManyArgs} args - Arguments to create many Materials.
     *     @example
     *     // Create many Materials
     *     const material = await prisma.material.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends materialCreateManyArgs>(
      args?: SelectSubset<T, materialCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Material.
     * @param {materialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
    **/
    delete<T extends materialDeleteArgs>(
      args: SelectSubset<T, materialDeleteArgs>
    ): CheckSelect<T, Prisma__materialClient<material>, Prisma__materialClient<materialGetPayload<T>>>

    /**
     * Update one Material.
     * @param {materialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends materialUpdateArgs>(
      args: SelectSubset<T, materialUpdateArgs>
    ): CheckSelect<T, Prisma__materialClient<material>, Prisma__materialClient<materialGetPayload<T>>>

    /**
     * Delete zero or more Materials.
     * @param {materialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends materialDeleteManyArgs>(
      args?: SelectSubset<T, materialDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends materialUpdateManyArgs>(
      args: SelectSubset<T, materialUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {materialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
    **/
    upsert<T extends materialUpsertArgs>(
      args: SelectSubset<T, materialUpsertArgs>
    ): CheckSelect<T, Prisma__materialClient<material>, Prisma__materialClient<materialGetPayload<T>>>

    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends materialCountArgs>(
      args?: Subset<T, materialCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__materialClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * material findUnique
   */
  export type materialFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
    /**
     * Throw an Error if a material can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which material to fetch.
     * 
    **/
    where: materialWhereUniqueInput
  }


  /**
   * material findFirst
   */
  export type materialFindFirstArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
    /**
     * Throw an Error if a material can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which material to fetch.
     * 
    **/
    where?: materialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materials to fetch.
     * 
    **/
    orderBy?: Enumerable<materialOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materials.
     * 
    **/
    cursor?: materialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materials.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materials.
     * 
    **/
    distinct?: Enumerable<MaterialScalarFieldEnum>
  }


  /**
   * material findMany
   */
  export type materialFindManyArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
    /**
     * Filter, which materials to fetch.
     * 
    **/
    where?: materialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materials to fetch.
     * 
    **/
    orderBy?: Enumerable<materialOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materials.
     * 
    **/
    cursor?: materialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materials from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materials.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MaterialScalarFieldEnum>
  }


  /**
   * material create
   */
  export type materialCreateArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
    /**
     * The data needed to create a material.
     * 
    **/
    data: XOR<materialCreateInput, materialUncheckedCreateInput>
  }


  /**
   * material createMany
   */
  export type materialCreateManyArgs = {
    data: Enumerable<materialCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * material update
   */
  export type materialUpdateArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
    /**
     * The data needed to update a material.
     * 
    **/
    data: XOR<materialUpdateInput, materialUncheckedUpdateInput>
    /**
     * Choose, which material to update.
     * 
    **/
    where: materialWhereUniqueInput
  }


  /**
   * material updateMany
   */
  export type materialUpdateManyArgs = {
    data: XOR<materialUpdateManyMutationInput, materialUncheckedUpdateManyInput>
    where?: materialWhereInput
  }


  /**
   * material upsert
   */
  export type materialUpsertArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
    /**
     * The filter to search for the material to update in case it exists.
     * 
    **/
    where: materialWhereUniqueInput
    /**
     * In case the material found by the `where` argument doesn't exist, create a new material with this data.
     * 
    **/
    create: XOR<materialCreateInput, materialUncheckedCreateInput>
    /**
     * In case the material was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<materialUpdateInput, materialUncheckedUpdateInput>
  }


  /**
   * material delete
   */
  export type materialDeleteArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
    /**
     * Filter which material to delete.
     * 
    **/
    where: materialWhereUniqueInput
  }


  /**
   * material deleteMany
   */
  export type materialDeleteManyArgs = {
    where?: materialWhereInput
  }


  /**
   * material without action
   */
  export type materialArgs = {
    /**
     * Select specific fields to fetch from the material
     * 
    **/
    select?: materialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: materialInclude | null
  }



  /**
   * Model project
   */


  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
    max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    Id: number | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
  }

  export type ProjectSumAggregateOutputType = {
    Id: number | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
  }

  export type ProjectMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    IsDelete: boolean | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
    Description: string | null
    Unit: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    BudgetPrice: number | null
    Quantity: number | null
    Done: number | null
    IsDelete: boolean | null
    CodeProjectId: number | null
    ParentId: number | null
    EstimatedDuration: number | null
    Timeline: number | null
    Price: number | null
    Description: string | null
    Unit: string | null
  }

  export type ProjectCountAggregateOutputType = {
    Id: number
    Name: number
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete: number
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: number
    Unit: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    Id?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
  }

  export type ProjectSumAggregateInputType = {
    Id?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
  }

  export type ProjectMinAggregateInputType = {
    Id?: true
    Name?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    IsDelete?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
    Description?: true
    Unit?: true
  }

  export type ProjectMaxAggregateInputType = {
    Id?: true
    Name?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    IsDelete?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
    Description?: true
    Unit?: true
  }

  export type ProjectCountAggregateInputType = {
    Id?: true
    Name?: true
    BudgetPrice?: true
    Quantity?: true
    Done?: true
    IsDelete?: true
    CodeProjectId?: true
    ParentId?: true
    EstimatedDuration?: true
    Timeline?: true
    Price?: true
    Description?: true
    Unit?: true
    _all?: true
  }

  export type ProjectAggregateArgs = {
    /**
     * Filter which project to aggregate.
     * 
    **/
    where?: projectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     * 
    **/
    orderBy?: Enumerable<projectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }


    
    
  export type ProjectGroupByArgs = {
    where?: projectWhereInput
    orderBy?: Enumerable<projectOrderByInput>
    by: Array<ProjectScalarFieldEnum>
    having?: projectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    Id: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete: boolean
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Promise<
    Array<
      PickArray<ProjectGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProjectGroupByOutputType[P]> 
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      > 
    >


  export type projectSelect = {
    Id?: boolean
    Name?: boolean
    BudgetPrice?: boolean
    Quantity?: boolean
    Done?: boolean
    IsDelete?: boolean
    CodeProjectId?: boolean
    ParentId?: boolean
    EstimatedDuration?: boolean
    Timeline?: boolean
    Price?: boolean
    Description?: boolean
    Unit?: boolean
    CodeProject?: boolean | codeProjectArgs
  }

  export type projectInclude = {
    CodeProject?: boolean | codeProjectArgs
  }

  export type projectGetPayload<
    S extends boolean | null | undefined | projectArgs,
    U = keyof S
      > = S extends true
        ? project
    : S extends undefined
    ? never
    : S extends projectArgs | projectFindManyArgs
    ?'include' extends U
    ? project  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeProject'
        ? codeProjectGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof project ?project [P]
  : 
          P extends 'CodeProject'
        ? codeProjectGetPayload<S['select'][P]> : never
  } 
    : project
  : project


  type projectCountArgs = Merge<
    Omit<projectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }
  >

  export interface projectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Project that matches the filter.
     * @param {projectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends projectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, projectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'project'> extends True ? CheckSelect<T, Prisma__projectClient<project>, Prisma__projectClient<projectGetPayload<T>>> : CheckSelect<T, Prisma__projectClient<project | null >, Prisma__projectClient<projectGetPayload<T> | null >>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends projectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, projectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'project'> extends True ? CheckSelect<T, Prisma__projectClient<project>, Prisma__projectClient<projectGetPayload<T>>> : CheckSelect<T, Prisma__projectClient<project | null >, Prisma__projectClient<projectGetPayload<T> | null >>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends projectFindManyArgs>(
      args?: SelectSubset<T, projectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<project>>, PrismaPromise<Array<projectGetPayload<T>>>>

    /**
     * Create a Project.
     * @param {projectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends projectCreateArgs>(
      args: SelectSubset<T, projectCreateArgs>
    ): CheckSelect<T, Prisma__projectClient<project>, Prisma__projectClient<projectGetPayload<T>>>

    /**
     * Create many Projects.
     *     @param {projectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends projectCreateManyArgs>(
      args?: SelectSubset<T, projectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {projectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends projectDeleteArgs>(
      args: SelectSubset<T, projectDeleteArgs>
    ): CheckSelect<T, Prisma__projectClient<project>, Prisma__projectClient<projectGetPayload<T>>>

    /**
     * Update one Project.
     * @param {projectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends projectUpdateArgs>(
      args: SelectSubset<T, projectUpdateArgs>
    ): CheckSelect<T, Prisma__projectClient<project>, Prisma__projectClient<projectGetPayload<T>>>

    /**
     * Delete zero or more Projects.
     * @param {projectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends projectDeleteManyArgs>(
      args?: SelectSubset<T, projectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends projectUpdateManyArgs>(
      args: SelectSubset<T, projectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {projectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends projectUpsertArgs>(
      args: SelectSubset<T, projectUpsertArgs>
    ): CheckSelect<T, Prisma__projectClient<project>, Prisma__projectClient<projectGetPayload<T>>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends projectCountArgs>(
      args?: Subset<T, projectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__projectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeProject<T extends codeProjectArgs = {}>(args?: Subset<T, codeProjectArgs>): CheckSelect<T, Prisma__codeProjectClient<codeProject | null >, Prisma__codeProjectClient<codeProjectGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * project findUnique
   */
  export type projectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
    /**
     * Throw an Error if a project can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which project to fetch.
     * 
    **/
    where: projectWhereUniqueInput
  }


  /**
   * project findFirst
   */
  export type projectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
    /**
     * Throw an Error if a project can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which project to fetch.
     * 
    **/
    where?: projectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     * 
    **/
    orderBy?: Enumerable<projectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     * 
    **/
    cursor?: projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     * 
    **/
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * project findMany
   */
  export type projectFindManyArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
    /**
     * Filter, which projects to fetch.
     * 
    **/
    where?: projectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     * 
    **/
    orderBy?: Enumerable<projectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projects.
     * 
    **/
    cursor?: projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * project create
   */
  export type projectCreateArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
    /**
     * The data needed to create a project.
     * 
    **/
    data: XOR<projectCreateInput, projectUncheckedCreateInput>
  }


  /**
   * project createMany
   */
  export type projectCreateManyArgs = {
    data: Enumerable<projectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * project update
   */
  export type projectUpdateArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
    /**
     * The data needed to update a project.
     * 
    **/
    data: XOR<projectUpdateInput, projectUncheckedUpdateInput>
    /**
     * Choose, which project to update.
     * 
    **/
    where: projectWhereUniqueInput
  }


  /**
   * project updateMany
   */
  export type projectUpdateManyArgs = {
    data: XOR<projectUpdateManyMutationInput, projectUncheckedUpdateManyInput>
    where?: projectWhereInput
  }


  /**
   * project upsert
   */
  export type projectUpsertArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
    /**
     * The filter to search for the project to update in case it exists.
     * 
    **/
    where: projectWhereUniqueInput
    /**
     * In case the project found by the `where` argument doesn't exist, create a new project with this data.
     * 
    **/
    create: XOR<projectCreateInput, projectUncheckedCreateInput>
    /**
     * In case the project was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<projectUpdateInput, projectUncheckedUpdateInput>
  }


  /**
   * project delete
   */
  export type projectDeleteArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
    /**
     * Filter which project to delete.
     * 
    **/
    where: projectWhereUniqueInput
  }


  /**
   * project deleteMany
   */
  export type projectDeleteManyArgs = {
    where?: projectWhereInput
  }


  /**
   * project without action
   */
  export type projectArgs = {
    /**
     * Select specific fields to fetch from the project
     * 
    **/
    select?: projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectInclude | null
  }



  /**
   * Model projectTask
   */


  export type AggregateProjectTask = {
    _count: ProjectTaskCountAggregateOutputType | null
    count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
    max: ProjectTaskMaxAggregateOutputType | null
  }

  export type ProjectTaskAvgAggregateOutputType = {
    Id: number | null
    ParentId: number | null
    CreatedBy: number | null
  }

  export type ProjectTaskSumAggregateOutputType = {
    Id: number | null
    ParentId: number | null
    CreatedBy: number | null
  }

  export type ProjectTaskMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    ParentId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ProjectTaskMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    ParentId: number | null
    CreatedBy: number | null
    CreatedDate: Date | null
  }

  export type ProjectTaskCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    ParentId: number
    CreatedBy: number
    CreatedDate: number
    _all: number
  }


  export type ProjectTaskAvgAggregateInputType = {
    Id?: true
    ParentId?: true
    CreatedBy?: true
  }

  export type ProjectTaskSumAggregateInputType = {
    Id?: true
    ParentId?: true
    CreatedBy?: true
  }

  export type ProjectTaskMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    ParentId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ProjectTaskMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    ParentId?: true
    CreatedBy?: true
    CreatedDate?: true
  }

  export type ProjectTaskCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    ParentId?: true
    CreatedBy?: true
    CreatedDate?: true
    _all?: true
  }

  export type ProjectTaskAggregateArgs = {
    /**
     * Filter which projectTask to aggregate.
     * 
    **/
    where?: projectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<projectTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: projectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projectTasks
    **/
    _count?: true | ProjectTaskCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ProjectTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTaskAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ProjectTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTaskSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ProjectTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTaskMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ProjectTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTaskMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ProjectTaskMaxAggregateInputType
  }

  export type GetProjectTaskAggregateType<T extends ProjectTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTask[P]>
      : GetScalarType<T[P], AggregateProjectTask[P]>
  }


    
    
  export type ProjectTaskGroupByArgs = {
    where?: projectTaskWhereInput
    orderBy?: Enumerable<projectTaskOrderByInput>
    by: Array<ProjectTaskScalarFieldEnum>
    having?: projectTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTaskCountAggregateInputType | true
    _avg?: ProjectTaskAvgAggregateInputType
    _sum?: ProjectTaskSumAggregateInputType
    _min?: ProjectTaskMinAggregateInputType
    _max?: ProjectTaskMaxAggregateInputType
  }


  export type ProjectTaskGroupByOutputType = {
    Id: number
    Name: string
    Description: string
    ParentId: number
    CreatedBy: number
    CreatedDate: Date
    _count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  type GetProjectTaskGroupByPayload<T extends ProjectTaskGroupByArgs> = Promise<
    Array<
      PickArray<ProjectTaskGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProjectTaskGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]> 
            : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
        }
      > 
    >


  export type projectTaskSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    ParentId?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    User?: boolean | userArgs
  }

  export type projectTaskInclude = {
    User?: boolean | userArgs
  }

  export type projectTaskGetPayload<
    S extends boolean | null | undefined | projectTaskArgs,
    U = keyof S
      > = S extends true
        ? projectTask
    : S extends undefined
    ? never
    : S extends projectTaskArgs | projectTaskFindManyArgs
    ?'include' extends U
    ? projectTask  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof projectTask ?projectTask [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> : never
  } 
    : projectTask
  : projectTask


  type projectTaskCountArgs = Merge<
    Omit<projectTaskFindManyArgs, 'select' | 'include'> & {
      select?: ProjectTaskCountAggregateInputType | true
    }
  >

  export interface projectTaskDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProjectTask that matches the filter.
     * @param {projectTaskFindUniqueArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends projectTaskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, projectTaskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'projectTask'> extends True ? CheckSelect<T, Prisma__projectTaskClient<projectTask>, Prisma__projectTaskClient<projectTaskGetPayload<T>>> : CheckSelect<T, Prisma__projectTaskClient<projectTask | null >, Prisma__projectTaskClient<projectTaskGetPayload<T> | null >>

    /**
     * Find the first ProjectTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskFindFirstArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends projectTaskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, projectTaskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'projectTask'> extends True ? CheckSelect<T, Prisma__projectTaskClient<projectTask>, Prisma__projectTaskClient<projectTaskGetPayload<T>>> : CheckSelect<T, Prisma__projectTaskClient<projectTask | null >, Prisma__projectTaskClient<projectTaskGetPayload<T> | null >>

    /**
     * Find zero or more ProjectTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany()
     * 
     * // Get first 10 ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const projectTaskWithIdOnly = await prisma.projectTask.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends projectTaskFindManyArgs>(
      args?: SelectSubset<T, projectTaskFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<projectTask>>, PrismaPromise<Array<projectTaskGetPayload<T>>>>

    /**
     * Create a ProjectTask.
     * @param {projectTaskCreateArgs} args - Arguments to create a ProjectTask.
     * @example
     * // Create one ProjectTask
     * const ProjectTask = await prisma.projectTask.create({
     *   data: {
     *     // ... data to create a ProjectTask
     *   }
     * })
     * 
    **/
    create<T extends projectTaskCreateArgs>(
      args: SelectSubset<T, projectTaskCreateArgs>
    ): CheckSelect<T, Prisma__projectTaskClient<projectTask>, Prisma__projectTaskClient<projectTaskGetPayload<T>>>

    /**
     * Create many ProjectTasks.
     *     @param {projectTaskCreateManyArgs} args - Arguments to create many ProjectTasks.
     *     @example
     *     // Create many ProjectTasks
     *     const projectTask = await prisma.projectTask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends projectTaskCreateManyArgs>(
      args?: SelectSubset<T, projectTaskCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectTask.
     * @param {projectTaskDeleteArgs} args - Arguments to delete one ProjectTask.
     * @example
     * // Delete one ProjectTask
     * const ProjectTask = await prisma.projectTask.delete({
     *   where: {
     *     // ... filter to delete one ProjectTask
     *   }
     * })
     * 
    **/
    delete<T extends projectTaskDeleteArgs>(
      args: SelectSubset<T, projectTaskDeleteArgs>
    ): CheckSelect<T, Prisma__projectTaskClient<projectTask>, Prisma__projectTaskClient<projectTaskGetPayload<T>>>

    /**
     * Update one ProjectTask.
     * @param {projectTaskUpdateArgs} args - Arguments to update one ProjectTask.
     * @example
     * // Update one ProjectTask
     * const projectTask = await prisma.projectTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends projectTaskUpdateArgs>(
      args: SelectSubset<T, projectTaskUpdateArgs>
    ): CheckSelect<T, Prisma__projectTaskClient<projectTask>, Prisma__projectTaskClient<projectTaskGetPayload<T>>>

    /**
     * Delete zero or more ProjectTasks.
     * @param {projectTaskDeleteManyArgs} args - Arguments to filter ProjectTasks to delete.
     * @example
     * // Delete a few ProjectTasks
     * const { count } = await prisma.projectTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends projectTaskDeleteManyArgs>(
      args?: SelectSubset<T, projectTaskDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTasks
     * const projectTask = await prisma.projectTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends projectTaskUpdateManyArgs>(
      args: SelectSubset<T, projectTaskUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTask.
     * @param {projectTaskUpsertArgs} args - Arguments to update or create a ProjectTask.
     * @example
     * // Update or create a ProjectTask
     * const projectTask = await prisma.projectTask.upsert({
     *   create: {
     *     // ... data to create a ProjectTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTask we want to update
     *   }
     * })
    **/
    upsert<T extends projectTaskUpsertArgs>(
      args: SelectSubset<T, projectTaskUpsertArgs>
    ): CheckSelect<T, Prisma__projectTaskClient<projectTask>, Prisma__projectTaskClient<projectTaskGetPayload<T>>>

    /**
     * Count the number of ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectTaskCountArgs} args - Arguments to filter ProjectTasks to count.
     * @example
     * // Count the number of ProjectTasks
     * const count = await prisma.projectTask.count({
     *   where: {
     *     // ... the filter for the ProjectTasks we want to count
     *   }
     * })
    **/
    count<T extends projectTaskCountArgs>(
      args?: Subset<T, projectTaskCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTaskAggregateArgs>(args: Subset<T, ProjectTaskAggregateArgs>): PrismaPromise<GetProjectTaskAggregateType<T>>

    /**
     * Group by ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTaskGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTaskGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for projectTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__projectTaskClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * projectTask findUnique
   */
  export type projectTaskFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
    /**
     * Throw an Error if a projectTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which projectTask to fetch.
     * 
    **/
    where: projectTaskWhereUniqueInput
  }


  /**
   * projectTask findFirst
   */
  export type projectTaskFindFirstArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
    /**
     * Throw an Error if a projectTask can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which projectTask to fetch.
     * 
    **/
    where?: projectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<projectTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projectTasks.
     * 
    **/
    cursor?: projectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectTasks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projectTasks.
     * 
    **/
    distinct?: Enumerable<ProjectTaskScalarFieldEnum>
  }


  /**
   * projectTask findMany
   */
  export type projectTaskFindManyArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
    /**
     * Filter, which projectTasks to fetch.
     * 
    **/
    where?: projectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projectTasks to fetch.
     * 
    **/
    orderBy?: Enumerable<projectTaskOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projectTasks.
     * 
    **/
    cursor?: projectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projectTasks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projectTasks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProjectTaskScalarFieldEnum>
  }


  /**
   * projectTask create
   */
  export type projectTaskCreateArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
    /**
     * The data needed to create a projectTask.
     * 
    **/
    data: XOR<projectTaskCreateInput, projectTaskUncheckedCreateInput>
  }


  /**
   * projectTask createMany
   */
  export type projectTaskCreateManyArgs = {
    data: Enumerable<projectTaskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * projectTask update
   */
  export type projectTaskUpdateArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
    /**
     * The data needed to update a projectTask.
     * 
    **/
    data: XOR<projectTaskUpdateInput, projectTaskUncheckedUpdateInput>
    /**
     * Choose, which projectTask to update.
     * 
    **/
    where: projectTaskWhereUniqueInput
  }


  /**
   * projectTask updateMany
   */
  export type projectTaskUpdateManyArgs = {
    data: XOR<projectTaskUpdateManyMutationInput, projectTaskUncheckedUpdateManyInput>
    where?: projectTaskWhereInput
  }


  /**
   * projectTask upsert
   */
  export type projectTaskUpsertArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
    /**
     * The filter to search for the projectTask to update in case it exists.
     * 
    **/
    where: projectTaskWhereUniqueInput
    /**
     * In case the projectTask found by the `where` argument doesn't exist, create a new projectTask with this data.
     * 
    **/
    create: XOR<projectTaskCreateInput, projectTaskUncheckedCreateInput>
    /**
     * In case the projectTask was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<projectTaskUpdateInput, projectTaskUncheckedUpdateInput>
  }


  /**
   * projectTask delete
   */
  export type projectTaskDeleteArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
    /**
     * Filter which projectTask to delete.
     * 
    **/
    where: projectTaskWhereUniqueInput
  }


  /**
   * projectTask deleteMany
   */
  export type projectTaskDeleteManyArgs = {
    where?: projectTaskWhereInput
  }


  /**
   * projectTask without action
   */
  export type projectTaskArgs = {
    /**
     * Select specific fields to fetch from the projectTask
     * 
    **/
    select?: projectTaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: projectTaskInclude | null
  }



  /**
   * Model requestForInformation
   */


  export type AggregateRequestForInformation = {
    _count: RequestForInformationCountAggregateOutputType | null
    count: RequestForInformationCountAggregateOutputType | null
    _avg: RequestForInformationAvgAggregateOutputType | null
    avg: RequestForInformationAvgAggregateOutputType | null
    _sum: RequestForInformationSumAggregateOutputType | null
    sum: RequestForInformationSumAggregateOutputType | null
    _min: RequestForInformationMinAggregateOutputType | null
    min: RequestForInformationMinAggregateOutputType | null
    _max: RequestForInformationMaxAggregateOutputType | null
    max: RequestForInformationMaxAggregateOutputType | null
  }

  export type RequestForInformationAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type RequestForInformationSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type RequestForInformationMinAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Description: string | null
    Header: string | null
    AddressedFor: string | null
    IsDelete: boolean | null
  }

  export type RequestForInformationMaxAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Description: string | null
    Header: string | null
    AddressedFor: string | null
    IsDelete: boolean | null
  }

  export type RequestForInformationCountAggregateOutputType = {
    Id: number
    CodeReportId: number
    Description: number
    Header: number
    AddressedFor: number
    IsDelete: number
    _all: number
  }


  export type RequestForInformationAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type RequestForInformationSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type RequestForInformationMinAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Description?: true
    Header?: true
    AddressedFor?: true
    IsDelete?: true
  }

  export type RequestForInformationMaxAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Description?: true
    Header?: true
    AddressedFor?: true
    IsDelete?: true
  }

  export type RequestForInformationCountAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Description?: true
    Header?: true
    AddressedFor?: true
    IsDelete?: true
    _all?: true
  }

  export type RequestForInformationAggregateArgs = {
    /**
     * Filter which requestForInformation to aggregate.
     * 
    **/
    where?: requestForInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: requestForInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requestForInformations
    **/
    _count?: true | RequestForInformationCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | RequestForInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestForInformationAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: RequestForInformationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestForInformationSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: RequestForInformationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestForInformationMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: RequestForInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestForInformationMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: RequestForInformationMaxAggregateInputType
  }

  export type GetRequestForInformationAggregateType<T extends RequestForInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestForInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestForInformation[P]>
      : GetScalarType<T[P], AggregateRequestForInformation[P]>
  }


    
    
  export type RequestForInformationGroupByArgs = {
    where?: requestForInformationWhereInput
    orderBy?: Enumerable<requestForInformationOrderByInput>
    by: Array<RequestForInformationScalarFieldEnum>
    having?: requestForInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestForInformationCountAggregateInputType | true
    _avg?: RequestForInformationAvgAggregateInputType
    _sum?: RequestForInformationSumAggregateInputType
    _min?: RequestForInformationMinAggregateInputType
    _max?: RequestForInformationMaxAggregateInputType
  }


  export type RequestForInformationGroupByOutputType = {
    Id: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete: boolean
    _count: RequestForInformationCountAggregateOutputType | null
    _avg: RequestForInformationAvgAggregateOutputType | null
    _sum: RequestForInformationSumAggregateOutputType | null
    _min: RequestForInformationMinAggregateOutputType | null
    _max: RequestForInformationMaxAggregateOutputType | null
  }

  type GetRequestForInformationGroupByPayload<T extends RequestForInformationGroupByArgs> = Promise<
    Array<
      PickArray<RequestForInformationGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RequestForInformationGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RequestForInformationGroupByOutputType[P]> 
            : GetScalarType<T[P], RequestForInformationGroupByOutputType[P]>
        }
      > 
    >


  export type requestForInformationSelect = {
    Id?: boolean
    CodeReportId?: boolean
    Description?: boolean
    Header?: boolean
    AddressedFor?: boolean
    IsDelete?: boolean
    CodeReport?: boolean | codeReportArgs
    RequestForInformationAnswer?: boolean | requestForInformationAnswerFindManyArgs
    RequestForInformationDocument?: boolean | requestForInformationDocumentFindManyArgs
  }

  export type requestForInformationInclude = {
    CodeReport?: boolean | codeReportArgs
    RequestForInformationAnswer?: boolean | requestForInformationAnswerFindManyArgs
    RequestForInformationDocument?: boolean | requestForInformationDocumentFindManyArgs
  }

  export type requestForInformationGetPayload<
    S extends boolean | null | undefined | requestForInformationArgs,
    U = keyof S
      > = S extends true
        ? requestForInformation
    : S extends undefined
    ? never
    : S extends requestForInformationArgs | requestForInformationFindManyArgs
    ?'include' extends U
    ? requestForInformation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> :
        P extends 'RequestForInformationAnswer'
        ? Array < requestForInformationAnswerGetPayload<S['include'][P]>>  :
        P extends 'RequestForInformationDocument'
        ? Array < requestForInformationDocumentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof requestForInformation ?requestForInformation [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> :
        P extends 'RequestForInformationAnswer'
        ? Array < requestForInformationAnswerGetPayload<S['select'][P]>>  :
        P extends 'RequestForInformationDocument'
        ? Array < requestForInformationDocumentGetPayload<S['select'][P]>>  : never
  } 
    : requestForInformation
  : requestForInformation


  type requestForInformationCountArgs = Merge<
    Omit<requestForInformationFindManyArgs, 'select' | 'include'> & {
      select?: RequestForInformationCountAggregateInputType | true
    }
  >

  export interface requestForInformationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestForInformation that matches the filter.
     * @param {requestForInformationFindUniqueArgs} args - Arguments to find a RequestForInformation
     * @example
     * // Get one RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends requestForInformationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, requestForInformationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'requestForInformation'> extends True ? CheckSelect<T, Prisma__requestForInformationClient<requestForInformation>, Prisma__requestForInformationClient<requestForInformationGetPayload<T>>> : CheckSelect<T, Prisma__requestForInformationClient<requestForInformation | null >, Prisma__requestForInformationClient<requestForInformationGetPayload<T> | null >>

    /**
     * Find the first RequestForInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationFindFirstArgs} args - Arguments to find a RequestForInformation
     * @example
     * // Get one RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends requestForInformationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, requestForInformationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'requestForInformation'> extends True ? CheckSelect<T, Prisma__requestForInformationClient<requestForInformation>, Prisma__requestForInformationClient<requestForInformationGetPayload<T>>> : CheckSelect<T, Prisma__requestForInformationClient<requestForInformation | null >, Prisma__requestForInformationClient<requestForInformationGetPayload<T> | null >>

    /**
     * Find zero or more RequestForInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestForInformations
     * const requestForInformations = await prisma.requestForInformation.findMany()
     * 
     * // Get first 10 RequestForInformations
     * const requestForInformations = await prisma.requestForInformation.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const requestForInformationWithIdOnly = await prisma.requestForInformation.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends requestForInformationFindManyArgs>(
      args?: SelectSubset<T, requestForInformationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<requestForInformation>>, PrismaPromise<Array<requestForInformationGetPayload<T>>>>

    /**
     * Create a RequestForInformation.
     * @param {requestForInformationCreateArgs} args - Arguments to create a RequestForInformation.
     * @example
     * // Create one RequestForInformation
     * const RequestForInformation = await prisma.requestForInformation.create({
     *   data: {
     *     // ... data to create a RequestForInformation
     *   }
     * })
     * 
    **/
    create<T extends requestForInformationCreateArgs>(
      args: SelectSubset<T, requestForInformationCreateArgs>
    ): CheckSelect<T, Prisma__requestForInformationClient<requestForInformation>, Prisma__requestForInformationClient<requestForInformationGetPayload<T>>>

    /**
     * Create many RequestForInformations.
     *     @param {requestForInformationCreateManyArgs} args - Arguments to create many RequestForInformations.
     *     @example
     *     // Create many RequestForInformations
     *     const requestForInformation = await prisma.requestForInformation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends requestForInformationCreateManyArgs>(
      args?: SelectSubset<T, requestForInformationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestForInformation.
     * @param {requestForInformationDeleteArgs} args - Arguments to delete one RequestForInformation.
     * @example
     * // Delete one RequestForInformation
     * const RequestForInformation = await prisma.requestForInformation.delete({
     *   where: {
     *     // ... filter to delete one RequestForInformation
     *   }
     * })
     * 
    **/
    delete<T extends requestForInformationDeleteArgs>(
      args: SelectSubset<T, requestForInformationDeleteArgs>
    ): CheckSelect<T, Prisma__requestForInformationClient<requestForInformation>, Prisma__requestForInformationClient<requestForInformationGetPayload<T>>>

    /**
     * Update one RequestForInformation.
     * @param {requestForInformationUpdateArgs} args - Arguments to update one RequestForInformation.
     * @example
     * // Update one RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends requestForInformationUpdateArgs>(
      args: SelectSubset<T, requestForInformationUpdateArgs>
    ): CheckSelect<T, Prisma__requestForInformationClient<requestForInformation>, Prisma__requestForInformationClient<requestForInformationGetPayload<T>>>

    /**
     * Delete zero or more RequestForInformations.
     * @param {requestForInformationDeleteManyArgs} args - Arguments to filter RequestForInformations to delete.
     * @example
     * // Delete a few RequestForInformations
     * const { count } = await prisma.requestForInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends requestForInformationDeleteManyArgs>(
      args?: SelectSubset<T, requestForInformationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestForInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestForInformations
     * const requestForInformation = await prisma.requestForInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends requestForInformationUpdateManyArgs>(
      args: SelectSubset<T, requestForInformationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestForInformation.
     * @param {requestForInformationUpsertArgs} args - Arguments to update or create a RequestForInformation.
     * @example
     * // Update or create a RequestForInformation
     * const requestForInformation = await prisma.requestForInformation.upsert({
     *   create: {
     *     // ... data to create a RequestForInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestForInformation we want to update
     *   }
     * })
    **/
    upsert<T extends requestForInformationUpsertArgs>(
      args: SelectSubset<T, requestForInformationUpsertArgs>
    ): CheckSelect<T, Prisma__requestForInformationClient<requestForInformation>, Prisma__requestForInformationClient<requestForInformationGetPayload<T>>>

    /**
     * Count the number of RequestForInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationCountArgs} args - Arguments to filter RequestForInformations to count.
     * @example
     * // Count the number of RequestForInformations
     * const count = await prisma.requestForInformation.count({
     *   where: {
     *     // ... the filter for the RequestForInformations we want to count
     *   }
     * })
    **/
    count<T extends requestForInformationCountArgs>(
      args?: Subset<T, requestForInformationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestForInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestForInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestForInformationAggregateArgs>(args: Subset<T, RequestForInformationAggregateArgs>): PrismaPromise<GetRequestForInformationAggregateType<T>>

    /**
     * Group by RequestForInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestForInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestForInformationGroupByArgs['orderBy'] }
        : { orderBy?: RequestForInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestForInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestForInformationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for requestForInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__requestForInformationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    RequestForInformationAnswer<T extends requestForInformationAnswerFindManyArgs = {}>(args?: Subset<T, requestForInformationAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<requestForInformationAnswer>>, PrismaPromise<Array<requestForInformationAnswerGetPayload<T>>>>;

    RequestForInformationDocument<T extends requestForInformationDocumentFindManyArgs = {}>(args?: Subset<T, requestForInformationDocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<requestForInformationDocument>>, PrismaPromise<Array<requestForInformationDocumentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * requestForInformation findUnique
   */
  export type requestForInformationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
    /**
     * Throw an Error if a requestForInformation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requestForInformation to fetch.
     * 
    **/
    where: requestForInformationWhereUniqueInput
  }


  /**
   * requestForInformation findFirst
   */
  export type requestForInformationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
    /**
     * Throw an Error if a requestForInformation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requestForInformation to fetch.
     * 
    **/
    where?: requestForInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requestForInformations.
     * 
    **/
    cursor?: requestForInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requestForInformations.
     * 
    **/
    distinct?: Enumerable<RequestForInformationScalarFieldEnum>
  }


  /**
   * requestForInformation findMany
   */
  export type requestForInformationFindManyArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
    /**
     * Filter, which requestForInformations to fetch.
     * 
    **/
    where?: requestForInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requestForInformations.
     * 
    **/
    cursor?: requestForInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestForInformationScalarFieldEnum>
  }


  /**
   * requestForInformation create
   */
  export type requestForInformationCreateArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
    /**
     * The data needed to create a requestForInformation.
     * 
    **/
    data: XOR<requestForInformationCreateInput, requestForInformationUncheckedCreateInput>
  }


  /**
   * requestForInformation createMany
   */
  export type requestForInformationCreateManyArgs = {
    data: Enumerable<requestForInformationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * requestForInformation update
   */
  export type requestForInformationUpdateArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
    /**
     * The data needed to update a requestForInformation.
     * 
    **/
    data: XOR<requestForInformationUpdateInput, requestForInformationUncheckedUpdateInput>
    /**
     * Choose, which requestForInformation to update.
     * 
    **/
    where: requestForInformationWhereUniqueInput
  }


  /**
   * requestForInformation updateMany
   */
  export type requestForInformationUpdateManyArgs = {
    data: XOR<requestForInformationUpdateManyMutationInput, requestForInformationUncheckedUpdateManyInput>
    where?: requestForInformationWhereInput
  }


  /**
   * requestForInformation upsert
   */
  export type requestForInformationUpsertArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
    /**
     * The filter to search for the requestForInformation to update in case it exists.
     * 
    **/
    where: requestForInformationWhereUniqueInput
    /**
     * In case the requestForInformation found by the `where` argument doesn't exist, create a new requestForInformation with this data.
     * 
    **/
    create: XOR<requestForInformationCreateInput, requestForInformationUncheckedCreateInput>
    /**
     * In case the requestForInformation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<requestForInformationUpdateInput, requestForInformationUncheckedUpdateInput>
  }


  /**
   * requestForInformation delete
   */
  export type requestForInformationDeleteArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
    /**
     * Filter which requestForInformation to delete.
     * 
    **/
    where: requestForInformationWhereUniqueInput
  }


  /**
   * requestForInformation deleteMany
   */
  export type requestForInformationDeleteManyArgs = {
    where?: requestForInformationWhereInput
  }


  /**
   * requestForInformation without action
   */
  export type requestForInformationArgs = {
    /**
     * Select specific fields to fetch from the requestForInformation
     * 
    **/
    select?: requestForInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationInclude | null
  }



  /**
   * Model requestForInformationAnswer
   */


  export type AggregateRequestForInformationAnswer = {
    _count: RequestForInformationAnswerCountAggregateOutputType | null
    count: RequestForInformationAnswerCountAggregateOutputType | null
    _avg: RequestForInformationAnswerAvgAggregateOutputType | null
    avg: RequestForInformationAnswerAvgAggregateOutputType | null
    _sum: RequestForInformationAnswerSumAggregateOutputType | null
    sum: RequestForInformationAnswerSumAggregateOutputType | null
    _min: RequestForInformationAnswerMinAggregateOutputType | null
    min: RequestForInformationAnswerMinAggregateOutputType | null
    _max: RequestForInformationAnswerMaxAggregateOutputType | null
    max: RequestForInformationAnswerMaxAggregateOutputType | null
  }

  export type RequestForInformationAnswerAvgAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationAnswerSumAggregateOutputType = {
    Id: number | null
    CreatedBy: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationAnswerMinAggregateOutputType = {
    Id: number | null
    Answer: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    RequestForInformationId: number | null
    IsDelete: boolean | null
  }

  export type RequestForInformationAnswerMaxAggregateOutputType = {
    Id: number | null
    Answer: string | null
    CreatedBy: number | null
    CreatedDate: Date | null
    RequestForInformationId: number | null
    IsDelete: boolean | null
  }

  export type RequestForInformationAnswerCountAggregateOutputType = {
    Id: number
    Answer: number
    CreatedBy: number
    CreatedDate: number
    RequestForInformationId: number
    IsDelete: number
    _all: number
  }


  export type RequestForInformationAnswerAvgAggregateInputType = {
    Id?: true
    CreatedBy?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationAnswerSumAggregateInputType = {
    Id?: true
    CreatedBy?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationAnswerMinAggregateInputType = {
    Id?: true
    Answer?: true
    CreatedBy?: true
    CreatedDate?: true
    RequestForInformationId?: true
    IsDelete?: true
  }

  export type RequestForInformationAnswerMaxAggregateInputType = {
    Id?: true
    Answer?: true
    CreatedBy?: true
    CreatedDate?: true
    RequestForInformationId?: true
    IsDelete?: true
  }

  export type RequestForInformationAnswerCountAggregateInputType = {
    Id?: true
    Answer?: true
    CreatedBy?: true
    CreatedDate?: true
    RequestForInformationId?: true
    IsDelete?: true
    _all?: true
  }

  export type RequestForInformationAnswerAggregateArgs = {
    /**
     * Filter which requestForInformationAnswer to aggregate.
     * 
    **/
    where?: requestForInformationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformationAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationAnswerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: requestForInformationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformationAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformationAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requestForInformationAnswers
    **/
    _count?: true | RequestForInformationAnswerCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | RequestForInformationAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestForInformationAnswerAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: RequestForInformationAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestForInformationAnswerSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: RequestForInformationAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestForInformationAnswerMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: RequestForInformationAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestForInformationAnswerMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: RequestForInformationAnswerMaxAggregateInputType
  }

  export type GetRequestForInformationAnswerAggregateType<T extends RequestForInformationAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestForInformationAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestForInformationAnswer[P]>
      : GetScalarType<T[P], AggregateRequestForInformationAnswer[P]>
  }


    
    
  export type RequestForInformationAnswerGroupByArgs = {
    where?: requestForInformationAnswerWhereInput
    orderBy?: Enumerable<requestForInformationAnswerOrderByInput>
    by: Array<RequestForInformationAnswerScalarFieldEnum>
    having?: requestForInformationAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestForInformationAnswerCountAggregateInputType | true
    _avg?: RequestForInformationAnswerAvgAggregateInputType
    _sum?: RequestForInformationAnswerSumAggregateInputType
    _min?: RequestForInformationAnswerMinAggregateInputType
    _max?: RequestForInformationAnswerMaxAggregateInputType
  }


  export type RequestForInformationAnswerGroupByOutputType = {
    Id: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date
    RequestForInformationId: number
    IsDelete: boolean
    _count: RequestForInformationAnswerCountAggregateOutputType | null
    _avg: RequestForInformationAnswerAvgAggregateOutputType | null
    _sum: RequestForInformationAnswerSumAggregateOutputType | null
    _min: RequestForInformationAnswerMinAggregateOutputType | null
    _max: RequestForInformationAnswerMaxAggregateOutputType | null
  }

  type GetRequestForInformationAnswerGroupByPayload<T extends RequestForInformationAnswerGroupByArgs> = Promise<
    Array<
      PickArray<RequestForInformationAnswerGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RequestForInformationAnswerGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RequestForInformationAnswerGroupByOutputType[P]> 
            : GetScalarType<T[P], RequestForInformationAnswerGroupByOutputType[P]>
        }
      > 
    >


  export type requestForInformationAnswerSelect = {
    Id?: boolean
    Answer?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    RequestForInformationId?: boolean
    IsDelete?: boolean
    User?: boolean | userArgs
    RequestForInformation?: boolean | requestForInformationArgs
  }

  export type requestForInformationAnswerInclude = {
    User?: boolean | userArgs
    RequestForInformation?: boolean | requestForInformationArgs
  }

  export type requestForInformationAnswerGetPayload<
    S extends boolean | null | undefined | requestForInformationAnswerArgs,
    U = keyof S
      > = S extends true
        ? requestForInformationAnswer
    : S extends undefined
    ? never
    : S extends requestForInformationAnswerArgs | requestForInformationAnswerFindManyArgs
    ?'include' extends U
    ? requestForInformationAnswer  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> :
        P extends 'RequestForInformation'
        ? requestForInformationGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof requestForInformationAnswer ?requestForInformationAnswer [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> :
        P extends 'RequestForInformation'
        ? requestForInformationGetPayload<S['select'][P]> : never
  } 
    : requestForInformationAnswer
  : requestForInformationAnswer


  type requestForInformationAnswerCountArgs = Merge<
    Omit<requestForInformationAnswerFindManyArgs, 'select' | 'include'> & {
      select?: RequestForInformationAnswerCountAggregateInputType | true
    }
  >

  export interface requestForInformationAnswerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestForInformationAnswer that matches the filter.
     * @param {requestForInformationAnswerFindUniqueArgs} args - Arguments to find a RequestForInformationAnswer
     * @example
     * // Get one RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends requestForInformationAnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, requestForInformationAnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'requestForInformationAnswer'> extends True ? CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer>, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T>>> : CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer | null >, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T> | null >>

    /**
     * Find the first RequestForInformationAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationAnswerFindFirstArgs} args - Arguments to find a RequestForInformationAnswer
     * @example
     * // Get one RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends requestForInformationAnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, requestForInformationAnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'requestForInformationAnswer'> extends True ? CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer>, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T>>> : CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer | null >, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T> | null >>

    /**
     * Find zero or more RequestForInformationAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestForInformationAnswers
     * const requestForInformationAnswers = await prisma.requestForInformationAnswer.findMany()
     * 
     * // Get first 10 RequestForInformationAnswers
     * const requestForInformationAnswers = await prisma.requestForInformationAnswer.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const requestForInformationAnswerWithIdOnly = await prisma.requestForInformationAnswer.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends requestForInformationAnswerFindManyArgs>(
      args?: SelectSubset<T, requestForInformationAnswerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<requestForInformationAnswer>>, PrismaPromise<Array<requestForInformationAnswerGetPayload<T>>>>

    /**
     * Create a RequestForInformationAnswer.
     * @param {requestForInformationAnswerCreateArgs} args - Arguments to create a RequestForInformationAnswer.
     * @example
     * // Create one RequestForInformationAnswer
     * const RequestForInformationAnswer = await prisma.requestForInformationAnswer.create({
     *   data: {
     *     // ... data to create a RequestForInformationAnswer
     *   }
     * })
     * 
    **/
    create<T extends requestForInformationAnswerCreateArgs>(
      args: SelectSubset<T, requestForInformationAnswerCreateArgs>
    ): CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer>, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T>>>

    /**
     * Create many RequestForInformationAnswers.
     *     @param {requestForInformationAnswerCreateManyArgs} args - Arguments to create many RequestForInformationAnswers.
     *     @example
     *     // Create many RequestForInformationAnswers
     *     const requestForInformationAnswer = await prisma.requestForInformationAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends requestForInformationAnswerCreateManyArgs>(
      args?: SelectSubset<T, requestForInformationAnswerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestForInformationAnswer.
     * @param {requestForInformationAnswerDeleteArgs} args - Arguments to delete one RequestForInformationAnswer.
     * @example
     * // Delete one RequestForInformationAnswer
     * const RequestForInformationAnswer = await prisma.requestForInformationAnswer.delete({
     *   where: {
     *     // ... filter to delete one RequestForInformationAnswer
     *   }
     * })
     * 
    **/
    delete<T extends requestForInformationAnswerDeleteArgs>(
      args: SelectSubset<T, requestForInformationAnswerDeleteArgs>
    ): CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer>, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T>>>

    /**
     * Update one RequestForInformationAnswer.
     * @param {requestForInformationAnswerUpdateArgs} args - Arguments to update one RequestForInformationAnswer.
     * @example
     * // Update one RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends requestForInformationAnswerUpdateArgs>(
      args: SelectSubset<T, requestForInformationAnswerUpdateArgs>
    ): CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer>, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T>>>

    /**
     * Delete zero or more RequestForInformationAnswers.
     * @param {requestForInformationAnswerDeleteManyArgs} args - Arguments to filter RequestForInformationAnswers to delete.
     * @example
     * // Delete a few RequestForInformationAnswers
     * const { count } = await prisma.requestForInformationAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends requestForInformationAnswerDeleteManyArgs>(
      args?: SelectSubset<T, requestForInformationAnswerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestForInformationAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestForInformationAnswers
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends requestForInformationAnswerUpdateManyArgs>(
      args: SelectSubset<T, requestForInformationAnswerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestForInformationAnswer.
     * @param {requestForInformationAnswerUpsertArgs} args - Arguments to update or create a RequestForInformationAnswer.
     * @example
     * // Update or create a RequestForInformationAnswer
     * const requestForInformationAnswer = await prisma.requestForInformationAnswer.upsert({
     *   create: {
     *     // ... data to create a RequestForInformationAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestForInformationAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends requestForInformationAnswerUpsertArgs>(
      args: SelectSubset<T, requestForInformationAnswerUpsertArgs>
    ): CheckSelect<T, Prisma__requestForInformationAnswerClient<requestForInformationAnswer>, Prisma__requestForInformationAnswerClient<requestForInformationAnswerGetPayload<T>>>

    /**
     * Count the number of RequestForInformationAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationAnswerCountArgs} args - Arguments to filter RequestForInformationAnswers to count.
     * @example
     * // Count the number of RequestForInformationAnswers
     * const count = await prisma.requestForInformationAnswer.count({
     *   where: {
     *     // ... the filter for the RequestForInformationAnswers we want to count
     *   }
     * })
    **/
    count<T extends requestForInformationAnswerCountArgs>(
      args?: Subset<T, requestForInformationAnswerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestForInformationAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestForInformationAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestForInformationAnswerAggregateArgs>(args: Subset<T, RequestForInformationAnswerAggregateArgs>): PrismaPromise<GetRequestForInformationAnswerAggregateType<T>>

    /**
     * Group by RequestForInformationAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestForInformationAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestForInformationAnswerGroupByArgs['orderBy'] }
        : { orderBy?: RequestForInformationAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestForInformationAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestForInformationAnswerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for requestForInformationAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__requestForInformationAnswerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    RequestForInformation<T extends requestForInformationArgs = {}>(args?: Subset<T, requestForInformationArgs>): CheckSelect<T, Prisma__requestForInformationClient<requestForInformation | null >, Prisma__requestForInformationClient<requestForInformationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * requestForInformationAnswer findUnique
   */
  export type requestForInformationAnswerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
    /**
     * Throw an Error if a requestForInformationAnswer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requestForInformationAnswer to fetch.
     * 
    **/
    where: requestForInformationAnswerWhereUniqueInput
  }


  /**
   * requestForInformationAnswer findFirst
   */
  export type requestForInformationAnswerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
    /**
     * Throw an Error if a requestForInformationAnswer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requestForInformationAnswer to fetch.
     * 
    **/
    where?: requestForInformationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformationAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationAnswerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requestForInformationAnswers.
     * 
    **/
    cursor?: requestForInformationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformationAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformationAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requestForInformationAnswers.
     * 
    **/
    distinct?: Enumerable<RequestForInformationAnswerScalarFieldEnum>
  }


  /**
   * requestForInformationAnswer findMany
   */
  export type requestForInformationAnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
    /**
     * Filter, which requestForInformationAnswers to fetch.
     * 
    **/
    where?: requestForInformationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformationAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationAnswerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requestForInformationAnswers.
     * 
    **/
    cursor?: requestForInformationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformationAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformationAnswers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestForInformationAnswerScalarFieldEnum>
  }


  /**
   * requestForInformationAnswer create
   */
  export type requestForInformationAnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
    /**
     * The data needed to create a requestForInformationAnswer.
     * 
    **/
    data: XOR<requestForInformationAnswerCreateInput, requestForInformationAnswerUncheckedCreateInput>
  }


  /**
   * requestForInformationAnswer createMany
   */
  export type requestForInformationAnswerCreateManyArgs = {
    data: Enumerable<requestForInformationAnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * requestForInformationAnswer update
   */
  export type requestForInformationAnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
    /**
     * The data needed to update a requestForInformationAnswer.
     * 
    **/
    data: XOR<requestForInformationAnswerUpdateInput, requestForInformationAnswerUncheckedUpdateInput>
    /**
     * Choose, which requestForInformationAnswer to update.
     * 
    **/
    where: requestForInformationAnswerWhereUniqueInput
  }


  /**
   * requestForInformationAnswer updateMany
   */
  export type requestForInformationAnswerUpdateManyArgs = {
    data: XOR<requestForInformationAnswerUpdateManyMutationInput, requestForInformationAnswerUncheckedUpdateManyInput>
    where?: requestForInformationAnswerWhereInput
  }


  /**
   * requestForInformationAnswer upsert
   */
  export type requestForInformationAnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
    /**
     * The filter to search for the requestForInformationAnswer to update in case it exists.
     * 
    **/
    where: requestForInformationAnswerWhereUniqueInput
    /**
     * In case the requestForInformationAnswer found by the `where` argument doesn't exist, create a new requestForInformationAnswer with this data.
     * 
    **/
    create: XOR<requestForInformationAnswerCreateInput, requestForInformationAnswerUncheckedCreateInput>
    /**
     * In case the requestForInformationAnswer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<requestForInformationAnswerUpdateInput, requestForInformationAnswerUncheckedUpdateInput>
  }


  /**
   * requestForInformationAnswer delete
   */
  export type requestForInformationAnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
    /**
     * Filter which requestForInformationAnswer to delete.
     * 
    **/
    where: requestForInformationAnswerWhereUniqueInput
  }


  /**
   * requestForInformationAnswer deleteMany
   */
  export type requestForInformationAnswerDeleteManyArgs = {
    where?: requestForInformationAnswerWhereInput
  }


  /**
   * requestForInformationAnswer without action
   */
  export type requestForInformationAnswerArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationAnswer
     * 
    **/
    select?: requestForInformationAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationAnswerInclude | null
  }



  /**
   * Model requestForInformationDocument
   */


  export type AggregateRequestForInformationDocument = {
    _count: RequestForInformationDocumentCountAggregateOutputType | null
    count: RequestForInformationDocumentCountAggregateOutputType | null
    _avg: RequestForInformationDocumentAvgAggregateOutputType | null
    avg: RequestForInformationDocumentAvgAggregateOutputType | null
    _sum: RequestForInformationDocumentSumAggregateOutputType | null
    sum: RequestForInformationDocumentSumAggregateOutputType | null
    _min: RequestForInformationDocumentMinAggregateOutputType | null
    min: RequestForInformationDocumentMinAggregateOutputType | null
    _max: RequestForInformationDocumentMaxAggregateOutputType | null
    max: RequestForInformationDocumentMaxAggregateOutputType | null
  }

  export type RequestForInformationDocumentAvgAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationDocumentSumAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
  }

  export type RequestForInformationDocumentMinAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type RequestForInformationDocumentMaxAggregateOutputType = {
    Id: number | null
    RequestForInformationId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type RequestForInformationDocumentCountAggregateOutputType = {
    Id: number
    RequestForInformationId: number
    ImageUrl: number
    Name: number
    _all: number
  }


  export type RequestForInformationDocumentAvgAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationDocumentSumAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
  }

  export type RequestForInformationDocumentMinAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
    ImageUrl?: true
    Name?: true
  }

  export type RequestForInformationDocumentMaxAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
    ImageUrl?: true
    Name?: true
  }

  export type RequestForInformationDocumentCountAggregateInputType = {
    Id?: true
    RequestForInformationId?: true
    ImageUrl?: true
    Name?: true
    _all?: true
  }

  export type RequestForInformationDocumentAggregateArgs = {
    /**
     * Filter which requestForInformationDocument to aggregate.
     * 
    **/
    where?: requestForInformationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformationDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: requestForInformationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformationDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformationDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requestForInformationDocuments
    **/
    _count?: true | RequestForInformationDocumentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | RequestForInformationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestForInformationDocumentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: RequestForInformationDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestForInformationDocumentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: RequestForInformationDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestForInformationDocumentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: RequestForInformationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestForInformationDocumentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: RequestForInformationDocumentMaxAggregateInputType
  }

  export type GetRequestForInformationDocumentAggregateType<T extends RequestForInformationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestForInformationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestForInformationDocument[P]>
      : GetScalarType<T[P], AggregateRequestForInformationDocument[P]>
  }


    
    
  export type RequestForInformationDocumentGroupByArgs = {
    where?: requestForInformationDocumentWhereInput
    orderBy?: Enumerable<requestForInformationDocumentOrderByInput>
    by: Array<RequestForInformationDocumentScalarFieldEnum>
    having?: requestForInformationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestForInformationDocumentCountAggregateInputType | true
    _avg?: RequestForInformationDocumentAvgAggregateInputType
    _sum?: RequestForInformationDocumentSumAggregateInputType
    _min?: RequestForInformationDocumentMinAggregateInputType
    _max?: RequestForInformationDocumentMaxAggregateInputType
  }


  export type RequestForInformationDocumentGroupByOutputType = {
    Id: number
    RequestForInformationId: number
    ImageUrl: string
    Name: string
    _count: RequestForInformationDocumentCountAggregateOutputType | null
    _avg: RequestForInformationDocumentAvgAggregateOutputType | null
    _sum: RequestForInformationDocumentSumAggregateOutputType | null
    _min: RequestForInformationDocumentMinAggregateOutputType | null
    _max: RequestForInformationDocumentMaxAggregateOutputType | null
  }

  type GetRequestForInformationDocumentGroupByPayload<T extends RequestForInformationDocumentGroupByArgs> = Promise<
    Array<
      PickArray<RequestForInformationDocumentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RequestForInformationDocumentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RequestForInformationDocumentGroupByOutputType[P]> 
            : GetScalarType<T[P], RequestForInformationDocumentGroupByOutputType[P]>
        }
      > 
    >


  export type requestForInformationDocumentSelect = {
    Id?: boolean
    RequestForInformationId?: boolean
    ImageUrl?: boolean
    Name?: boolean
    RequestForInformation?: boolean | requestForInformationArgs
  }

  export type requestForInformationDocumentInclude = {
    RequestForInformation?: boolean | requestForInformationArgs
  }

  export type requestForInformationDocumentGetPayload<
    S extends boolean | null | undefined | requestForInformationDocumentArgs,
    U = keyof S
      > = S extends true
        ? requestForInformationDocument
    : S extends undefined
    ? never
    : S extends requestForInformationDocumentArgs | requestForInformationDocumentFindManyArgs
    ?'include' extends U
    ? requestForInformationDocument  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RequestForInformation'
        ? requestForInformationGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof requestForInformationDocument ?requestForInformationDocument [P]
  : 
          P extends 'RequestForInformation'
        ? requestForInformationGetPayload<S['select'][P]> : never
  } 
    : requestForInformationDocument
  : requestForInformationDocument


  type requestForInformationDocumentCountArgs = Merge<
    Omit<requestForInformationDocumentFindManyArgs, 'select' | 'include'> & {
      select?: RequestForInformationDocumentCountAggregateInputType | true
    }
  >

  export interface requestForInformationDocumentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestForInformationDocument that matches the filter.
     * @param {requestForInformationDocumentFindUniqueArgs} args - Arguments to find a RequestForInformationDocument
     * @example
     * // Get one RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends requestForInformationDocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, requestForInformationDocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'requestForInformationDocument'> extends True ? CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument>, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T>>> : CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument | null >, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T> | null >>

    /**
     * Find the first RequestForInformationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationDocumentFindFirstArgs} args - Arguments to find a RequestForInformationDocument
     * @example
     * // Get one RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends requestForInformationDocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, requestForInformationDocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'requestForInformationDocument'> extends True ? CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument>, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T>>> : CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument | null >, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T> | null >>

    /**
     * Find zero or more RequestForInformationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestForInformationDocuments
     * const requestForInformationDocuments = await prisma.requestForInformationDocument.findMany()
     * 
     * // Get first 10 RequestForInformationDocuments
     * const requestForInformationDocuments = await prisma.requestForInformationDocument.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const requestForInformationDocumentWithIdOnly = await prisma.requestForInformationDocument.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends requestForInformationDocumentFindManyArgs>(
      args?: SelectSubset<T, requestForInformationDocumentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<requestForInformationDocument>>, PrismaPromise<Array<requestForInformationDocumentGetPayload<T>>>>

    /**
     * Create a RequestForInformationDocument.
     * @param {requestForInformationDocumentCreateArgs} args - Arguments to create a RequestForInformationDocument.
     * @example
     * // Create one RequestForInformationDocument
     * const RequestForInformationDocument = await prisma.requestForInformationDocument.create({
     *   data: {
     *     // ... data to create a RequestForInformationDocument
     *   }
     * })
     * 
    **/
    create<T extends requestForInformationDocumentCreateArgs>(
      args: SelectSubset<T, requestForInformationDocumentCreateArgs>
    ): CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument>, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T>>>

    /**
     * Create many RequestForInformationDocuments.
     *     @param {requestForInformationDocumentCreateManyArgs} args - Arguments to create many RequestForInformationDocuments.
     *     @example
     *     // Create many RequestForInformationDocuments
     *     const requestForInformationDocument = await prisma.requestForInformationDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends requestForInformationDocumentCreateManyArgs>(
      args?: SelectSubset<T, requestForInformationDocumentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestForInformationDocument.
     * @param {requestForInformationDocumentDeleteArgs} args - Arguments to delete one RequestForInformationDocument.
     * @example
     * // Delete one RequestForInformationDocument
     * const RequestForInformationDocument = await prisma.requestForInformationDocument.delete({
     *   where: {
     *     // ... filter to delete one RequestForInformationDocument
     *   }
     * })
     * 
    **/
    delete<T extends requestForInformationDocumentDeleteArgs>(
      args: SelectSubset<T, requestForInformationDocumentDeleteArgs>
    ): CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument>, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T>>>

    /**
     * Update one RequestForInformationDocument.
     * @param {requestForInformationDocumentUpdateArgs} args - Arguments to update one RequestForInformationDocument.
     * @example
     * // Update one RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends requestForInformationDocumentUpdateArgs>(
      args: SelectSubset<T, requestForInformationDocumentUpdateArgs>
    ): CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument>, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T>>>

    /**
     * Delete zero or more RequestForInformationDocuments.
     * @param {requestForInformationDocumentDeleteManyArgs} args - Arguments to filter RequestForInformationDocuments to delete.
     * @example
     * // Delete a few RequestForInformationDocuments
     * const { count } = await prisma.requestForInformationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends requestForInformationDocumentDeleteManyArgs>(
      args?: SelectSubset<T, requestForInformationDocumentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestForInformationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestForInformationDocuments
     * const requestForInformationDocument = await prisma.requestForInformationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends requestForInformationDocumentUpdateManyArgs>(
      args: SelectSubset<T, requestForInformationDocumentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestForInformationDocument.
     * @param {requestForInformationDocumentUpsertArgs} args - Arguments to update or create a RequestForInformationDocument.
     * @example
     * // Update or create a RequestForInformationDocument
     * const requestForInformationDocument = await prisma.requestForInformationDocument.upsert({
     *   create: {
     *     // ... data to create a RequestForInformationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestForInformationDocument we want to update
     *   }
     * })
    **/
    upsert<T extends requestForInformationDocumentUpsertArgs>(
      args: SelectSubset<T, requestForInformationDocumentUpsertArgs>
    ): CheckSelect<T, Prisma__requestForInformationDocumentClient<requestForInformationDocument>, Prisma__requestForInformationDocumentClient<requestForInformationDocumentGetPayload<T>>>

    /**
     * Count the number of RequestForInformationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestForInformationDocumentCountArgs} args - Arguments to filter RequestForInformationDocuments to count.
     * @example
     * // Count the number of RequestForInformationDocuments
     * const count = await prisma.requestForInformationDocument.count({
     *   where: {
     *     // ... the filter for the RequestForInformationDocuments we want to count
     *   }
     * })
    **/
    count<T extends requestForInformationDocumentCountArgs>(
      args?: Subset<T, requestForInformationDocumentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestForInformationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestForInformationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestForInformationDocumentAggregateArgs>(args: Subset<T, RequestForInformationDocumentAggregateArgs>): PrismaPromise<GetRequestForInformationDocumentAggregateType<T>>

    /**
     * Group by RequestForInformationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestForInformationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestForInformationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestForInformationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: RequestForInformationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestForInformationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestForInformationDocumentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for requestForInformationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__requestForInformationDocumentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RequestForInformation<T extends requestForInformationArgs = {}>(args?: Subset<T, requestForInformationArgs>): CheckSelect<T, Prisma__requestForInformationClient<requestForInformation | null >, Prisma__requestForInformationClient<requestForInformationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * requestForInformationDocument findUnique
   */
  export type requestForInformationDocumentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
    /**
     * Throw an Error if a requestForInformationDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requestForInformationDocument to fetch.
     * 
    **/
    where: requestForInformationDocumentWhereUniqueInput
  }


  /**
   * requestForInformationDocument findFirst
   */
  export type requestForInformationDocumentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
    /**
     * Throw an Error if a requestForInformationDocument can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which requestForInformationDocument to fetch.
     * 
    **/
    where?: requestForInformationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformationDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requestForInformationDocuments.
     * 
    **/
    cursor?: requestForInformationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformationDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformationDocuments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requestForInformationDocuments.
     * 
    **/
    distinct?: Enumerable<RequestForInformationDocumentScalarFieldEnum>
  }


  /**
   * requestForInformationDocument findMany
   */
  export type requestForInformationDocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
    /**
     * Filter, which requestForInformationDocuments to fetch.
     * 
    **/
    where?: requestForInformationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestForInformationDocuments to fetch.
     * 
    **/
    orderBy?: Enumerable<requestForInformationDocumentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requestForInformationDocuments.
     * 
    **/
    cursor?: requestForInformationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestForInformationDocuments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestForInformationDocuments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestForInformationDocumentScalarFieldEnum>
  }


  /**
   * requestForInformationDocument create
   */
  export type requestForInformationDocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
    /**
     * The data needed to create a requestForInformationDocument.
     * 
    **/
    data: XOR<requestForInformationDocumentCreateInput, requestForInformationDocumentUncheckedCreateInput>
  }


  /**
   * requestForInformationDocument createMany
   */
  export type requestForInformationDocumentCreateManyArgs = {
    data: Enumerable<requestForInformationDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * requestForInformationDocument update
   */
  export type requestForInformationDocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
    /**
     * The data needed to update a requestForInformationDocument.
     * 
    **/
    data: XOR<requestForInformationDocumentUpdateInput, requestForInformationDocumentUncheckedUpdateInput>
    /**
     * Choose, which requestForInformationDocument to update.
     * 
    **/
    where: requestForInformationDocumentWhereUniqueInput
  }


  /**
   * requestForInformationDocument updateMany
   */
  export type requestForInformationDocumentUpdateManyArgs = {
    data: XOR<requestForInformationDocumentUpdateManyMutationInput, requestForInformationDocumentUncheckedUpdateManyInput>
    where?: requestForInformationDocumentWhereInput
  }


  /**
   * requestForInformationDocument upsert
   */
  export type requestForInformationDocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
    /**
     * The filter to search for the requestForInformationDocument to update in case it exists.
     * 
    **/
    where: requestForInformationDocumentWhereUniqueInput
    /**
     * In case the requestForInformationDocument found by the `where` argument doesn't exist, create a new requestForInformationDocument with this data.
     * 
    **/
    create: XOR<requestForInformationDocumentCreateInput, requestForInformationDocumentUncheckedCreateInput>
    /**
     * In case the requestForInformationDocument was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<requestForInformationDocumentUpdateInput, requestForInformationDocumentUncheckedUpdateInput>
  }


  /**
   * requestForInformationDocument delete
   */
  export type requestForInformationDocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
    /**
     * Filter which requestForInformationDocument to delete.
     * 
    **/
    where: requestForInformationDocumentWhereUniqueInput
  }


  /**
   * requestForInformationDocument deleteMany
   */
  export type requestForInformationDocumentDeleteManyArgs = {
    where?: requestForInformationDocumentWhereInput
  }


  /**
   * requestForInformationDocument without action
   */
  export type requestForInformationDocumentArgs = {
    /**
     * Select specific fields to fetch from the requestForInformationDocument
     * 
    **/
    select?: requestForInformationDocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: requestForInformationDocumentInclude | null
  }



  /**
   * Model statusReport
   */


  export type AggregateStatusReport = {
    _count: StatusReportCountAggregateOutputType | null
    count: StatusReportCountAggregateOutputType | null
    _avg: StatusReportAvgAggregateOutputType | null
    avg: StatusReportAvgAggregateOutputType | null
    _sum: StatusReportSumAggregateOutputType | null
    sum: StatusReportSumAggregateOutputType | null
    _min: StatusReportMinAggregateOutputType | null
    min: StatusReportMinAggregateOutputType | null
    _max: StatusReportMaxAggregateOutputType | null
    max: StatusReportMaxAggregateOutputType | null
  }

  export type StatusReportAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type StatusReportSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
  }

  export type StatusReportMinAggregateOutputType = {
    Id: number | null
    Status: string | null
    CodeReportId: number | null
  }

  export type StatusReportMaxAggregateOutputType = {
    Id: number | null
    Status: string | null
    CodeReportId: number | null
  }

  export type StatusReportCountAggregateOutputType = {
    Id: number
    Status: number
    CodeReportId: number
    _all: number
  }


  export type StatusReportAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type StatusReportSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
  }

  export type StatusReportMinAggregateInputType = {
    Id?: true
    Status?: true
    CodeReportId?: true
  }

  export type StatusReportMaxAggregateInputType = {
    Id?: true
    Status?: true
    CodeReportId?: true
  }

  export type StatusReportCountAggregateInputType = {
    Id?: true
    Status?: true
    CodeReportId?: true
    _all?: true
  }

  export type StatusReportAggregateArgs = {
    /**
     * Filter which statusReport to aggregate.
     * 
    **/
    where?: statusReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusReports to fetch.
     * 
    **/
    orderBy?: Enumerable<statusReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: statusReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statusReports
    **/
    _count?: true | StatusReportCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | StatusReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusReportAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: StatusReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusReportSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: StatusReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusReportMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: StatusReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusReportMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: StatusReportMaxAggregateInputType
  }

  export type GetStatusReportAggregateType<T extends StatusReportAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusReport[P]>
      : GetScalarType<T[P], AggregateStatusReport[P]>
  }


    
    
  export type StatusReportGroupByArgs = {
    where?: statusReportWhereInput
    orderBy?: Enumerable<statusReportOrderByInput>
    by: Array<StatusReportScalarFieldEnum>
    having?: statusReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusReportCountAggregateInputType | true
    _avg?: StatusReportAvgAggregateInputType
    _sum?: StatusReportSumAggregateInputType
    _min?: StatusReportMinAggregateInputType
    _max?: StatusReportMaxAggregateInputType
  }


  export type StatusReportGroupByOutputType = {
    Id: number
    Status: string
    CodeReportId: number
    _count: StatusReportCountAggregateOutputType | null
    _avg: StatusReportAvgAggregateOutputType | null
    _sum: StatusReportSumAggregateOutputType | null
    _min: StatusReportMinAggregateOutputType | null
    _max: StatusReportMaxAggregateOutputType | null
  }

  type GetStatusReportGroupByPayload<T extends StatusReportGroupByArgs> = Promise<
    Array<
      PickArray<StatusReportGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StatusReportGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StatusReportGroupByOutputType[P]> 
            : GetScalarType<T[P], StatusReportGroupByOutputType[P]>
        }
      > 
    >


  export type statusReportSelect = {
    Id?: boolean
    Status?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | codeReportArgs
    StatusReportImage?: boolean | statusReportImageFindManyArgs
  }

  export type statusReportInclude = {
    CodeReport?: boolean | codeReportArgs
    StatusReportImage?: boolean | statusReportImageFindManyArgs
  }

  export type statusReportGetPayload<
    S extends boolean | null | undefined | statusReportArgs,
    U = keyof S
      > = S extends true
        ? statusReport
    : S extends undefined
    ? never
    : S extends statusReportArgs | statusReportFindManyArgs
    ?'include' extends U
    ? statusReport  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> :
        P extends 'StatusReportImage'
        ? Array < statusReportImageGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof statusReport ?statusReport [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> :
        P extends 'StatusReportImage'
        ? Array < statusReportImageGetPayload<S['select'][P]>>  : never
  } 
    : statusReport
  : statusReport


  type statusReportCountArgs = Merge<
    Omit<statusReportFindManyArgs, 'select' | 'include'> & {
      select?: StatusReportCountAggregateInputType | true
    }
  >

  export interface statusReportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StatusReport that matches the filter.
     * @param {statusReportFindUniqueArgs} args - Arguments to find a StatusReport
     * @example
     * // Get one StatusReport
     * const statusReport = await prisma.statusReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends statusReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, statusReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'statusReport'> extends True ? CheckSelect<T, Prisma__statusReportClient<statusReport>, Prisma__statusReportClient<statusReportGetPayload<T>>> : CheckSelect<T, Prisma__statusReportClient<statusReport | null >, Prisma__statusReportClient<statusReportGetPayload<T> | null >>

    /**
     * Find the first StatusReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportFindFirstArgs} args - Arguments to find a StatusReport
     * @example
     * // Get one StatusReport
     * const statusReport = await prisma.statusReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends statusReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, statusReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'statusReport'> extends True ? CheckSelect<T, Prisma__statusReportClient<statusReport>, Prisma__statusReportClient<statusReportGetPayload<T>>> : CheckSelect<T, Prisma__statusReportClient<statusReport | null >, Prisma__statusReportClient<statusReportGetPayload<T> | null >>

    /**
     * Find zero or more StatusReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusReports
     * const statusReports = await prisma.statusReport.findMany()
     * 
     * // Get first 10 StatusReports
     * const statusReports = await prisma.statusReport.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const statusReportWithIdOnly = await prisma.statusReport.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends statusReportFindManyArgs>(
      args?: SelectSubset<T, statusReportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<statusReport>>, PrismaPromise<Array<statusReportGetPayload<T>>>>

    /**
     * Create a StatusReport.
     * @param {statusReportCreateArgs} args - Arguments to create a StatusReport.
     * @example
     * // Create one StatusReport
     * const StatusReport = await prisma.statusReport.create({
     *   data: {
     *     // ... data to create a StatusReport
     *   }
     * })
     * 
    **/
    create<T extends statusReportCreateArgs>(
      args: SelectSubset<T, statusReportCreateArgs>
    ): CheckSelect<T, Prisma__statusReportClient<statusReport>, Prisma__statusReportClient<statusReportGetPayload<T>>>

    /**
     * Create many StatusReports.
     *     @param {statusReportCreateManyArgs} args - Arguments to create many StatusReports.
     *     @example
     *     // Create many StatusReports
     *     const statusReport = await prisma.statusReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends statusReportCreateManyArgs>(
      args?: SelectSubset<T, statusReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StatusReport.
     * @param {statusReportDeleteArgs} args - Arguments to delete one StatusReport.
     * @example
     * // Delete one StatusReport
     * const StatusReport = await prisma.statusReport.delete({
     *   where: {
     *     // ... filter to delete one StatusReport
     *   }
     * })
     * 
    **/
    delete<T extends statusReportDeleteArgs>(
      args: SelectSubset<T, statusReportDeleteArgs>
    ): CheckSelect<T, Prisma__statusReportClient<statusReport>, Prisma__statusReportClient<statusReportGetPayload<T>>>

    /**
     * Update one StatusReport.
     * @param {statusReportUpdateArgs} args - Arguments to update one StatusReport.
     * @example
     * // Update one StatusReport
     * const statusReport = await prisma.statusReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends statusReportUpdateArgs>(
      args: SelectSubset<T, statusReportUpdateArgs>
    ): CheckSelect<T, Prisma__statusReportClient<statusReport>, Prisma__statusReportClient<statusReportGetPayload<T>>>

    /**
     * Delete zero or more StatusReports.
     * @param {statusReportDeleteManyArgs} args - Arguments to filter StatusReports to delete.
     * @example
     * // Delete a few StatusReports
     * const { count } = await prisma.statusReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends statusReportDeleteManyArgs>(
      args?: SelectSubset<T, statusReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusReports
     * const statusReport = await prisma.statusReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends statusReportUpdateManyArgs>(
      args: SelectSubset<T, statusReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusReport.
     * @param {statusReportUpsertArgs} args - Arguments to update or create a StatusReport.
     * @example
     * // Update or create a StatusReport
     * const statusReport = await prisma.statusReport.upsert({
     *   create: {
     *     // ... data to create a StatusReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusReport we want to update
     *   }
     * })
    **/
    upsert<T extends statusReportUpsertArgs>(
      args: SelectSubset<T, statusReportUpsertArgs>
    ): CheckSelect<T, Prisma__statusReportClient<statusReport>, Prisma__statusReportClient<statusReportGetPayload<T>>>

    /**
     * Count the number of StatusReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportCountArgs} args - Arguments to filter StatusReports to count.
     * @example
     * // Count the number of StatusReports
     * const count = await prisma.statusReport.count({
     *   where: {
     *     // ... the filter for the StatusReports we want to count
     *   }
     * })
    **/
    count<T extends statusReportCountArgs>(
      args?: Subset<T, statusReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusReportAggregateArgs>(args: Subset<T, StatusReportAggregateArgs>): PrismaPromise<GetStatusReportAggregateType<T>>

    /**
     * Group by StatusReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusReportGroupByArgs['orderBy'] }
        : { orderBy?: StatusReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusReportGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for statusReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__statusReportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    StatusReportImage<T extends statusReportImageFindManyArgs = {}>(args?: Subset<T, statusReportImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<statusReportImage>>, PrismaPromise<Array<statusReportImageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * statusReport findUnique
   */
  export type statusReportFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
    /**
     * Throw an Error if a statusReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which statusReport to fetch.
     * 
    **/
    where: statusReportWhereUniqueInput
  }


  /**
   * statusReport findFirst
   */
  export type statusReportFindFirstArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
    /**
     * Throw an Error if a statusReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which statusReport to fetch.
     * 
    **/
    where?: statusReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusReports to fetch.
     * 
    **/
    orderBy?: Enumerable<statusReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusReports.
     * 
    **/
    cursor?: statusReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusReports.
     * 
    **/
    distinct?: Enumerable<StatusReportScalarFieldEnum>
  }


  /**
   * statusReport findMany
   */
  export type statusReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
    /**
     * Filter, which statusReports to fetch.
     * 
    **/
    where?: statusReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusReports to fetch.
     * 
    **/
    orderBy?: Enumerable<statusReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statusReports.
     * 
    **/
    cursor?: statusReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusReports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StatusReportScalarFieldEnum>
  }


  /**
   * statusReport create
   */
  export type statusReportCreateArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
    /**
     * The data needed to create a statusReport.
     * 
    **/
    data: XOR<statusReportCreateInput, statusReportUncheckedCreateInput>
  }


  /**
   * statusReport createMany
   */
  export type statusReportCreateManyArgs = {
    data: Enumerable<statusReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * statusReport update
   */
  export type statusReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
    /**
     * The data needed to update a statusReport.
     * 
    **/
    data: XOR<statusReportUpdateInput, statusReportUncheckedUpdateInput>
    /**
     * Choose, which statusReport to update.
     * 
    **/
    where: statusReportWhereUniqueInput
  }


  /**
   * statusReport updateMany
   */
  export type statusReportUpdateManyArgs = {
    data: XOR<statusReportUpdateManyMutationInput, statusReportUncheckedUpdateManyInput>
    where?: statusReportWhereInput
  }


  /**
   * statusReport upsert
   */
  export type statusReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
    /**
     * The filter to search for the statusReport to update in case it exists.
     * 
    **/
    where: statusReportWhereUniqueInput
    /**
     * In case the statusReport found by the `where` argument doesn't exist, create a new statusReport with this data.
     * 
    **/
    create: XOR<statusReportCreateInput, statusReportUncheckedCreateInput>
    /**
     * In case the statusReport was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<statusReportUpdateInput, statusReportUncheckedUpdateInput>
  }


  /**
   * statusReport delete
   */
  export type statusReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
    /**
     * Filter which statusReport to delete.
     * 
    **/
    where: statusReportWhereUniqueInput
  }


  /**
   * statusReport deleteMany
   */
  export type statusReportDeleteManyArgs = {
    where?: statusReportWhereInput
  }


  /**
   * statusReport without action
   */
  export type statusReportArgs = {
    /**
     * Select specific fields to fetch from the statusReport
     * 
    **/
    select?: statusReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportInclude | null
  }



  /**
   * Model statusReportImage
   */


  export type AggregateStatusReportImage = {
    _count: StatusReportImageCountAggregateOutputType | null
    count: StatusReportImageCountAggregateOutputType | null
    _avg: StatusReportImageAvgAggregateOutputType | null
    avg: StatusReportImageAvgAggregateOutputType | null
    _sum: StatusReportImageSumAggregateOutputType | null
    sum: StatusReportImageSumAggregateOutputType | null
    _min: StatusReportImageMinAggregateOutputType | null
    min: StatusReportImageMinAggregateOutputType | null
    _max: StatusReportImageMaxAggregateOutputType | null
    max: StatusReportImageMaxAggregateOutputType | null
  }

  export type StatusReportImageAvgAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
  }

  export type StatusReportImageSumAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
  }

  export type StatusReportImageMinAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type StatusReportImageMaxAggregateOutputType = {
    Id: number | null
    StatusReportId: number | null
    ImageUrl: string | null
    Name: string | null
  }

  export type StatusReportImageCountAggregateOutputType = {
    Id: number
    StatusReportId: number
    ImageUrl: number
    Name: number
    _all: number
  }


  export type StatusReportImageAvgAggregateInputType = {
    Id?: true
    StatusReportId?: true
  }

  export type StatusReportImageSumAggregateInputType = {
    Id?: true
    StatusReportId?: true
  }

  export type StatusReportImageMinAggregateInputType = {
    Id?: true
    StatusReportId?: true
    ImageUrl?: true
    Name?: true
  }

  export type StatusReportImageMaxAggregateInputType = {
    Id?: true
    StatusReportId?: true
    ImageUrl?: true
    Name?: true
  }

  export type StatusReportImageCountAggregateInputType = {
    Id?: true
    StatusReportId?: true
    ImageUrl?: true
    Name?: true
    _all?: true
  }

  export type StatusReportImageAggregateArgs = {
    /**
     * Filter which statusReportImage to aggregate.
     * 
    **/
    where?: statusReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<statusReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: statusReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statusReportImages
    **/
    _count?: true | StatusReportImageCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | StatusReportImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusReportImageAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: StatusReportImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusReportImageSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: StatusReportImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusReportImageMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: StatusReportImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusReportImageMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: StatusReportImageMaxAggregateInputType
  }

  export type GetStatusReportImageAggregateType<T extends StatusReportImageAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusReportImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusReportImage[P]>
      : GetScalarType<T[P], AggregateStatusReportImage[P]>
  }


    
    
  export type StatusReportImageGroupByArgs = {
    where?: statusReportImageWhereInput
    orderBy?: Enumerable<statusReportImageOrderByInput>
    by: Array<StatusReportImageScalarFieldEnum>
    having?: statusReportImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusReportImageCountAggregateInputType | true
    _avg?: StatusReportImageAvgAggregateInputType
    _sum?: StatusReportImageSumAggregateInputType
    _min?: StatusReportImageMinAggregateInputType
    _max?: StatusReportImageMaxAggregateInputType
  }


  export type StatusReportImageGroupByOutputType = {
    Id: number
    StatusReportId: number
    ImageUrl: string
    Name: string
    _count: StatusReportImageCountAggregateOutputType | null
    _avg: StatusReportImageAvgAggregateOutputType | null
    _sum: StatusReportImageSumAggregateOutputType | null
    _min: StatusReportImageMinAggregateOutputType | null
    _max: StatusReportImageMaxAggregateOutputType | null
  }

  type GetStatusReportImageGroupByPayload<T extends StatusReportImageGroupByArgs> = Promise<
    Array<
      PickArray<StatusReportImageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StatusReportImageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StatusReportImageGroupByOutputType[P]> 
            : GetScalarType<T[P], StatusReportImageGroupByOutputType[P]>
        }
      > 
    >


  export type statusReportImageSelect = {
    Id?: boolean
    StatusReportId?: boolean
    ImageUrl?: boolean
    Name?: boolean
    StatusReport?: boolean | statusReportArgs
  }

  export type statusReportImageInclude = {
    StatusReport?: boolean | statusReportArgs
  }

  export type statusReportImageGetPayload<
    S extends boolean | null | undefined | statusReportImageArgs,
    U = keyof S
      > = S extends true
        ? statusReportImage
    : S extends undefined
    ? never
    : S extends statusReportImageArgs | statusReportImageFindManyArgs
    ?'include' extends U
    ? statusReportImage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'StatusReport'
        ? statusReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof statusReportImage ?statusReportImage [P]
  : 
          P extends 'StatusReport'
        ? statusReportGetPayload<S['select'][P]> : never
  } 
    : statusReportImage
  : statusReportImage


  type statusReportImageCountArgs = Merge<
    Omit<statusReportImageFindManyArgs, 'select' | 'include'> & {
      select?: StatusReportImageCountAggregateInputType | true
    }
  >

  export interface statusReportImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StatusReportImage that matches the filter.
     * @param {statusReportImageFindUniqueArgs} args - Arguments to find a StatusReportImage
     * @example
     * // Get one StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends statusReportImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, statusReportImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'statusReportImage'> extends True ? CheckSelect<T, Prisma__statusReportImageClient<statusReportImage>, Prisma__statusReportImageClient<statusReportImageGetPayload<T>>> : CheckSelect<T, Prisma__statusReportImageClient<statusReportImage | null >, Prisma__statusReportImageClient<statusReportImageGetPayload<T> | null >>

    /**
     * Find the first StatusReportImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportImageFindFirstArgs} args - Arguments to find a StatusReportImage
     * @example
     * // Get one StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends statusReportImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, statusReportImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'statusReportImage'> extends True ? CheckSelect<T, Prisma__statusReportImageClient<statusReportImage>, Prisma__statusReportImageClient<statusReportImageGetPayload<T>>> : CheckSelect<T, Prisma__statusReportImageClient<statusReportImage | null >, Prisma__statusReportImageClient<statusReportImageGetPayload<T> | null >>

    /**
     * Find zero or more StatusReportImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusReportImages
     * const statusReportImages = await prisma.statusReportImage.findMany()
     * 
     * // Get first 10 StatusReportImages
     * const statusReportImages = await prisma.statusReportImage.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const statusReportImageWithIdOnly = await prisma.statusReportImage.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends statusReportImageFindManyArgs>(
      args?: SelectSubset<T, statusReportImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<statusReportImage>>, PrismaPromise<Array<statusReportImageGetPayload<T>>>>

    /**
     * Create a StatusReportImage.
     * @param {statusReportImageCreateArgs} args - Arguments to create a StatusReportImage.
     * @example
     * // Create one StatusReportImage
     * const StatusReportImage = await prisma.statusReportImage.create({
     *   data: {
     *     // ... data to create a StatusReportImage
     *   }
     * })
     * 
    **/
    create<T extends statusReportImageCreateArgs>(
      args: SelectSubset<T, statusReportImageCreateArgs>
    ): CheckSelect<T, Prisma__statusReportImageClient<statusReportImage>, Prisma__statusReportImageClient<statusReportImageGetPayload<T>>>

    /**
     * Create many StatusReportImages.
     *     @param {statusReportImageCreateManyArgs} args - Arguments to create many StatusReportImages.
     *     @example
     *     // Create many StatusReportImages
     *     const statusReportImage = await prisma.statusReportImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends statusReportImageCreateManyArgs>(
      args?: SelectSubset<T, statusReportImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StatusReportImage.
     * @param {statusReportImageDeleteArgs} args - Arguments to delete one StatusReportImage.
     * @example
     * // Delete one StatusReportImage
     * const StatusReportImage = await prisma.statusReportImage.delete({
     *   where: {
     *     // ... filter to delete one StatusReportImage
     *   }
     * })
     * 
    **/
    delete<T extends statusReportImageDeleteArgs>(
      args: SelectSubset<T, statusReportImageDeleteArgs>
    ): CheckSelect<T, Prisma__statusReportImageClient<statusReportImage>, Prisma__statusReportImageClient<statusReportImageGetPayload<T>>>

    /**
     * Update one StatusReportImage.
     * @param {statusReportImageUpdateArgs} args - Arguments to update one StatusReportImage.
     * @example
     * // Update one StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends statusReportImageUpdateArgs>(
      args: SelectSubset<T, statusReportImageUpdateArgs>
    ): CheckSelect<T, Prisma__statusReportImageClient<statusReportImage>, Prisma__statusReportImageClient<statusReportImageGetPayload<T>>>

    /**
     * Delete zero or more StatusReportImages.
     * @param {statusReportImageDeleteManyArgs} args - Arguments to filter StatusReportImages to delete.
     * @example
     * // Delete a few StatusReportImages
     * const { count } = await prisma.statusReportImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends statusReportImageDeleteManyArgs>(
      args?: SelectSubset<T, statusReportImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusReportImages
     * const statusReportImage = await prisma.statusReportImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends statusReportImageUpdateManyArgs>(
      args: SelectSubset<T, statusReportImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusReportImage.
     * @param {statusReportImageUpsertArgs} args - Arguments to update or create a StatusReportImage.
     * @example
     * // Update or create a StatusReportImage
     * const statusReportImage = await prisma.statusReportImage.upsert({
     *   create: {
     *     // ... data to create a StatusReportImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusReportImage we want to update
     *   }
     * })
    **/
    upsert<T extends statusReportImageUpsertArgs>(
      args: SelectSubset<T, statusReportImageUpsertArgs>
    ): CheckSelect<T, Prisma__statusReportImageClient<statusReportImage>, Prisma__statusReportImageClient<statusReportImageGetPayload<T>>>

    /**
     * Count the number of StatusReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusReportImageCountArgs} args - Arguments to filter StatusReportImages to count.
     * @example
     * // Count the number of StatusReportImages
     * const count = await prisma.statusReportImage.count({
     *   where: {
     *     // ... the filter for the StatusReportImages we want to count
     *   }
     * })
    **/
    count<T extends statusReportImageCountArgs>(
      args?: Subset<T, statusReportImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusReportImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusReportImageAggregateArgs>(args: Subset<T, StatusReportImageAggregateArgs>): PrismaPromise<GetStatusReportImageAggregateType<T>>

    /**
     * Group by StatusReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusReportImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusReportImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusReportImageGroupByArgs['orderBy'] }
        : { orderBy?: StatusReportImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusReportImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusReportImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for statusReportImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__statusReportImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StatusReport<T extends statusReportArgs = {}>(args?: Subset<T, statusReportArgs>): CheckSelect<T, Prisma__statusReportClient<statusReport | null >, Prisma__statusReportClient<statusReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * statusReportImage findUnique
   */
  export type statusReportImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
    /**
     * Throw an Error if a statusReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which statusReportImage to fetch.
     * 
    **/
    where: statusReportImageWhereUniqueInput
  }


  /**
   * statusReportImage findFirst
   */
  export type statusReportImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
    /**
     * Throw an Error if a statusReportImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which statusReportImage to fetch.
     * 
    **/
    where?: statusReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<statusReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusReportImages.
     * 
    **/
    cursor?: statusReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusReportImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusReportImages.
     * 
    **/
    distinct?: Enumerable<StatusReportImageScalarFieldEnum>
  }


  /**
   * statusReportImage findMany
   */
  export type statusReportImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
    /**
     * Filter, which statusReportImages to fetch.
     * 
    **/
    where?: statusReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusReportImages to fetch.
     * 
    **/
    orderBy?: Enumerable<statusReportImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statusReportImages.
     * 
    **/
    cursor?: statusReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusReportImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusReportImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StatusReportImageScalarFieldEnum>
  }


  /**
   * statusReportImage create
   */
  export type statusReportImageCreateArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
    /**
     * The data needed to create a statusReportImage.
     * 
    **/
    data: XOR<statusReportImageCreateInput, statusReportImageUncheckedCreateInput>
  }


  /**
   * statusReportImage createMany
   */
  export type statusReportImageCreateManyArgs = {
    data: Enumerable<statusReportImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * statusReportImage update
   */
  export type statusReportImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
    /**
     * The data needed to update a statusReportImage.
     * 
    **/
    data: XOR<statusReportImageUpdateInput, statusReportImageUncheckedUpdateInput>
    /**
     * Choose, which statusReportImage to update.
     * 
    **/
    where: statusReportImageWhereUniqueInput
  }


  /**
   * statusReportImage updateMany
   */
  export type statusReportImageUpdateManyArgs = {
    data: XOR<statusReportImageUpdateManyMutationInput, statusReportImageUncheckedUpdateManyInput>
    where?: statusReportImageWhereInput
  }


  /**
   * statusReportImage upsert
   */
  export type statusReportImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
    /**
     * The filter to search for the statusReportImage to update in case it exists.
     * 
    **/
    where: statusReportImageWhereUniqueInput
    /**
     * In case the statusReportImage found by the `where` argument doesn't exist, create a new statusReportImage with this data.
     * 
    **/
    create: XOR<statusReportImageCreateInput, statusReportImageUncheckedCreateInput>
    /**
     * In case the statusReportImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<statusReportImageUpdateInput, statusReportImageUncheckedUpdateInput>
  }


  /**
   * statusReportImage delete
   */
  export type statusReportImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
    /**
     * Filter which statusReportImage to delete.
     * 
    **/
    where: statusReportImageWhereUniqueInput
  }


  /**
   * statusReportImage deleteMany
   */
  export type statusReportImageDeleteManyArgs = {
    where?: statusReportImageWhereInput
  }


  /**
   * statusReportImage without action
   */
  export type statusReportImageArgs = {
    /**
     * Select specific fields to fetch from the statusReportImage
     * 
    **/
    select?: statusReportImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: statusReportImageInclude | null
  }



  /**
   * Model tool
   */


  export type AggregateTool = {
    _count: ToolCountAggregateOutputType | null
    count: ToolCountAggregateOutputType | null
    _avg: ToolAvgAggregateOutputType | null
    avg: ToolAvgAggregateOutputType | null
    _sum: ToolSumAggregateOutputType | null
    sum: ToolSumAggregateOutputType | null
    _min: ToolMinAggregateOutputType | null
    min: ToolMinAggregateOutputType | null
    _max: ToolMaxAggregateOutputType | null
    max: ToolMaxAggregateOutputType | null
  }

  export type ToolAvgAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolSumAggregateOutputType = {
    Id: number | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Description: string | null
    Quantity: number | null
    CodeReportId: number | null
  }

  export type ToolCountAggregateOutputType = {
    Id: number
    Name: number
    Description: number
    Quantity: number
    CodeReportId: number
    _all: number
  }


  export type ToolAvgAggregateInputType = {
    Id?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolSumAggregateInputType = {
    Id?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolMinAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolMaxAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Quantity?: true
    CodeReportId?: true
  }

  export type ToolCountAggregateInputType = {
    Id?: true
    Name?: true
    Description?: true
    Quantity?: true
    CodeReportId?: true
    _all?: true
  }

  export type ToolAggregateArgs = {
    /**
     * Filter which tool to aggregate.
     * 
    **/
    where?: toolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tools to fetch.
     * 
    **/
    orderBy?: Enumerable<toolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: toolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tools.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tools
    **/
    _count?: true | ToolCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ToolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ToolAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ToolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ToolSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ToolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToolMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ToolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToolMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ToolMaxAggregateInputType
  }

  export type GetToolAggregateType<T extends ToolAggregateArgs> = {
        [P in keyof T & keyof AggregateTool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTool[P]>
      : GetScalarType<T[P], AggregateTool[P]>
  }


    
    
  export type ToolGroupByArgs = {
    where?: toolWhereInput
    orderBy?: Enumerable<toolOrderByInput>
    by: Array<ToolScalarFieldEnum>
    having?: toolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToolCountAggregateInputType | true
    _avg?: ToolAvgAggregateInputType
    _sum?: ToolSumAggregateInputType
    _min?: ToolMinAggregateInputType
    _max?: ToolMaxAggregateInputType
  }


  export type ToolGroupByOutputType = {
    Id: number
    Name: string
    Description: string
    Quantity: number
    CodeReportId: number
    _count: ToolCountAggregateOutputType | null
    _avg: ToolAvgAggregateOutputType | null
    _sum: ToolSumAggregateOutputType | null
    _min: ToolMinAggregateOutputType | null
    _max: ToolMaxAggregateOutputType | null
  }

  type GetToolGroupByPayload<T extends ToolGroupByArgs> = Promise<
    Array<
      PickArray<ToolGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ToolGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ToolGroupByOutputType[P]> 
            : GetScalarType<T[P], ToolGroupByOutputType[P]>
        }
      > 
    >


  export type toolSelect = {
    Id?: boolean
    Name?: boolean
    Description?: boolean
    Quantity?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | codeReportArgs
  }

  export type toolInclude = {
    CodeReport?: boolean | codeReportArgs
  }

  export type toolGetPayload<
    S extends boolean | null | undefined | toolArgs,
    U = keyof S
      > = S extends true
        ? tool
    : S extends undefined
    ? never
    : S extends toolArgs | toolFindManyArgs
    ?'include' extends U
    ? tool  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof tool ?tool [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> : never
  } 
    : tool
  : tool


  type toolCountArgs = Merge<
    Omit<toolFindManyArgs, 'select' | 'include'> & {
      select?: ToolCountAggregateInputType | true
    }
  >

  export interface toolDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tool that matches the filter.
     * @param {toolFindUniqueArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends toolFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, toolFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tool'> extends True ? CheckSelect<T, Prisma__toolClient<tool>, Prisma__toolClient<toolGetPayload<T>>> : CheckSelect<T, Prisma__toolClient<tool | null >, Prisma__toolClient<toolGetPayload<T> | null >>

    /**
     * Find the first Tool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toolFindFirstArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends toolFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, toolFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tool'> extends True ? CheckSelect<T, Prisma__toolClient<tool>, Prisma__toolClient<toolGetPayload<T>>> : CheckSelect<T, Prisma__toolClient<tool | null >, Prisma__toolClient<toolGetPayload<T> | null >>

    /**
     * Find zero or more Tools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tools
     * const tools = await prisma.tool.findMany()
     * 
     * // Get first 10 Tools
     * const tools = await prisma.tool.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const toolWithIdOnly = await prisma.tool.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends toolFindManyArgs>(
      args?: SelectSubset<T, toolFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<tool>>, PrismaPromise<Array<toolGetPayload<T>>>>

    /**
     * Create a Tool.
     * @param {toolCreateArgs} args - Arguments to create a Tool.
     * @example
     * // Create one Tool
     * const Tool = await prisma.tool.create({
     *   data: {
     *     // ... data to create a Tool
     *   }
     * })
     * 
    **/
    create<T extends toolCreateArgs>(
      args: SelectSubset<T, toolCreateArgs>
    ): CheckSelect<T, Prisma__toolClient<tool>, Prisma__toolClient<toolGetPayload<T>>>

    /**
     * Create many Tools.
     *     @param {toolCreateManyArgs} args - Arguments to create many Tools.
     *     @example
     *     // Create many Tools
     *     const tool = await prisma.tool.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends toolCreateManyArgs>(
      args?: SelectSubset<T, toolCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tool.
     * @param {toolDeleteArgs} args - Arguments to delete one Tool.
     * @example
     * // Delete one Tool
     * const Tool = await prisma.tool.delete({
     *   where: {
     *     // ... filter to delete one Tool
     *   }
     * })
     * 
    **/
    delete<T extends toolDeleteArgs>(
      args: SelectSubset<T, toolDeleteArgs>
    ): CheckSelect<T, Prisma__toolClient<tool>, Prisma__toolClient<toolGetPayload<T>>>

    /**
     * Update one Tool.
     * @param {toolUpdateArgs} args - Arguments to update one Tool.
     * @example
     * // Update one Tool
     * const tool = await prisma.tool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends toolUpdateArgs>(
      args: SelectSubset<T, toolUpdateArgs>
    ): CheckSelect<T, Prisma__toolClient<tool>, Prisma__toolClient<toolGetPayload<T>>>

    /**
     * Delete zero or more Tools.
     * @param {toolDeleteManyArgs} args - Arguments to filter Tools to delete.
     * @example
     * // Delete a few Tools
     * const { count } = await prisma.tool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends toolDeleteManyArgs>(
      args?: SelectSubset<T, toolDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tools
     * const tool = await prisma.tool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends toolUpdateManyArgs>(
      args: SelectSubset<T, toolUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tool.
     * @param {toolUpsertArgs} args - Arguments to update or create a Tool.
     * @example
     * // Update or create a Tool
     * const tool = await prisma.tool.upsert({
     *   create: {
     *     // ... data to create a Tool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tool we want to update
     *   }
     * })
    **/
    upsert<T extends toolUpsertArgs>(
      args: SelectSubset<T, toolUpsertArgs>
    ): CheckSelect<T, Prisma__toolClient<tool>, Prisma__toolClient<toolGetPayload<T>>>

    /**
     * Count the number of Tools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {toolCountArgs} args - Arguments to filter Tools to count.
     * @example
     * // Count the number of Tools
     * const count = await prisma.tool.count({
     *   where: {
     *     // ... the filter for the Tools we want to count
     *   }
     * })
    **/
    count<T extends toolCountArgs>(
      args?: Subset<T, toolCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToolAggregateArgs>(args: Subset<T, ToolAggregateArgs>): PrismaPromise<GetToolAggregateType<T>>

    /**
     * Group by Tool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToolGroupByArgs['orderBy'] }
        : { orderBy?: ToolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToolGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for tool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__toolClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * tool findUnique
   */
  export type toolFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
    /**
     * Throw an Error if a tool can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which tool to fetch.
     * 
    **/
    where: toolWhereUniqueInput
  }


  /**
   * tool findFirst
   */
  export type toolFindFirstArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
    /**
     * Throw an Error if a tool can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which tool to fetch.
     * 
    **/
    where?: toolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tools to fetch.
     * 
    **/
    orderBy?: Enumerable<toolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tools.
     * 
    **/
    cursor?: toolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tools.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tools.
     * 
    **/
    distinct?: Enumerable<ToolScalarFieldEnum>
  }


  /**
   * tool findMany
   */
  export type toolFindManyArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
    /**
     * Filter, which tools to fetch.
     * 
    **/
    where?: toolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tools to fetch.
     * 
    **/
    orderBy?: Enumerable<toolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tools.
     * 
    **/
    cursor?: toolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tools.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ToolScalarFieldEnum>
  }


  /**
   * tool create
   */
  export type toolCreateArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
    /**
     * The data needed to create a tool.
     * 
    **/
    data: XOR<toolCreateInput, toolUncheckedCreateInput>
  }


  /**
   * tool createMany
   */
  export type toolCreateManyArgs = {
    data: Enumerable<toolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tool update
   */
  export type toolUpdateArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
    /**
     * The data needed to update a tool.
     * 
    **/
    data: XOR<toolUpdateInput, toolUncheckedUpdateInput>
    /**
     * Choose, which tool to update.
     * 
    **/
    where: toolWhereUniqueInput
  }


  /**
   * tool updateMany
   */
  export type toolUpdateManyArgs = {
    data: XOR<toolUpdateManyMutationInput, toolUncheckedUpdateManyInput>
    where?: toolWhereInput
  }


  /**
   * tool upsert
   */
  export type toolUpsertArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
    /**
     * The filter to search for the tool to update in case it exists.
     * 
    **/
    where: toolWhereUniqueInput
    /**
     * In case the tool found by the `where` argument doesn't exist, create a new tool with this data.
     * 
    **/
    create: XOR<toolCreateInput, toolUncheckedCreateInput>
    /**
     * In case the tool was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<toolUpdateInput, toolUncheckedUpdateInput>
  }


  /**
   * tool delete
   */
  export type toolDeleteArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
    /**
     * Filter which tool to delete.
     * 
    **/
    where: toolWhereUniqueInput
  }


  /**
   * tool deleteMany
   */
  export type toolDeleteManyArgs = {
    where?: toolWhereInput
  }


  /**
   * tool without action
   */
  export type toolArgs = {
    /**
     * Select specific fields to fetch from the tool
     * 
    **/
    select?: toolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: toolInclude | null
  }



  /**
   * Model weather
   */


  export type AggregateWeather = {
    _count: WeatherCountAggregateOutputType | null
    count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
    max: WeatherMaxAggregateOutputType | null
  }

  export type WeatherAvgAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherSumAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherMinAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherMaxAggregateOutputType = {
    Id: number | null
    WeatherId: number | null
    CodeReportId: number | null
  }

  export type WeatherCountAggregateOutputType = {
    Id: number
    WeatherId: number
    CodeReportId: number
    _all: number
  }


  export type WeatherAvgAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherSumAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherMinAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherMaxAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
  }

  export type WeatherCountAggregateInputType = {
    Id?: true
    WeatherId?: true
    CodeReportId?: true
    _all?: true
  }

  export type WeatherAggregateArgs = {
    /**
     * Filter which weather to aggregate.
     * 
    **/
    where?: weatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weathers to fetch.
     * 
    **/
    orderBy?: Enumerable<weatherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weathers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weathers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weathers
    **/
    _count?: true | WeatherCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: WeatherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: WeatherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WeatherMaxAggregateInputType
  }

  export type GetWeatherAggregateType<T extends WeatherAggregateArgs> = {
        [P in keyof T & keyof AggregateWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeather[P]>
      : GetScalarType<T[P], AggregateWeather[P]>
  }


    
    
  export type WeatherGroupByArgs = {
    where?: weatherWhereInput
    orderBy?: Enumerable<weatherOrderByInput>
    by: Array<WeatherScalarFieldEnum>
    having?: weatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherCountAggregateInputType | true
    _avg?: WeatherAvgAggregateInputType
    _sum?: WeatherSumAggregateInputType
    _min?: WeatherMinAggregateInputType
    _max?: WeatherMaxAggregateInputType
  }


  export type WeatherGroupByOutputType = {
    Id: number
    WeatherId: number
    CodeReportId: number
    _count: WeatherCountAggregateOutputType | null
    _avg: WeatherAvgAggregateOutputType | null
    _sum: WeatherSumAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  type GetWeatherGroupByPayload<T extends WeatherGroupByArgs> = Promise<
    Array<
      PickArray<WeatherGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WeatherGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WeatherGroupByOutputType[P]> 
            : GetScalarType<T[P], WeatherGroupByOutputType[P]>
        }
      > 
    >


  export type weatherSelect = {
    Id?: boolean
    WeatherId?: boolean
    CodeReportId?: boolean
    CodeReport?: boolean | codeReportArgs
  }

  export type weatherInclude = {
    CodeReport?: boolean | codeReportArgs
  }

  export type weatherGetPayload<
    S extends boolean | null | undefined | weatherArgs,
    U = keyof S
      > = S extends true
        ? weather
    : S extends undefined
    ? never
    : S extends weatherArgs | weatherFindManyArgs
    ?'include' extends U
    ? weather  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof weather ?weather [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> : never
  } 
    : weather
  : weather


  type weatherCountArgs = Merge<
    Omit<weatherFindManyArgs, 'select' | 'include'> & {
      select?: WeatherCountAggregateInputType | true
    }
  >

  export interface weatherDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weather that matches the filter.
     * @param {weatherFindUniqueArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weatherFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weatherFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weather'> extends True ? CheckSelect<T, Prisma__weatherClient<weather>, Prisma__weatherClient<weatherGetPayload<T>>> : CheckSelect<T, Prisma__weatherClient<weather | null >, Prisma__weatherClient<weatherGetPayload<T> | null >>

    /**
     * Find the first Weather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weatherFindFirstArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weatherFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weatherFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weather'> extends True ? CheckSelect<T, Prisma__weatherClient<weather>, Prisma__weatherClient<weatherGetPayload<T>>> : CheckSelect<T, Prisma__weatherClient<weather | null >, Prisma__weatherClient<weatherGetPayload<T> | null >>

    /**
     * Find zero or more Weathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weatherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weathers
     * const weathers = await prisma.weather.findMany()
     * 
     * // Get first 10 Weathers
     * const weathers = await prisma.weather.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const weatherWithIdOnly = await prisma.weather.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends weatherFindManyArgs>(
      args?: SelectSubset<T, weatherFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weather>>, PrismaPromise<Array<weatherGetPayload<T>>>>

    /**
     * Create a Weather.
     * @param {weatherCreateArgs} args - Arguments to create a Weather.
     * @example
     * // Create one Weather
     * const Weather = await prisma.weather.create({
     *   data: {
     *     // ... data to create a Weather
     *   }
     * })
     * 
    **/
    create<T extends weatherCreateArgs>(
      args: SelectSubset<T, weatherCreateArgs>
    ): CheckSelect<T, Prisma__weatherClient<weather>, Prisma__weatherClient<weatherGetPayload<T>>>

    /**
     * Create many Weathers.
     *     @param {weatherCreateManyArgs} args - Arguments to create many Weathers.
     *     @example
     *     // Create many Weathers
     *     const weather = await prisma.weather.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weatherCreateManyArgs>(
      args?: SelectSubset<T, weatherCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weather.
     * @param {weatherDeleteArgs} args - Arguments to delete one Weather.
     * @example
     * // Delete one Weather
     * const Weather = await prisma.weather.delete({
     *   where: {
     *     // ... filter to delete one Weather
     *   }
     * })
     * 
    **/
    delete<T extends weatherDeleteArgs>(
      args: SelectSubset<T, weatherDeleteArgs>
    ): CheckSelect<T, Prisma__weatherClient<weather>, Prisma__weatherClient<weatherGetPayload<T>>>

    /**
     * Update one Weather.
     * @param {weatherUpdateArgs} args - Arguments to update one Weather.
     * @example
     * // Update one Weather
     * const weather = await prisma.weather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weatherUpdateArgs>(
      args: SelectSubset<T, weatherUpdateArgs>
    ): CheckSelect<T, Prisma__weatherClient<weather>, Prisma__weatherClient<weatherGetPayload<T>>>

    /**
     * Delete zero or more Weathers.
     * @param {weatherDeleteManyArgs} args - Arguments to filter Weathers to delete.
     * @example
     * // Delete a few Weathers
     * const { count } = await prisma.weather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weatherDeleteManyArgs>(
      args?: SelectSubset<T, weatherDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weatherUpdateManyArgs>(
      args: SelectSubset<T, weatherUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weather.
     * @param {weatherUpsertArgs} args - Arguments to update or create a Weather.
     * @example
     * // Update or create a Weather
     * const weather = await prisma.weather.upsert({
     *   create: {
     *     // ... data to create a Weather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weather we want to update
     *   }
     * })
    **/
    upsert<T extends weatherUpsertArgs>(
      args: SelectSubset<T, weatherUpsertArgs>
    ): CheckSelect<T, Prisma__weatherClient<weather>, Prisma__weatherClient<weatherGetPayload<T>>>

    /**
     * Count the number of Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weatherCountArgs} args - Arguments to filter Weathers to count.
     * @example
     * // Count the number of Weathers
     * const count = await prisma.weather.count({
     *   where: {
     *     // ... the filter for the Weathers we want to count
     *   }
     * })
    **/
    count<T extends weatherCountArgs>(
      args?: Subset<T, weatherCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateArgs>(args: Subset<T, WeatherAggregateArgs>): PrismaPromise<GetWeatherAggregateType<T>>

    /**
     * Group by Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherGroupByArgs['orderBy'] }
        : { orderBy?: WeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weatherClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weather findUnique
   */
  export type weatherFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
    /**
     * Throw an Error if a weather can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weather to fetch.
     * 
    **/
    where: weatherWhereUniqueInput
  }


  /**
   * weather findFirst
   */
  export type weatherFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
    /**
     * Throw an Error if a weather can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weather to fetch.
     * 
    **/
    where?: weatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weathers to fetch.
     * 
    **/
    orderBy?: Enumerable<weatherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weathers.
     * 
    **/
    cursor?: weatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weathers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weathers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weathers.
     * 
    **/
    distinct?: Enumerable<WeatherScalarFieldEnum>
  }


  /**
   * weather findMany
   */
  export type weatherFindManyArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
    /**
     * Filter, which weathers to fetch.
     * 
    **/
    where?: weatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weathers to fetch.
     * 
    **/
    orderBy?: Enumerable<weatherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weathers.
     * 
    **/
    cursor?: weatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weathers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weathers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WeatherScalarFieldEnum>
  }


  /**
   * weather create
   */
  export type weatherCreateArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
    /**
     * The data needed to create a weather.
     * 
    **/
    data: XOR<weatherCreateInput, weatherUncheckedCreateInput>
  }


  /**
   * weather createMany
   */
  export type weatherCreateManyArgs = {
    data: Enumerable<weatherCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weather update
   */
  export type weatherUpdateArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
    /**
     * The data needed to update a weather.
     * 
    **/
    data: XOR<weatherUpdateInput, weatherUncheckedUpdateInput>
    /**
     * Choose, which weather to update.
     * 
    **/
    where: weatherWhereUniqueInput
  }


  /**
   * weather updateMany
   */
  export type weatherUpdateManyArgs = {
    data: XOR<weatherUpdateManyMutationInput, weatherUncheckedUpdateManyInput>
    where?: weatherWhereInput
  }


  /**
   * weather upsert
   */
  export type weatherUpsertArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
    /**
     * The filter to search for the weather to update in case it exists.
     * 
    **/
    where: weatherWhereUniqueInput
    /**
     * In case the weather found by the `where` argument doesn't exist, create a new weather with this data.
     * 
    **/
    create: XOR<weatherCreateInput, weatherUncheckedCreateInput>
    /**
     * In case the weather was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weatherUpdateInput, weatherUncheckedUpdateInput>
  }


  /**
   * weather delete
   */
  export type weatherDeleteArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
    /**
     * Filter which weather to delete.
     * 
    **/
    where: weatherWhereUniqueInput
  }


  /**
   * weather deleteMany
   */
  export type weatherDeleteManyArgs = {
    where?: weatherWhereInput
  }


  /**
   * weather without action
   */
  export type weatherArgs = {
    /**
     * Select specific fields to fetch from the weather
     * 
    **/
    select?: weatherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weatherInclude | null
  }



  /**
   * Model worker
   */


  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
    max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerAvgAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerSumAggregateOutputType = {
    Id: number | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    CodeReportId: number | null
    Quantity: number | null
  }

  export type WorkerCountAggregateOutputType = {
    Id: number
    Name: number
    CodeReportId: number
    Quantity: number
    _all: number
  }


  export type WorkerAvgAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerSumAggregateInputType = {
    Id?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerMinAggregateInputType = {
    Id?: true
    Name?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerMaxAggregateInputType = {
    Id?: true
    Name?: true
    CodeReportId?: true
    Quantity?: true
  }

  export type WorkerCountAggregateInputType = {
    Id?: true
    Name?: true
    CodeReportId?: true
    Quantity?: true
    _all?: true
  }

  export type WorkerAggregateArgs = {
    /**
     * Filter which worker to aggregate.
     * 
    **/
    where?: workerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workers to fetch.
     * 
    **/
    orderBy?: Enumerable<workerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: workerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: WorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: WorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }


    
    
  export type WorkerGroupByArgs = {
    where?: workerWhereInput
    orderBy?: Enumerable<workerOrderByInput>
    by: Array<WorkerScalarFieldEnum>
    having?: workerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _avg?: WorkerAvgAggregateInputType
    _sum?: WorkerSumAggregateInputType
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }


  export type WorkerGroupByOutputType = {
    Id: number
    Name: string
    CodeReportId: number
    Quantity: number
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Promise<
    Array<
      PickArray<WorkerGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WorkerGroupByOutputType[P]> 
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      > 
    >


  export type workerSelect = {
    Id?: boolean
    Name?: boolean
    CodeReportId?: boolean
    Quantity?: boolean
    CodeReport?: boolean | codeReportArgs
  }

  export type workerInclude = {
    CodeReport?: boolean | codeReportArgs
  }

  export type workerGetPayload<
    S extends boolean | null | undefined | workerArgs,
    U = keyof S
      > = S extends true
        ? worker
    : S extends undefined
    ? never
    : S extends workerArgs | workerFindManyArgs
    ?'include' extends U
    ? worker  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof worker ?worker [P]
  : 
          P extends 'CodeReport'
        ? codeReportGetPayload<S['select'][P]> : never
  } 
    : worker
  : worker


  type workerCountArgs = Merge<
    Omit<workerFindManyArgs, 'select' | 'include'> & {
      select?: WorkerCountAggregateInputType | true
    }
  >

  export interface workerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Worker that matches the filter.
     * @param {workerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends workerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, workerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'worker'> extends True ? CheckSelect<T, Prisma__workerClient<worker>, Prisma__workerClient<workerGetPayload<T>>> : CheckSelect<T, Prisma__workerClient<worker | null >, Prisma__workerClient<workerGetPayload<T> | null >>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends workerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, workerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'worker'> extends True ? CheckSelect<T, Prisma__workerClient<worker>, Prisma__workerClient<workerGetPayload<T>>> : CheckSelect<T, Prisma__workerClient<worker | null >, Prisma__workerClient<workerGetPayload<T> | null >>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends workerFindManyArgs>(
      args?: SelectSubset<T, workerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<worker>>, PrismaPromise<Array<workerGetPayload<T>>>>

    /**
     * Create a Worker.
     * @param {workerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
    **/
    create<T extends workerCreateArgs>(
      args: SelectSubset<T, workerCreateArgs>
    ): CheckSelect<T, Prisma__workerClient<worker>, Prisma__workerClient<workerGetPayload<T>>>

    /**
     * Create many Workers.
     *     @param {workerCreateManyArgs} args - Arguments to create many Workers.
     *     @example
     *     // Create many Workers
     *     const worker = await prisma.worker.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends workerCreateManyArgs>(
      args?: SelectSubset<T, workerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Worker.
     * @param {workerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
    **/
    delete<T extends workerDeleteArgs>(
      args: SelectSubset<T, workerDeleteArgs>
    ): CheckSelect<T, Prisma__workerClient<worker>, Prisma__workerClient<workerGetPayload<T>>>

    /**
     * Update one Worker.
     * @param {workerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends workerUpdateArgs>(
      args: SelectSubset<T, workerUpdateArgs>
    ): CheckSelect<T, Prisma__workerClient<worker>, Prisma__workerClient<workerGetPayload<T>>>

    /**
     * Delete zero or more Workers.
     * @param {workerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends workerDeleteManyArgs>(
      args?: SelectSubset<T, workerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends workerUpdateManyArgs>(
      args: SelectSubset<T, workerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {workerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
    **/
    upsert<T extends workerUpsertArgs>(
      args: SelectSubset<T, workerUpsertArgs>
    ): CheckSelect<T, Prisma__workerClient<worker>, Prisma__workerClient<workerGetPayload<T>>>

    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends workerCountArgs>(
      args?: Subset<T, workerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__workerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CodeReport<T extends codeReportArgs = {}>(args?: Subset<T, codeReportArgs>): CheckSelect<T, Prisma__codeReportClient<codeReport | null >, Prisma__codeReportClient<codeReportGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * worker findUnique
   */
  export type workerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
    /**
     * Throw an Error if a worker can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which worker to fetch.
     * 
    **/
    where: workerWhereUniqueInput
  }


  /**
   * worker findFirst
   */
  export type workerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
    /**
     * Throw an Error if a worker can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which worker to fetch.
     * 
    **/
    where?: workerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workers to fetch.
     * 
    **/
    orderBy?: Enumerable<workerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workers.
     * 
    **/
    cursor?: workerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workers.
     * 
    **/
    distinct?: Enumerable<WorkerScalarFieldEnum>
  }


  /**
   * worker findMany
   */
  export type workerFindManyArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
    /**
     * Filter, which workers to fetch.
     * 
    **/
    where?: workerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workers to fetch.
     * 
    **/
    orderBy?: Enumerable<workerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing workers.
     * 
    **/
    cursor?: workerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkerScalarFieldEnum>
  }


  /**
   * worker create
   */
  export type workerCreateArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
    /**
     * The data needed to create a worker.
     * 
    **/
    data: XOR<workerCreateInput, workerUncheckedCreateInput>
  }


  /**
   * worker createMany
   */
  export type workerCreateManyArgs = {
    data: Enumerable<workerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * worker update
   */
  export type workerUpdateArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
    /**
     * The data needed to update a worker.
     * 
    **/
    data: XOR<workerUpdateInput, workerUncheckedUpdateInput>
    /**
     * Choose, which worker to update.
     * 
    **/
    where: workerWhereUniqueInput
  }


  /**
   * worker updateMany
   */
  export type workerUpdateManyArgs = {
    data: XOR<workerUpdateManyMutationInput, workerUncheckedUpdateManyInput>
    where?: workerWhereInput
  }


  /**
   * worker upsert
   */
  export type workerUpsertArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
    /**
     * The filter to search for the worker to update in case it exists.
     * 
    **/
    where: workerWhereUniqueInput
    /**
     * In case the worker found by the `where` argument doesn't exist, create a new worker with this data.
     * 
    **/
    create: XOR<workerCreateInput, workerUncheckedCreateInput>
    /**
     * In case the worker was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<workerUpdateInput, workerUncheckedUpdateInput>
  }


  /**
   * worker delete
   */
  export type workerDeleteArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
    /**
     * Filter which worker to delete.
     * 
    **/
    where: workerWhereUniqueInput
  }


  /**
   * worker deleteMany
   */
  export type workerDeleteManyArgs = {
    where?: workerWhereInput
  }


  /**
   * worker without action
   */
  export type workerArgs = {
    /**
     * Select specific fields to fetch from the worker
     * 
    **/
    select?: workerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerInclude | null
  }



  /**
   * Model userContact
   */


  export type AggregateUserContact = {
    _count: UserContactCountAggregateOutputType | null
    count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
    max: UserContactMaxAggregateOutputType | null
  }

  export type UserContactAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type UserContactSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type UserContactMinAggregateOutputType = {
    Id: number | null
    PhoneNumber: string | null
    UserId: number | null
    WhatsappAvailable: boolean | null
  }

  export type UserContactMaxAggregateOutputType = {
    Id: number | null
    PhoneNumber: string | null
    UserId: number | null
    WhatsappAvailable: boolean | null
  }

  export type UserContactCountAggregateOutputType = {
    Id: number
    PhoneNumber: number
    UserId: number
    WhatsappAvailable: number
    _all: number
  }


  export type UserContactAvgAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type UserContactSumAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type UserContactMinAggregateInputType = {
    Id?: true
    PhoneNumber?: true
    UserId?: true
    WhatsappAvailable?: true
  }

  export type UserContactMaxAggregateInputType = {
    Id?: true
    PhoneNumber?: true
    UserId?: true
    WhatsappAvailable?: true
  }

  export type UserContactCountAggregateInputType = {
    Id?: true
    PhoneNumber?: true
    UserId?: true
    WhatsappAvailable?: true
    _all?: true
  }

  export type UserContactAggregateArgs = {
    /**
     * Filter which userContact to aggregate.
     * 
    **/
    where?: userContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<userContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: userContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userContacts
    **/
    _count?: true | UserContactCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserContactAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserContactSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserContactMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserContactMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserContactMaxAggregateInputType
  }

  export type GetUserContactAggregateType<T extends UserContactAggregateArgs> = {
        [P in keyof T & keyof AggregateUserContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserContact[P]>
      : GetScalarType<T[P], AggregateUserContact[P]>
  }


    
    
  export type UserContactGroupByArgs = {
    where?: userContactWhereInput
    orderBy?: Enumerable<userContactOrderByInput>
    by: Array<UserContactScalarFieldEnum>
    having?: userContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserContactCountAggregateInputType | true
    _avg?: UserContactAvgAggregateInputType
    _sum?: UserContactSumAggregateInputType
    _min?: UserContactMinAggregateInputType
    _max?: UserContactMaxAggregateInputType
  }


  export type UserContactGroupByOutputType = {
    Id: number
    PhoneNumber: string
    UserId: number
    WhatsappAvailable: boolean
    _count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  type GetUserContactGroupByPayload<T extends UserContactGroupByArgs> = Promise<
    Array<
      PickArray<UserContactGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserContactGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserContactGroupByOutputType[P]> 
            : GetScalarType<T[P], UserContactGroupByOutputType[P]>
        }
      > 
    >


  export type userContactSelect = {
    Id?: boolean
    PhoneNumber?: boolean
    UserId?: boolean
    WhatsappAvailable?: boolean
    User?: boolean | userArgs
  }

  export type userContactInclude = {
    User?: boolean | userArgs
  }

  export type userContactGetPayload<
    S extends boolean | null | undefined | userContactArgs,
    U = keyof S
      > = S extends true
        ? userContact
    : S extends undefined
    ? never
    : S extends userContactArgs | userContactFindManyArgs
    ?'include' extends U
    ? userContact  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof userContact ?userContact [P]
  : 
          P extends 'User'
        ? userGetPayload<S['select'][P]> : never
  } 
    : userContact
  : userContact


  type userContactCountArgs = Merge<
    Omit<userContactFindManyArgs, 'select' | 'include'> & {
      select?: UserContactCountAggregateInputType | true
    }
  >

  export interface userContactDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserContact that matches the filter.
     * @param {userContactFindUniqueArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userContactFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userContactFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'userContact'> extends True ? CheckSelect<T, Prisma__userContactClient<userContact>, Prisma__userContactClient<userContactGetPayload<T>>> : CheckSelect<T, Prisma__userContactClient<userContact | null >, Prisma__userContactClient<userContactGetPayload<T> | null >>

    /**
     * Find the first UserContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContactFindFirstArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userContactFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userContactFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'userContact'> extends True ? CheckSelect<T, Prisma__userContactClient<userContact>, Prisma__userContactClient<userContactGetPayload<T>>> : CheckSelect<T, Prisma__userContactClient<userContact | null >, Prisma__userContactClient<userContactGetPayload<T> | null >>

    /**
     * Find zero or more UserContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserContacts
     * const userContacts = await prisma.userContact.findMany()
     * 
     * // Get first 10 UserContacts
     * const userContacts = await prisma.userContact.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userContactWithIdOnly = await prisma.userContact.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends userContactFindManyArgs>(
      args?: SelectSubset<T, userContactFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<userContact>>, PrismaPromise<Array<userContactGetPayload<T>>>>

    /**
     * Create a UserContact.
     * @param {userContactCreateArgs} args - Arguments to create a UserContact.
     * @example
     * // Create one UserContact
     * const UserContact = await prisma.userContact.create({
     *   data: {
     *     // ... data to create a UserContact
     *   }
     * })
     * 
    **/
    create<T extends userContactCreateArgs>(
      args: SelectSubset<T, userContactCreateArgs>
    ): CheckSelect<T, Prisma__userContactClient<userContact>, Prisma__userContactClient<userContactGetPayload<T>>>

    /**
     * Create many UserContacts.
     *     @param {userContactCreateManyArgs} args - Arguments to create many UserContacts.
     *     @example
     *     // Create many UserContacts
     *     const userContact = await prisma.userContact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userContactCreateManyArgs>(
      args?: SelectSubset<T, userContactCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserContact.
     * @param {userContactDeleteArgs} args - Arguments to delete one UserContact.
     * @example
     * // Delete one UserContact
     * const UserContact = await prisma.userContact.delete({
     *   where: {
     *     // ... filter to delete one UserContact
     *   }
     * })
     * 
    **/
    delete<T extends userContactDeleteArgs>(
      args: SelectSubset<T, userContactDeleteArgs>
    ): CheckSelect<T, Prisma__userContactClient<userContact>, Prisma__userContactClient<userContactGetPayload<T>>>

    /**
     * Update one UserContact.
     * @param {userContactUpdateArgs} args - Arguments to update one UserContact.
     * @example
     * // Update one UserContact
     * const userContact = await prisma.userContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userContactUpdateArgs>(
      args: SelectSubset<T, userContactUpdateArgs>
    ): CheckSelect<T, Prisma__userContactClient<userContact>, Prisma__userContactClient<userContactGetPayload<T>>>

    /**
     * Delete zero or more UserContacts.
     * @param {userContactDeleteManyArgs} args - Arguments to filter UserContacts to delete.
     * @example
     * // Delete a few UserContacts
     * const { count } = await prisma.userContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userContactDeleteManyArgs>(
      args?: SelectSubset<T, userContactDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserContacts
     * const userContact = await prisma.userContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userContactUpdateManyArgs>(
      args: SelectSubset<T, userContactUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserContact.
     * @param {userContactUpsertArgs} args - Arguments to update or create a UserContact.
     * @example
     * // Update or create a UserContact
     * const userContact = await prisma.userContact.upsert({
     *   create: {
     *     // ... data to create a UserContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserContact we want to update
     *   }
     * })
    **/
    upsert<T extends userContactUpsertArgs>(
      args: SelectSubset<T, userContactUpsertArgs>
    ): CheckSelect<T, Prisma__userContactClient<userContact>, Prisma__userContactClient<userContactGetPayload<T>>>

    /**
     * Count the number of UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContactCountArgs} args - Arguments to filter UserContacts to count.
     * @example
     * // Count the number of UserContacts
     * const count = await prisma.userContact.count({
     *   where: {
     *     // ... the filter for the UserContacts we want to count
     *   }
     * })
    **/
    count<T extends userContactCountArgs>(
      args?: Subset<T, userContactCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserContactAggregateArgs>(args: Subset<T, UserContactAggregateArgs>): PrismaPromise<GetUserContactAggregateType<T>>

    /**
     * Group by UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserContactGroupByArgs['orderBy'] }
        : { orderBy?: UserContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserContactGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for userContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userContactClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * userContact findUnique
   */
  export type userContactFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
    /**
     * Throw an Error if a userContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which userContact to fetch.
     * 
    **/
    where: userContactWhereUniqueInput
  }


  /**
   * userContact findFirst
   */
  export type userContactFindFirstArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
    /**
     * Throw an Error if a userContact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which userContact to fetch.
     * 
    **/
    where?: userContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<userContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userContacts.
     * 
    **/
    cursor?: userContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userContacts.
     * 
    **/
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }


  /**
   * userContact findMany
   */
  export type userContactFindManyArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
    /**
     * Filter, which userContacts to fetch.
     * 
    **/
    where?: userContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<userContactOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userContacts.
     * 
    **/
    cursor?: userContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userContacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }


  /**
   * userContact create
   */
  export type userContactCreateArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
    /**
     * The data needed to create a userContact.
     * 
    **/
    data: XOR<userContactCreateInput, userContactUncheckedCreateInput>
  }


  /**
   * userContact createMany
   */
  export type userContactCreateManyArgs = {
    data: Enumerable<userContactCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * userContact update
   */
  export type userContactUpdateArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
    /**
     * The data needed to update a userContact.
     * 
    **/
    data: XOR<userContactUpdateInput, userContactUncheckedUpdateInput>
    /**
     * Choose, which userContact to update.
     * 
    **/
    where: userContactWhereUniqueInput
  }


  /**
   * userContact updateMany
   */
  export type userContactUpdateManyArgs = {
    data: XOR<userContactUpdateManyMutationInput, userContactUncheckedUpdateManyInput>
    where?: userContactWhereInput
  }


  /**
   * userContact upsert
   */
  export type userContactUpsertArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
    /**
     * The filter to search for the userContact to update in case it exists.
     * 
    **/
    where: userContactWhereUniqueInput
    /**
     * In case the userContact found by the `where` argument doesn't exist, create a new userContact with this data.
     * 
    **/
    create: XOR<userContactCreateInput, userContactUncheckedCreateInput>
    /**
     * In case the userContact was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<userContactUpdateInput, userContactUncheckedUpdateInput>
  }


  /**
   * userContact delete
   */
  export type userContactDeleteArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
    /**
     * Filter which userContact to delete.
     * 
    **/
    where: userContactWhereUniqueInput
  }


  /**
   * userContact deleteMany
   */
  export type userContactDeleteManyArgs = {
    where?: userContactWhereInput
  }


  /**
   * userContact without action
   */
  export type userContactArgs = {
    /**
     * Select specific fields to fetch from the userContact
     * 
    **/
    select?: userContactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userContactInclude | null
  }



  /**
   * Model userPosition
   */


  export type AggregateUserPosition = {
    _count: UserPositionCountAggregateOutputType | null
    count: UserPositionCountAggregateOutputType | null
    _avg: UserPositionAvgAggregateOutputType | null
    avg: UserPositionAvgAggregateOutputType | null
    _sum: UserPositionSumAggregateOutputType | null
    sum: UserPositionSumAggregateOutputType | null
    _min: UserPositionMinAggregateOutputType | null
    min: UserPositionMinAggregateOutputType | null
    _max: UserPositionMaxAggregateOutputType | null
    max: UserPositionMaxAggregateOutputType | null
  }

  export type UserPositionAvgAggregateOutputType = {
    Id: number | null
    Position: number | null
    CreatedBy: number | null
    UserId: number | null
  }

  export type UserPositionSumAggregateOutputType = {
    Id: number | null
    Position: number | null
    CreatedBy: number | null
    UserId: number | null
  }

  export type UserPositionMinAggregateOutputType = {
    Id: number | null
    Position: number | null
    EffectiveDate: Date | null
    CreatedBy: number | null
    CreatedDate: Date | null
    UserId: number | null
  }

  export type UserPositionMaxAggregateOutputType = {
    Id: number | null
    Position: number | null
    EffectiveDate: Date | null
    CreatedBy: number | null
    CreatedDate: Date | null
    UserId: number | null
  }

  export type UserPositionCountAggregateOutputType = {
    Id: number
    Position: number
    EffectiveDate: number
    CreatedBy: number
    CreatedDate: number
    UserId: number
    _all: number
  }


  export type UserPositionAvgAggregateInputType = {
    Id?: true
    Position?: true
    CreatedBy?: true
    UserId?: true
  }

  export type UserPositionSumAggregateInputType = {
    Id?: true
    Position?: true
    CreatedBy?: true
    UserId?: true
  }

  export type UserPositionMinAggregateInputType = {
    Id?: true
    Position?: true
    EffectiveDate?: true
    CreatedBy?: true
    CreatedDate?: true
    UserId?: true
  }

  export type UserPositionMaxAggregateInputType = {
    Id?: true
    Position?: true
    EffectiveDate?: true
    CreatedBy?: true
    CreatedDate?: true
    UserId?: true
  }

  export type UserPositionCountAggregateInputType = {
    Id?: true
    Position?: true
    EffectiveDate?: true
    CreatedBy?: true
    CreatedDate?: true
    UserId?: true
    _all?: true
  }

  export type UserPositionAggregateArgs = {
    /**
     * Filter which userPosition to aggregate.
     * 
    **/
    where?: userPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<userPositionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: userPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPositions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userPositions
    **/
    _count?: true | UserPositionCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPositionAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPositionSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPositionMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPositionMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserPositionMaxAggregateInputType
  }

  export type GetUserPositionAggregateType<T extends UserPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPosition[P]>
      : GetScalarType<T[P], AggregateUserPosition[P]>
  }


    
    
  export type UserPositionGroupByArgs = {
    where?: userPositionWhereInput
    orderBy?: Enumerable<userPositionOrderByInput>
    by: Array<UserPositionScalarFieldEnum>
    having?: userPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPositionCountAggregateInputType | true
    _avg?: UserPositionAvgAggregateInputType
    _sum?: UserPositionSumAggregateInputType
    _min?: UserPositionMinAggregateInputType
    _max?: UserPositionMaxAggregateInputType
  }


  export type UserPositionGroupByOutputType = {
    Id: number
    Position: number
    EffectiveDate: Date
    CreatedBy: number
    CreatedDate: Date
    UserId: number
    _count: UserPositionCountAggregateOutputType | null
    _avg: UserPositionAvgAggregateOutputType | null
    _sum: UserPositionSumAggregateOutputType | null
    _min: UserPositionMinAggregateOutputType | null
    _max: UserPositionMaxAggregateOutputType | null
  }

  type GetUserPositionGroupByPayload<T extends UserPositionGroupByArgs> = Promise<
    Array<
      PickArray<UserPositionGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserPositionGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserPositionGroupByOutputType[P]> 
            : GetScalarType<T[P], UserPositionGroupByOutputType[P]>
        }
      > 
    >


  export type userPositionSelect = {
    Id?: boolean
    Position?: boolean
    EffectiveDate?: boolean
    CreatedBy?: boolean
    CreatedDate?: boolean
    UserId?: boolean
    User4?: boolean | userArgs
    User5?: boolean | userArgs
  }

  export type userPositionInclude = {
    User4?: boolean | userArgs
    User5?: boolean | userArgs
  }

  export type userPositionGetPayload<
    S extends boolean | null | undefined | userPositionArgs,
    U = keyof S
      > = S extends true
        ? userPosition
    : S extends undefined
    ? never
    : S extends userPositionArgs | userPositionFindManyArgs
    ?'include' extends U
    ? userPosition  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User4'
        ? userGetPayload<S['include'][P]> :
        P extends 'User5'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof userPosition ?userPosition [P]
  : 
          P extends 'User4'
        ? userGetPayload<S['select'][P]> :
        P extends 'User5'
        ? userGetPayload<S['select'][P]> : never
  } 
    : userPosition
  : userPosition


  type userPositionCountArgs = Merge<
    Omit<userPositionFindManyArgs, 'select' | 'include'> & {
      select?: UserPositionCountAggregateInputType | true
    }
  >

  export interface userPositionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserPosition that matches the filter.
     * @param {userPositionFindUniqueArgs} args - Arguments to find a UserPosition
     * @example
     * // Get one UserPosition
     * const userPosition = await prisma.userPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userPositionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userPositionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'userPosition'> extends True ? CheckSelect<T, Prisma__userPositionClient<userPosition>, Prisma__userPositionClient<userPositionGetPayload<T>>> : CheckSelect<T, Prisma__userPositionClient<userPosition | null >, Prisma__userPositionClient<userPositionGetPayload<T> | null >>

    /**
     * Find the first UserPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPositionFindFirstArgs} args - Arguments to find a UserPosition
     * @example
     * // Get one UserPosition
     * const userPosition = await prisma.userPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userPositionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userPositionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'userPosition'> extends True ? CheckSelect<T, Prisma__userPositionClient<userPosition>, Prisma__userPositionClient<userPositionGetPayload<T>>> : CheckSelect<T, Prisma__userPositionClient<userPosition | null >, Prisma__userPositionClient<userPositionGetPayload<T> | null >>

    /**
     * Find zero or more UserPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPositionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPositions
     * const userPositions = await prisma.userPosition.findMany()
     * 
     * // Get first 10 UserPositions
     * const userPositions = await prisma.userPosition.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userPositionWithIdOnly = await prisma.userPosition.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends userPositionFindManyArgs>(
      args?: SelectSubset<T, userPositionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<userPosition>>, PrismaPromise<Array<userPositionGetPayload<T>>>>

    /**
     * Create a UserPosition.
     * @param {userPositionCreateArgs} args - Arguments to create a UserPosition.
     * @example
     * // Create one UserPosition
     * const UserPosition = await prisma.userPosition.create({
     *   data: {
     *     // ... data to create a UserPosition
     *   }
     * })
     * 
    **/
    create<T extends userPositionCreateArgs>(
      args: SelectSubset<T, userPositionCreateArgs>
    ): CheckSelect<T, Prisma__userPositionClient<userPosition>, Prisma__userPositionClient<userPositionGetPayload<T>>>

    /**
     * Create many UserPositions.
     *     @param {userPositionCreateManyArgs} args - Arguments to create many UserPositions.
     *     @example
     *     // Create many UserPositions
     *     const userPosition = await prisma.userPosition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userPositionCreateManyArgs>(
      args?: SelectSubset<T, userPositionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserPosition.
     * @param {userPositionDeleteArgs} args - Arguments to delete one UserPosition.
     * @example
     * // Delete one UserPosition
     * const UserPosition = await prisma.userPosition.delete({
     *   where: {
     *     // ... filter to delete one UserPosition
     *   }
     * })
     * 
    **/
    delete<T extends userPositionDeleteArgs>(
      args: SelectSubset<T, userPositionDeleteArgs>
    ): CheckSelect<T, Prisma__userPositionClient<userPosition>, Prisma__userPositionClient<userPositionGetPayload<T>>>

    /**
     * Update one UserPosition.
     * @param {userPositionUpdateArgs} args - Arguments to update one UserPosition.
     * @example
     * // Update one UserPosition
     * const userPosition = await prisma.userPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userPositionUpdateArgs>(
      args: SelectSubset<T, userPositionUpdateArgs>
    ): CheckSelect<T, Prisma__userPositionClient<userPosition>, Prisma__userPositionClient<userPositionGetPayload<T>>>

    /**
     * Delete zero or more UserPositions.
     * @param {userPositionDeleteManyArgs} args - Arguments to filter UserPositions to delete.
     * @example
     * // Delete a few UserPositions
     * const { count } = await prisma.userPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userPositionDeleteManyArgs>(
      args?: SelectSubset<T, userPositionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPositions
     * const userPosition = await prisma.userPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userPositionUpdateManyArgs>(
      args: SelectSubset<T, userPositionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPosition.
     * @param {userPositionUpsertArgs} args - Arguments to update or create a UserPosition.
     * @example
     * // Update or create a UserPosition
     * const userPosition = await prisma.userPosition.upsert({
     *   create: {
     *     // ... data to create a UserPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPosition we want to update
     *   }
     * })
    **/
    upsert<T extends userPositionUpsertArgs>(
      args: SelectSubset<T, userPositionUpsertArgs>
    ): CheckSelect<T, Prisma__userPositionClient<userPosition>, Prisma__userPositionClient<userPositionGetPayload<T>>>

    /**
     * Count the number of UserPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPositionCountArgs} args - Arguments to filter UserPositions to count.
     * @example
     * // Count the number of UserPositions
     * const count = await prisma.userPosition.count({
     *   where: {
     *     // ... the filter for the UserPositions we want to count
     *   }
     * })
    **/
    count<T extends userPositionCountArgs>(
      args?: Subset<T, userPositionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPositionAggregateArgs>(args: Subset<T, UserPositionAggregateArgs>): PrismaPromise<GetUserPositionAggregateType<T>>

    /**
     * Group by UserPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPositionGroupByArgs['orderBy'] }
        : { orderBy?: UserPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPositionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for userPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userPositionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User4<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    User5<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * userPosition findUnique
   */
  export type userPositionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
    /**
     * Throw an Error if a userPosition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which userPosition to fetch.
     * 
    **/
    where: userPositionWhereUniqueInput
  }


  /**
   * userPosition findFirst
   */
  export type userPositionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
    /**
     * Throw an Error if a userPosition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which userPosition to fetch.
     * 
    **/
    where?: userPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<userPositionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userPositions.
     * 
    **/
    cursor?: userPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPositions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userPositions.
     * 
    **/
    distinct?: Enumerable<UserPositionScalarFieldEnum>
  }


  /**
   * userPosition findMany
   */
  export type userPositionFindManyArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
    /**
     * Filter, which userPositions to fetch.
     * 
    **/
    where?: userPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPositions to fetch.
     * 
    **/
    orderBy?: Enumerable<userPositionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userPositions.
     * 
    **/
    cursor?: userPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPositions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPositions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserPositionScalarFieldEnum>
  }


  /**
   * userPosition create
   */
  export type userPositionCreateArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
    /**
     * The data needed to create a userPosition.
     * 
    **/
    data: XOR<userPositionCreateInput, userPositionUncheckedCreateInput>
  }


  /**
   * userPosition createMany
   */
  export type userPositionCreateManyArgs = {
    data: Enumerable<userPositionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * userPosition update
   */
  export type userPositionUpdateArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
    /**
     * The data needed to update a userPosition.
     * 
    **/
    data: XOR<userPositionUpdateInput, userPositionUncheckedUpdateInput>
    /**
     * Choose, which userPosition to update.
     * 
    **/
    where: userPositionWhereUniqueInput
  }


  /**
   * userPosition updateMany
   */
  export type userPositionUpdateManyArgs = {
    data: XOR<userPositionUpdateManyMutationInput, userPositionUncheckedUpdateManyInput>
    where?: userPositionWhereInput
  }


  /**
   * userPosition upsert
   */
  export type userPositionUpsertArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
    /**
     * The filter to search for the userPosition to update in case it exists.
     * 
    **/
    where: userPositionWhereUniqueInput
    /**
     * In case the userPosition found by the `where` argument doesn't exist, create a new userPosition with this data.
     * 
    **/
    create: XOR<userPositionCreateInput, userPositionUncheckedCreateInput>
    /**
     * In case the userPosition was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<userPositionUpdateInput, userPositionUncheckedUpdateInput>
  }


  /**
   * userPosition delete
   */
  export type userPositionDeleteArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
    /**
     * Filter which userPosition to delete.
     * 
    **/
    where: userPositionWhereUniqueInput
  }


  /**
   * userPosition deleteMany
   */
  export type userPositionDeleteManyArgs = {
    where?: userPositionWhereInput
  }


  /**
   * userPosition without action
   */
  export type userPositionArgs = {
    /**
     * Select specific fields to fetch from the userPosition
     * 
    **/
    select?: userPositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userPositionInclude | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    Id: number | null
  }

  export type UserSumAggregateOutputType = {
    Id: number | null
  }

  export type UserMinAggregateOutputType = {
    Id: number | null
    Email: string | null
    FirstName: string | null
    LastName: string | null
    IsActive: boolean | null
    Password: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    Id: number | null
    Email: string | null
    FirstName: string | null
    LastName: string | null
    IsActive: boolean | null
    Password: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    Id: number
    Email: number
    FirstName: number
    LastName: number
    IsActive: number
    Password: number
    ImageUrl: number
    ThumbnailUrl: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    Id?: true
  }

  export type UserSumAggregateInputType = {
    Id?: true
  }

  export type UserMinAggregateInputType = {
    Id?: true
    Email?: true
    FirstName?: true
    LastName?: true
    IsActive?: true
    Password?: true
    ImageUrl?: true
    ThumbnailUrl?: true
  }

  export type UserMaxAggregateInputType = {
    Id?: true
    Email?: true
    FirstName?: true
    LastName?: true
    IsActive?: true
    Password?: true
    ImageUrl?: true
    ThumbnailUrl?: true
  }

  export type UserCountAggregateInputType = {
    Id?: true
    Email?: true
    FirstName?: true
    LastName?: true
    IsActive?: true
    Password?: true
    ImageUrl?: true
    ThumbnailUrl?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which user to aggregate.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    Id: number
    Email: string
    FirstName: string
    LastName: string
    IsActive: boolean
    Password: string | null
    ImageUrl: string | null
    ThumbnailUrl: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type userSelect = {
    Id?: boolean
    Email?: boolean
    FirstName?: boolean
    LastName?: boolean
    IsActive?: boolean
    Password?: boolean
    ImageUrl?: boolean
    ThumbnailUrl?: boolean
    Client?: boolean | clientFindManyArgs
    ClientContact?: boolean | clientContactFindManyArgs
    CodeProjectDocument?: boolean | codeProjectDocumentFindManyArgs
    CreateCodeProject?: boolean | codeProjectFindManyArgs
    ConfirmedCodeProject?: boolean | codeProjectFindManyArgs
    CompletedCodeProject?: boolean | codeProjectFindManyArgs
    CodeProjectUser?: boolean | codeProjectUserFindManyArgs
    CodeReport?: boolean | codeReportFindManyArgs
    CodeReportApproval?: boolean | codeReportApprovalFindManyArgs
    ProjectTask?: boolean | projectTaskFindManyArgs
    RequestForInformationAnswer?: boolean | requestForInformationAnswerFindManyArgs
    CreateUserPosition?: boolean | userPositionFindManyArgs
    UserPosition?: boolean | userPositionFindManyArgs
    UserContact?: boolean | userContactFindManyArgs
    Token?: boolean | userTokenFindManyArgs
  }

  export type userInclude = {
    Client?: boolean | clientFindManyArgs
    ClientContact?: boolean | clientContactFindManyArgs
    CodeProjectDocument?: boolean | codeProjectDocumentFindManyArgs
    CreateCodeProject?: boolean | codeProjectFindManyArgs
    ConfirmedCodeProject?: boolean | codeProjectFindManyArgs
    CompletedCodeProject?: boolean | codeProjectFindManyArgs
    CodeProjectUser?: boolean | codeProjectUserFindManyArgs
    CodeReport?: boolean | codeReportFindManyArgs
    CodeReportApproval?: boolean | codeReportApprovalFindManyArgs
    ProjectTask?: boolean | projectTaskFindManyArgs
    RequestForInformationAnswer?: boolean | requestForInformationAnswerFindManyArgs
    CreateUserPosition?: boolean | userPositionFindManyArgs
    UserPosition?: boolean | userPositionFindManyArgs
    UserContact?: boolean | userContactFindManyArgs
    Token?: boolean | userTokenFindManyArgs
  }

  export type userGetPayload<
    S extends boolean | null | undefined | userArgs,
    U = keyof S
      > = S extends true
        ? user
    : S extends undefined
    ? never
    : S extends userArgs | userFindManyArgs
    ?'include' extends U
    ? user  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Client'
        ? Array < clientGetPayload<S['include'][P]>>  :
        P extends 'ClientContact'
        ? Array < clientContactGetPayload<S['include'][P]>>  :
        P extends 'CodeProjectDocument'
        ? Array < codeProjectDocumentGetPayload<S['include'][P]>>  :
        P extends 'CreateCodeProject'
        ? Array < codeProjectGetPayload<S['include'][P]>>  :
        P extends 'ConfirmedCodeProject'
        ? Array < codeProjectGetPayload<S['include'][P]>>  :
        P extends 'CompletedCodeProject'
        ? Array < codeProjectGetPayload<S['include'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < codeProjectUserGetPayload<S['include'][P]>>  :
        P extends 'CodeReport'
        ? Array < codeReportGetPayload<S['include'][P]>>  :
        P extends 'CodeReportApproval'
        ? Array < codeReportApprovalGetPayload<S['include'][P]>>  :
        P extends 'ProjectTask'
        ? Array < projectTaskGetPayload<S['include'][P]>>  :
        P extends 'RequestForInformationAnswer'
        ? Array < requestForInformationAnswerGetPayload<S['include'][P]>>  :
        P extends 'CreateUserPosition'
        ? Array < userPositionGetPayload<S['include'][P]>>  :
        P extends 'UserPosition'
        ? Array < userPositionGetPayload<S['include'][P]>>  :
        P extends 'UserContact'
        ? Array < userContactGetPayload<S['include'][P]>>  :
        P extends 'Token'
        ? Array < userTokenGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user ?user [P]
  : 
          P extends 'Client'
        ? Array < clientGetPayload<S['select'][P]>>  :
        P extends 'ClientContact'
        ? Array < clientContactGetPayload<S['select'][P]>>  :
        P extends 'CodeProjectDocument'
        ? Array < codeProjectDocumentGetPayload<S['select'][P]>>  :
        P extends 'CreateCodeProject'
        ? Array < codeProjectGetPayload<S['select'][P]>>  :
        P extends 'ConfirmedCodeProject'
        ? Array < codeProjectGetPayload<S['select'][P]>>  :
        P extends 'CompletedCodeProject'
        ? Array < codeProjectGetPayload<S['select'][P]>>  :
        P extends 'CodeProjectUser'
        ? Array < codeProjectUserGetPayload<S['select'][P]>>  :
        P extends 'CodeReport'
        ? Array < codeReportGetPayload<S['select'][P]>>  :
        P extends 'CodeReportApproval'
        ? Array < codeReportApprovalGetPayload<S['select'][P]>>  :
        P extends 'ProjectTask'
        ? Array < projectTaskGetPayload<S['select'][P]>>  :
        P extends 'RequestForInformationAnswer'
        ? Array < requestForInformationAnswerGetPayload<S['select'][P]>>  :
        P extends 'CreateUserPosition'
        ? Array < userPositionGetPayload<S['select'][P]>>  :
        P extends 'UserPosition'
        ? Array < userPositionGetPayload<S['select'][P]>>  :
        P extends 'UserContact'
        ? Array < userContactGetPayload<S['select'][P]>>  :
        P extends 'Token'
        ? Array < userTokenGetPayload<S['select'][P]>>  : never
  } 
    : user
  : user


  type userCountArgs = Merge<
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface userDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs>(
      args?: SelectSubset<T, userFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user>>, PrismaPromise<Array<userGetPayload<T>>>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: SelectSubset<T, userCreateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs>(
      args?: SelectSubset<T, userCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: SelectSubset<T, userDeleteArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: SelectSubset<T, userUpdateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: SelectSubset<T, userDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: SelectSubset<T, userUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: SelectSubset<T, userUpsertArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Client<T extends clientFindManyArgs = {}>(args?: Subset<T, clientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<client>>, PrismaPromise<Array<clientGetPayload<T>>>>;

    ClientContact<T extends clientContactFindManyArgs = {}>(args?: Subset<T, clientContactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientContact>>, PrismaPromise<Array<clientContactGetPayload<T>>>>;

    CodeProjectDocument<T extends codeProjectDocumentFindManyArgs = {}>(args?: Subset<T, codeProjectDocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProjectDocument>>, PrismaPromise<Array<codeProjectDocumentGetPayload<T>>>>;

    CreateCodeProject<T extends codeProjectFindManyArgs = {}>(args?: Subset<T, codeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProject>>, PrismaPromise<Array<codeProjectGetPayload<T>>>>;

    ConfirmedCodeProject<T extends codeProjectFindManyArgs = {}>(args?: Subset<T, codeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProject>>, PrismaPromise<Array<codeProjectGetPayload<T>>>>;

    CompletedCodeProject<T extends codeProjectFindManyArgs = {}>(args?: Subset<T, codeProjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProject>>, PrismaPromise<Array<codeProjectGetPayload<T>>>>;

    CodeProjectUser<T extends codeProjectUserFindManyArgs = {}>(args?: Subset<T, codeProjectUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeProjectUser>>, PrismaPromise<Array<codeProjectUserGetPayload<T>>>>;

    CodeReport<T extends codeReportFindManyArgs = {}>(args?: Subset<T, codeReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeReport>>, PrismaPromise<Array<codeReportGetPayload<T>>>>;

    CodeReportApproval<T extends codeReportApprovalFindManyArgs = {}>(args?: Subset<T, codeReportApprovalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<codeReportApproval>>, PrismaPromise<Array<codeReportApprovalGetPayload<T>>>>;

    ProjectTask<T extends projectTaskFindManyArgs = {}>(args?: Subset<T, projectTaskFindManyArgs>): CheckSelect<T, PrismaPromise<Array<projectTask>>, PrismaPromise<Array<projectTaskGetPayload<T>>>>;

    RequestForInformationAnswer<T extends requestForInformationAnswerFindManyArgs = {}>(args?: Subset<T, requestForInformationAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<requestForInformationAnswer>>, PrismaPromise<Array<requestForInformationAnswerGetPayload<T>>>>;

    CreateUserPosition<T extends userPositionFindManyArgs = {}>(args?: Subset<T, userPositionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<userPosition>>, PrismaPromise<Array<userPositionGetPayload<T>>>>;

    UserPosition<T extends userPositionFindManyArgs = {}>(args?: Subset<T, userPositionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<userPosition>>, PrismaPromise<Array<userPositionGetPayload<T>>>>;

    UserContact<T extends userContactFindManyArgs = {}>(args?: Subset<T, userContactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<userContact>>, PrismaPromise<Array<userContactGetPayload<T>>>>;

    Token<T extends userTokenFindManyArgs = {}>(args?: Subset<T, userTokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<userToken>>, PrismaPromise<Array<userTokenGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Throw an Error if a user can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user to fetch.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Throw an Error if a user can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user to fetch.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * The data needed to create a user.
     * 
    **/
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs = {
    data: Enumerable<userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * The data needed to update a user.
     * 
    **/
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * The filter to search for the user to update in case it exists.
     * 
    **/
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     * 
    **/
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
    /**
     * Filter which user to delete.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    where?: userWhereInput
  }


  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: userInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ClientScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Address: 'Address',
    City: 'City',
    PhoneNumber: 'PhoneNumber',
    TaxIdentificationNumber: 'TaxIdentificationNumber',
    IsDelete: 'IsDelete',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const UserTokenScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    Token: 'Token'
  };

  export type UserTokenScalarFieldEnum = (typeof UserTokenScalarFieldEnum)[keyof typeof UserTokenScalarFieldEnum]


  export const ClientContactScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Position: 'Position',
    PhoneNumber: 'PhoneNumber',
    Email: 'Email',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    ClientId: 'ClientId'
  };

  export type ClientContactScalarFieldEnum = (typeof ClientContactScalarFieldEnum)[keyof typeof ClientContactScalarFieldEnum]


  export const CodeProjectScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    ClientId: 'ClientId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    ConfirmedDate: 'ConfirmedDate',
    ConfirmedBy: 'ConfirmedBy',
    Address: 'Address',
    DocumentName: 'DocumentName',
    IsCompleted: 'IsCompleted',
    CompletedDate: 'CompletedDate',
    CompletedBy: 'CompletedBy',
    IsDelete: 'IsDelete'
  };

  export type CodeProjectScalarFieldEnum = (typeof CodeProjectScalarFieldEnum)[keyof typeof CodeProjectScalarFieldEnum]


  export const CodeProjectDocumentScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Url: 'Url',
    CodeProjectId: 'CodeProjectId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate'
  };

  export type CodeProjectDocumentScalarFieldEnum = (typeof CodeProjectDocumentScalarFieldEnum)[keyof typeof CodeProjectDocumentScalarFieldEnum]


  export const CodeProjectUserScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    CodeProjectId: 'CodeProjectId'
  };

  export type CodeProjectUserScalarFieldEnum = (typeof CodeProjectUserScalarFieldEnum)[keyof typeof CodeProjectUserScalarFieldEnum]


  export const CodeReportScalarFieldEnum: {
    Id: 'Id',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    Date: 'Date',
    CodeProjectId: 'CodeProjectId',
    Type: 'Type',
    IsDelete: 'IsDelete',
    Note: 'Note'
  };

  export type CodeReportScalarFieldEnum = (typeof CodeReportScalarFieldEnum)[keyof typeof CodeReportScalarFieldEnum]


  export const CodeReportApprovalScalarFieldEnum: {
    Id: 'Id',
    CodeReportId: 'CodeReportId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    Comment: 'Comment',
    Approval: 'Approval',
    IsDelete: 'IsDelete'
  };

  export type CodeReportApprovalScalarFieldEnum = (typeof CodeReportApprovalScalarFieldEnum)[keyof typeof CodeReportApprovalScalarFieldEnum]


  export const DailyReportImageScalarFieldEnum: {
    Id: 'Id',
    CodeReportId: 'CodeReportId',
    ImageUrl: 'ImageUrl',
    Name: 'Name',
    Caption: 'Caption'
  };

  export type DailyReportImageScalarFieldEnum = (typeof DailyReportImageScalarFieldEnum)[keyof typeof DailyReportImageScalarFieldEnum]


  export const DailyTaskScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    Unit: 'Unit',
    Quantity: 'Quantity',
    ParentId: 'ParentId',
    CodeReportId: 'CodeReportId',
    Note: 'Note'
  };

  export type DailyTaskScalarFieldEnum = (typeof DailyTaskScalarFieldEnum)[keyof typeof DailyTaskScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Quantity: 'Quantity',
    Status: 'Status',
    Description: 'Description',
    Unit: 'Unit',
    CodeReportId: 'CodeReportId'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    BudgetPrice: 'BudgetPrice',
    Quantity: 'Quantity',
    Done: 'Done',
    IsDelete: 'IsDelete',
    CodeProjectId: 'CodeProjectId',
    ParentId: 'ParentId',
    EstimatedDuration: 'EstimatedDuration',
    Timeline: 'Timeline',
    Price: 'Price',
    Description: 'Description',
    Unit: 'Unit'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectTaskScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    ParentId: 'ParentId',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate'
  };

  export type ProjectTaskScalarFieldEnum = (typeof ProjectTaskScalarFieldEnum)[keyof typeof ProjectTaskScalarFieldEnum]


  export const RequestForInformationScalarFieldEnum: {
    Id: 'Id',
    CodeReportId: 'CodeReportId',
    Description: 'Description',
    Header: 'Header',
    AddressedFor: 'AddressedFor',
    IsDelete: 'IsDelete'
  };

  export type RequestForInformationScalarFieldEnum = (typeof RequestForInformationScalarFieldEnum)[keyof typeof RequestForInformationScalarFieldEnum]


  export const RequestForInformationAnswerScalarFieldEnum: {
    Id: 'Id',
    Answer: 'Answer',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    RequestForInformationId: 'RequestForInformationId',
    IsDelete: 'IsDelete'
  };

  export type RequestForInformationAnswerScalarFieldEnum = (typeof RequestForInformationAnswerScalarFieldEnum)[keyof typeof RequestForInformationAnswerScalarFieldEnum]


  export const RequestForInformationDocumentScalarFieldEnum: {
    Id: 'Id',
    RequestForInformationId: 'RequestForInformationId',
    ImageUrl: 'ImageUrl',
    Name: 'Name'
  };

  export type RequestForInformationDocumentScalarFieldEnum = (typeof RequestForInformationDocumentScalarFieldEnum)[keyof typeof RequestForInformationDocumentScalarFieldEnum]


  export const StatusReportScalarFieldEnum: {
    Id: 'Id',
    Status: 'Status',
    CodeReportId: 'CodeReportId'
  };

  export type StatusReportScalarFieldEnum = (typeof StatusReportScalarFieldEnum)[keyof typeof StatusReportScalarFieldEnum]


  export const StatusReportImageScalarFieldEnum: {
    Id: 'Id',
    StatusReportId: 'StatusReportId',
    ImageUrl: 'ImageUrl',
    Name: 'Name'
  };

  export type StatusReportImageScalarFieldEnum = (typeof StatusReportImageScalarFieldEnum)[keyof typeof StatusReportImageScalarFieldEnum]


  export const ToolScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Description: 'Description',
    Quantity: 'Quantity',
    CodeReportId: 'CodeReportId'
  };

  export type ToolScalarFieldEnum = (typeof ToolScalarFieldEnum)[keyof typeof ToolScalarFieldEnum]


  export const WeatherScalarFieldEnum: {
    Id: 'Id',
    WeatherId: 'WeatherId',
    CodeReportId: 'CodeReportId'
  };

  export type WeatherScalarFieldEnum = (typeof WeatherScalarFieldEnum)[keyof typeof WeatherScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    CodeReportId: 'CodeReportId',
    Quantity: 'Quantity'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const UserContactScalarFieldEnum: {
    Id: 'Id',
    PhoneNumber: 'PhoneNumber',
    UserId: 'UserId',
    WhatsappAvailable: 'WhatsappAvailable'
  };

  export type UserContactScalarFieldEnum = (typeof UserContactScalarFieldEnum)[keyof typeof UserContactScalarFieldEnum]


  export const UserPositionScalarFieldEnum: {
    Id: 'Id',
    Position: 'Position',
    EffectiveDate: 'EffectiveDate',
    CreatedBy: 'CreatedBy',
    CreatedDate: 'CreatedDate',
    UserId: 'UserId'
  };

  export type UserPositionScalarFieldEnum = (typeof UserPositionScalarFieldEnum)[keyof typeof UserPositionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    Id: 'Id',
    Email: 'Email',
    FirstName: 'FirstName',
    LastName: 'LastName',
    IsActive: 'IsActive',
    Password: 'Password',
    ImageUrl: 'ImageUrl',
    ThumbnailUrl: 'ThumbnailUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type clientWhereInput = {
    AND?: Enumerable<clientWhereInput>
    OR?: Enumerable<clientWhereInput>
    NOT?: Enumerable<clientWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Address?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    PhoneNumber?: StringNullableFilter | string | null
    TaxIdentificationNumber?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, userWhereInput>
    IsDelete?: BoolFilter | boolean
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Contact?: ClientContactListRelationFilter
    CodeProject?: CodeProjectListRelationFilter
  }

  export type clientOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    City?: SortOrder
    PhoneNumber?: SortOrder
    TaxIdentificationNumber?: SortOrder
    IsDelete?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
  }

  export type clientWhereUniqueInput = {
    Id?: number
  }

  export type clientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clientScalarWhereWithAggregatesInput>
    OR?: Enumerable<clientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clientScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Address?: StringNullableWithAggregatesFilter | string | null
    City?: StringNullableWithAggregatesFilter | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter | string | null
    TaxIdentificationNumber?: StringNullableWithAggregatesFilter | string | null
    IsDelete?: BoolWithAggregatesFilter | boolean
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type userTokenWhereInput = {
    AND?: Enumerable<userTokenWhereInput>
    OR?: Enumerable<userTokenWhereInput>
    NOT?: Enumerable<userTokenWhereInput>
    Id?: IntFilter | number
    UserId?: IntFilter | number
    Token?: StringFilter | string
    User?: XOR<UserRelationFilter, userWhereInput> | null
  }

  export type userTokenOrderByInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Token?: SortOrder
  }

  export type userTokenWhereUniqueInput = {
    Id?: number
  }

  export type userTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<userTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userTokenScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    UserId?: IntWithAggregatesFilter | number
    Token?: StringWithAggregatesFilter | string
  }

  export type clientContactWhereInput = {
    AND?: Enumerable<clientContactWhereInput>
    OR?: Enumerable<clientContactWhereInput>
    NOT?: Enumerable<clientContactWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Position?: StringFilter | string
    PhoneNumber?: StringFilter | string
    Email?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Client?: XOR<ClientRelationFilter, clientWhereInput>
    ClientId?: IntFilter | number
    User?: XOR<UserRelationFilter, userWhereInput>
  }

  export type clientContactOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Position?: SortOrder
    PhoneNumber?: SortOrder
    Email?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    ClientId?: SortOrder
  }

  export type clientContactWhereUniqueInput = {
    Id?: number
  }

  export type clientContactScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clientContactScalarWhereWithAggregatesInput>
    OR?: Enumerable<clientContactScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clientContactScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Position?: StringWithAggregatesFilter | string
    PhoneNumber?: StringWithAggregatesFilter | string
    Email?: StringWithAggregatesFilter | string
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    ClientId?: IntWithAggregatesFilter | number
  }

  export type codeProjectWhereInput = {
    AND?: Enumerable<codeProjectWhereInput>
    OR?: Enumerable<codeProjectWhereInput>
    NOT?: Enumerable<codeProjectWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    ClientId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    ConfirmedDate?: DateTimeNullableFilter | Date | string | null
    ConfirmedBy?: IntNullableFilter | number | null
    Address?: StringFilter | string
    DocumentName?: StringFilter | string
    IsCompleted?: BoolFilter | boolean
    CompletedDate?: DateTimeNullableFilter | Date | string | null
    CompletedBy?: IntNullableFilter | number | null
    IsDelete?: BoolFilter | boolean
    Client?: XOR<ClientRelationFilter, clientWhereInput>
    User1?: XOR<UserRelationFilter, userWhereInput>
    User2?: XOR<UserRelationFilter, userWhereInput> | null
    User3?: XOR<UserRelationFilter, userWhereInput> | null
    CodeProjectDocument?: CodeProjectDocumentListRelationFilter
    CodeProjectUser?: CodeProjectUserListRelationFilter
    CodeReport?: CodeReportListRelationFilter
    Project?: ProjectListRelationFilter
  }

  export type codeProjectOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    ClientId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    ConfirmedDate?: SortOrder
    ConfirmedBy?: SortOrder
    Address?: SortOrder
    DocumentName?: SortOrder
    IsCompleted?: SortOrder
    CompletedDate?: SortOrder
    CompletedBy?: SortOrder
    IsDelete?: SortOrder
  }

  export type codeProjectWhereUniqueInput = {
    Id?: number
  }

  export type codeProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<codeProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<codeProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<codeProjectScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    ClientId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    ConfirmedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ConfirmedBy?: IntNullableWithAggregatesFilter | number | null
    Address?: StringWithAggregatesFilter | string
    DocumentName?: StringWithAggregatesFilter | string
    IsCompleted?: BoolWithAggregatesFilter | boolean
    CompletedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CompletedBy?: IntNullableWithAggregatesFilter | number | null
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type codeProjectDocumentWhereInput = {
    AND?: Enumerable<codeProjectDocumentWhereInput>
    OR?: Enumerable<codeProjectDocumentWhereInput>
    NOT?: Enumerable<codeProjectDocumentWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Url?: StringFilter | string
    CodeProjectId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, userWhereInput>
    CodeProject?: XOR<CodeProjectRelationFilter, codeProjectWhereInput>
  }

  export type codeProjectDocumentOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Url?: SortOrder
    CodeProjectId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
  }

  export type codeProjectDocumentWhereUniqueInput = {
    Id?: number
  }

  export type codeProjectDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<codeProjectDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<codeProjectDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<codeProjectDocumentScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Url?: StringWithAggregatesFilter | string
    CodeProjectId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type codeProjectUserWhereInput = {
    AND?: Enumerable<codeProjectUserWhereInput>
    OR?: Enumerable<codeProjectUserWhereInput>
    NOT?: Enumerable<codeProjectUserWhereInput>
    Id?: IntFilter | number
    UserId?: IntFilter | number
    CodeProjectId?: IntFilter | number
    User?: XOR<UserRelationFilter, userWhereInput>
    CodeProject?: XOR<CodeProjectRelationFilter, codeProjectWhereInput>
  }

  export type codeProjectUserOrderByInput = {
    Id?: SortOrder
    UserId?: SortOrder
    CodeProjectId?: SortOrder
  }

  export type codeProjectUserWhereUniqueInput = {
    Id?: number
  }

  export type codeProjectUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<codeProjectUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<codeProjectUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<codeProjectUserScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    UserId?: IntWithAggregatesFilter | number
    CodeProjectId?: IntWithAggregatesFilter | number
  }

  export type codeReportWhereInput = {
    AND?: Enumerable<codeReportWhereInput>
    OR?: Enumerable<codeReportWhereInput>
    NOT?: Enumerable<codeReportWhereInput>
    Id?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Date?: DateTimeFilter | Date | string
    CodeProjectId?: IntFilter | number
    Type?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    Note?: StringFilter | string
    User?: XOR<UserRelationFilter, userWhereInput>
    CodeProject?: XOR<CodeProjectRelationFilter, codeProjectWhereInput>
    CodeReportApproval?: CodeReportApprovalListRelationFilter
    CodeReportApprovalComment?: CodeReportApprovalListRelationFilter
    DailyReportImage?: DailyReportImageListRelationFilter
    DailyTask?: DailyTaskListRelationFilter
    StatusReport?: XOR<StatusReportRelationFilter, statusReportWhereInput> | null
    Tool?: ToolListRelationFilter
    Weather?: XOR<WeatherRelationFilter, weatherWhereInput> | null
    Material?: MaterialListRelationFilter
    Worker?: WorkerListRelationFilter
    RequestForInformation?: XOR<RequestForInformationRelationFilter, requestForInformationWhereInput> | null
  }

  export type codeReportOrderByInput = {
    Id?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    Date?: SortOrder
    CodeProjectId?: SortOrder
    Type?: SortOrder
    IsDelete?: SortOrder
    Note?: SortOrder
  }

  export type codeReportWhereUniqueInput = {
    Id?: number
  }

  export type codeReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<codeReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<codeReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<codeReportScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    Date?: DateTimeWithAggregatesFilter | Date | string
    CodeProjectId?: IntWithAggregatesFilter | number
    Type?: IntWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
    Note?: StringWithAggregatesFilter | string
  }

  export type codeReportApprovalWhereInput = {
    AND?: Enumerable<codeReportApprovalWhereInput>
    OR?: Enumerable<codeReportApprovalWhereInput>
    NOT?: Enumerable<codeReportApprovalWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Comment?: StringFilter | string
    Approval?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
    CodeReportComment?: XOR<CodeReportRelationFilter, codeReportWhereInput>
    User?: XOR<UserRelationFilter, userWhereInput>
  }

  export type codeReportApprovalOrderByInput = {
    Id?: SortOrder
    CodeReportId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    Comment?: SortOrder
    Approval?: SortOrder
    IsDelete?: SortOrder
  }

  export type codeReportApprovalWhereUniqueInput = {
    Id?: number
  }

  export type codeReportApprovalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<codeReportApprovalScalarWhereWithAggregatesInput>
    OR?: Enumerable<codeReportApprovalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<codeReportApprovalScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    Comment?: StringWithAggregatesFilter | string
    Approval?: IntWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type dailyReportImageWhereInput = {
    AND?: Enumerable<dailyReportImageWhereInput>
    OR?: Enumerable<dailyReportImageWhereInput>
    NOT?: Enumerable<dailyReportImageWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    Caption?: StringFilter | string
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
  }

  export type dailyReportImageOrderByInput = {
    Id?: SortOrder
    CodeReportId?: SortOrder
    ImageUrl?: SortOrder
    Name?: SortOrder
    Caption?: SortOrder
  }

  export type dailyReportImageWhereUniqueInput = {
    Id?: number
  }

  export type dailyReportImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dailyReportImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<dailyReportImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dailyReportImageScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    ImageUrl?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
    Caption?: StringWithAggregatesFilter | string
  }

  export type dailyTaskWhereInput = {
    AND?: Enumerable<dailyTaskWhereInput>
    OR?: Enumerable<dailyTaskWhereInput>
    NOT?: Enumerable<dailyTaskWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Unit?: StringFilter | string
    Quantity?: FloatFilter | number
    ParentId?: IntFilter | number
    CodeReportId?: IntFilter | number
    Note?: StringFilter | string
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
  }

  export type dailyTaskOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Unit?: SortOrder
    Quantity?: SortOrder
    ParentId?: SortOrder
    CodeReportId?: SortOrder
    Note?: SortOrder
  }

  export type dailyTaskWhereUniqueInput = {
    Id?: number
  }

  export type dailyTaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dailyTaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<dailyTaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dailyTaskScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Description?: StringWithAggregatesFilter | string
    Unit?: StringWithAggregatesFilter | string
    Quantity?: FloatWithAggregatesFilter | number
    ParentId?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    Note?: StringWithAggregatesFilter | string
  }

  export type materialWhereInput = {
    AND?: Enumerable<materialWhereInput>
    OR?: Enumerable<materialWhereInput>
    NOT?: Enumerable<materialWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Quantity?: FloatFilter | number
    Status?: IntFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
  }

  export type materialOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Quantity?: SortOrder
    Status?: SortOrder
    Description?: SortOrder
    Unit?: SortOrder
    CodeReportId?: SortOrder
  }

  export type materialWhereUniqueInput = {
    Id?: number
  }

  export type materialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<materialScalarWhereWithAggregatesInput>
    OR?: Enumerable<materialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<materialScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Quantity?: FloatWithAggregatesFilter | number
    Status?: IntWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Unit?: StringWithAggregatesFilter | string
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type projectWhereInput = {
    AND?: Enumerable<projectWhereInput>
    OR?: Enumerable<projectWhereInput>
    NOT?: Enumerable<projectWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    BudgetPrice?: FloatFilter | number
    Quantity?: FloatFilter | number
    Done?: FloatFilter | number
    IsDelete?: BoolFilter | boolean
    CodeProjectId?: IntFilter | number
    ParentId?: IntFilter | number
    EstimatedDuration?: FloatFilter | number
    Timeline?: IntFilter | number
    Price?: FloatFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
    CodeProject?: XOR<CodeProjectRelationFilter, codeProjectWhereInput>
  }

  export type projectOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    BudgetPrice?: SortOrder
    Quantity?: SortOrder
    Done?: SortOrder
    IsDelete?: SortOrder
    CodeProjectId?: SortOrder
    ParentId?: SortOrder
    EstimatedDuration?: SortOrder
    Timeline?: SortOrder
    Price?: SortOrder
    Description?: SortOrder
    Unit?: SortOrder
  }

  export type projectWhereUniqueInput = {
    Id?: number
  }

  export type projectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<projectScalarWhereWithAggregatesInput>
    OR?: Enumerable<projectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<projectScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    BudgetPrice?: FloatWithAggregatesFilter | number
    Quantity?: FloatWithAggregatesFilter | number
    Done?: FloatWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
    CodeProjectId?: IntWithAggregatesFilter | number
    ParentId?: IntWithAggregatesFilter | number
    EstimatedDuration?: FloatWithAggregatesFilter | number
    Timeline?: IntWithAggregatesFilter | number
    Price?: FloatWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Unit?: StringWithAggregatesFilter | string
  }

  export type projectTaskWhereInput = {
    AND?: Enumerable<projectTaskWhereInput>
    OR?: Enumerable<projectTaskWhereInput>
    NOT?: Enumerable<projectTaskWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    ParentId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, userWhereInput>
  }

  export type projectTaskOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    ParentId?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
  }

  export type projectTaskWhereUniqueInput = {
    Id?: number
  }

  export type projectTaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<projectTaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<projectTaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<projectTaskScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Description?: StringWithAggregatesFilter | string
    ParentId?: IntWithAggregatesFilter | number
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type requestForInformationWhereInput = {
    AND?: Enumerable<requestForInformationWhereInput>
    OR?: Enumerable<requestForInformationWhereInput>
    NOT?: Enumerable<requestForInformationWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    Description?: StringFilter | string
    Header?: StringFilter | string
    AddressedFor?: StringFilter | string
    IsDelete?: BoolFilter | boolean
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
    RequestForInformationAnswer?: RequestForInformationAnswerListRelationFilter
    RequestForInformationDocument?: RequestForInformationDocumentListRelationFilter
  }

  export type requestForInformationOrderByInput = {
    Id?: SortOrder
    CodeReportId?: SortOrder
    Description?: SortOrder
    Header?: SortOrder
    AddressedFor?: SortOrder
    IsDelete?: SortOrder
  }

  export type requestForInformationWhereUniqueInput = {
    Id?: number
  }

  export type requestForInformationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<requestForInformationScalarWhereWithAggregatesInput>
    OR?: Enumerable<requestForInformationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<requestForInformationScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
    Description?: StringWithAggregatesFilter | string
    Header?: StringWithAggregatesFilter | string
    AddressedFor?: StringWithAggregatesFilter | string
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type requestForInformationAnswerWhereInput = {
    AND?: Enumerable<requestForInformationAnswerWhereInput>
    OR?: Enumerable<requestForInformationAnswerWhereInput>
    NOT?: Enumerable<requestForInformationAnswerWhereInput>
    Id?: IntFilter | number
    Answer?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    RequestForInformationId?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    User?: XOR<UserRelationFilter, userWhereInput>
    RequestForInformation?: XOR<RequestForInformationRelationFilter, requestForInformationWhereInput>
  }

  export type requestForInformationAnswerOrderByInput = {
    Id?: SortOrder
    Answer?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    RequestForInformationId?: SortOrder
    IsDelete?: SortOrder
  }

  export type requestForInformationAnswerWhereUniqueInput = {
    Id?: number
  }

  export type requestForInformationAnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<requestForInformationAnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<requestForInformationAnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<requestForInformationAnswerScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Answer?: StringWithAggregatesFilter | string
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    RequestForInformationId?: IntWithAggregatesFilter | number
    IsDelete?: BoolWithAggregatesFilter | boolean
  }

  export type requestForInformationDocumentWhereInput = {
    AND?: Enumerable<requestForInformationDocumentWhereInput>
    OR?: Enumerable<requestForInformationDocumentWhereInput>
    NOT?: Enumerable<requestForInformationDocumentWhereInput>
    Id?: IntFilter | number
    RequestForInformationId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    RequestForInformation?: XOR<RequestForInformationRelationFilter, requestForInformationWhereInput>
  }

  export type requestForInformationDocumentOrderByInput = {
    Id?: SortOrder
    RequestForInformationId?: SortOrder
    ImageUrl?: SortOrder
    Name?: SortOrder
  }

  export type requestForInformationDocumentWhereUniqueInput = {
    Id?: number
  }

  export type requestForInformationDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<requestForInformationDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<requestForInformationDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<requestForInformationDocumentScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    RequestForInformationId?: IntWithAggregatesFilter | number
    ImageUrl?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
  }

  export type statusReportWhereInput = {
    AND?: Enumerable<statusReportWhereInput>
    OR?: Enumerable<statusReportWhereInput>
    NOT?: Enumerable<statusReportWhereInput>
    Id?: IntFilter | number
    Status?: StringFilter | string
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
    StatusReportImage?: StatusReportImageListRelationFilter
  }

  export type statusReportOrderByInput = {
    Id?: SortOrder
    Status?: SortOrder
    CodeReportId?: SortOrder
  }

  export type statusReportWhereUniqueInput = {
    Id?: number
  }

  export type statusReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<statusReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<statusReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<statusReportScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Status?: StringWithAggregatesFilter | string
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type statusReportImageWhereInput = {
    AND?: Enumerable<statusReportImageWhereInput>
    OR?: Enumerable<statusReportImageWhereInput>
    NOT?: Enumerable<statusReportImageWhereInput>
    Id?: IntFilter | number
    StatusReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    StatusReport?: XOR<StatusReportRelationFilter, statusReportWhereInput>
  }

  export type statusReportImageOrderByInput = {
    Id?: SortOrder
    StatusReportId?: SortOrder
    ImageUrl?: SortOrder
    Name?: SortOrder
  }

  export type statusReportImageWhereUniqueInput = {
    Id?: number
  }

  export type statusReportImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<statusReportImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<statusReportImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<statusReportImageScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    StatusReportId?: IntWithAggregatesFilter | number
    ImageUrl?: StringWithAggregatesFilter | string
    Name?: StringWithAggregatesFilter | string
  }

  export type toolWhereInput = {
    AND?: Enumerable<toolWhereInput>
    OR?: Enumerable<toolWhereInput>
    NOT?: Enumerable<toolWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Quantity?: IntFilter | number
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
  }

  export type toolOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Quantity?: SortOrder
    CodeReportId?: SortOrder
  }

  export type toolWhereUniqueInput = {
    Id?: number
  }

  export type toolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<toolScalarWhereWithAggregatesInput>
    OR?: Enumerable<toolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<toolScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    Description?: StringWithAggregatesFilter | string
    Quantity?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type weatherWhereInput = {
    AND?: Enumerable<weatherWhereInput>
    OR?: Enumerable<weatherWhereInput>
    NOT?: Enumerable<weatherWhereInput>
    Id?: IntFilter | number
    WeatherId?: IntFilter | number
    CodeReportId?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
  }

  export type weatherOrderByInput = {
    Id?: SortOrder
    WeatherId?: SortOrder
    CodeReportId?: SortOrder
  }

  export type weatherWhereUniqueInput = {
    Id?: number
  }

  export type weatherScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weatherScalarWhereWithAggregatesInput>
    OR?: Enumerable<weatherScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weatherScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    WeatherId?: IntWithAggregatesFilter | number
    CodeReportId?: IntWithAggregatesFilter | number
  }

  export type workerWhereInput = {
    AND?: Enumerable<workerWhereInput>
    OR?: Enumerable<workerWhereInput>
    NOT?: Enumerable<workerWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    CodeReportId?: IntFilter | number
    Quantity?: IntFilter | number
    CodeReport?: XOR<CodeReportRelationFilter, codeReportWhereInput>
  }

  export type workerOrderByInput = {
    Id?: SortOrder
    Name?: SortOrder
    CodeReportId?: SortOrder
    Quantity?: SortOrder
  }

  export type workerWhereUniqueInput = {
    Id?: number
  }

  export type workerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<workerScalarWhereWithAggregatesInput>
    OR?: Enumerable<workerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<workerScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    CodeReportId?: IntWithAggregatesFilter | number
    Quantity?: IntWithAggregatesFilter | number
  }

  export type userContactWhereInput = {
    AND?: Enumerable<userContactWhereInput>
    OR?: Enumerable<userContactWhereInput>
    NOT?: Enumerable<userContactWhereInput>
    Id?: IntFilter | number
    PhoneNumber?: StringFilter | string
    UserId?: IntFilter | number
    WhatsappAvailable?: BoolFilter | boolean
    User?: XOR<UserRelationFilter, userWhereInput>
  }

  export type userContactOrderByInput = {
    Id?: SortOrder
    PhoneNumber?: SortOrder
    UserId?: SortOrder
    WhatsappAvailable?: SortOrder
  }

  export type userContactWhereUniqueInput = {
    Id?: number
  }

  export type userContactScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userContactScalarWhereWithAggregatesInput>
    OR?: Enumerable<userContactScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userContactScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    PhoneNumber?: StringWithAggregatesFilter | string
    UserId?: IntWithAggregatesFilter | number
    WhatsappAvailable?: BoolWithAggregatesFilter | boolean
  }

  export type userPositionWhereInput = {
    AND?: Enumerable<userPositionWhereInput>
    OR?: Enumerable<userPositionWhereInput>
    NOT?: Enumerable<userPositionWhereInput>
    Id?: IntFilter | number
    Position?: IntFilter | number
    EffectiveDate?: DateTimeFilter | Date | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    UserId?: IntFilter | number
    User4?: XOR<UserRelationFilter, userWhereInput>
    User5?: XOR<UserRelationFilter, userWhereInput>
  }

  export type userPositionOrderByInput = {
    Id?: SortOrder
    Position?: SortOrder
    EffectiveDate?: SortOrder
    CreatedBy?: SortOrder
    CreatedDate?: SortOrder
    UserId?: SortOrder
  }

  export type userPositionWhereUniqueInput = {
    Id?: number
  }

  export type userPositionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userPositionScalarWhereWithAggregatesInput>
    OR?: Enumerable<userPositionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userPositionScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Position?: IntWithAggregatesFilter | number
    EffectiveDate?: DateTimeWithAggregatesFilter | Date | string
    CreatedBy?: IntWithAggregatesFilter | number
    CreatedDate?: DateTimeWithAggregatesFilter | Date | string
    UserId?: IntWithAggregatesFilter | number
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    Id?: IntFilter | number
    Email?: StringFilter | string
    FirstName?: StringFilter | string
    LastName?: StringFilter | string
    IsActive?: BoolFilter | boolean
    Password?: StringNullableFilter | string | null
    ImageUrl?: StringNullableFilter | string | null
    ThumbnailUrl?: StringNullableFilter | string | null
    Client?: ClientListRelationFilter
    ClientContact?: ClientContactListRelationFilter
    CodeProjectDocument?: CodeProjectDocumentListRelationFilter
    CreateCodeProject?: CodeProjectListRelationFilter
    ConfirmedCodeProject?: CodeProjectListRelationFilter
    CompletedCodeProject?: CodeProjectListRelationFilter
    CodeProjectUser?: CodeProjectUserListRelationFilter
    CodeReport?: CodeReportListRelationFilter
    CodeReportApproval?: CodeReportApprovalListRelationFilter
    ProjectTask?: ProjectTaskListRelationFilter
    RequestForInformationAnswer?: RequestForInformationAnswerListRelationFilter
    CreateUserPosition?: UserPositionListRelationFilter
    UserPosition?: UserPositionListRelationFilter
    UserContact?: UserContactListRelationFilter
    Token?: UserTokenListRelationFilter
  }

  export type userOrderByInput = {
    Id?: SortOrder
    Email?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    IsActive?: SortOrder
    Password?: SortOrder
    ImageUrl?: SortOrder
    ThumbnailUrl?: SortOrder
  }

  export type userWhereUniqueInput = {
    Id?: number
    Email?: string
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    Id?: IntWithAggregatesFilter | number
    Email?: StringWithAggregatesFilter | string
    FirstName?: StringWithAggregatesFilter | string
    LastName?: StringWithAggregatesFilter | string
    IsActive?: BoolWithAggregatesFilter | boolean
    Password?: StringNullableWithAggregatesFilter | string | null
    ImageUrl?: StringNullableWithAggregatesFilter | string | null
    ThumbnailUrl?: StringNullableWithAggregatesFilter | string | null
  }

  export type clientCreateInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    User: userCreateNestedOneWithoutClientInput
    Contact?: clientContactCreateNestedManyWithoutClientInput
    CodeProject?: codeProjectCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
    Contact?: clientContactUncheckedCreateNestedManyWithoutClientInput
    CodeProject?: codeProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: userUpdateOneRequiredWithoutClientInput
    Contact?: clientContactUpdateManyWithoutClientInput
    CodeProject?: codeProjectUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: clientContactUncheckedUpdateManyWithoutClientInput
    CodeProject?: codeProjectUncheckedUpdateManyWithoutClientInput
  }

  export type clientCreateManyInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type clientUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTokenCreateInput = {
    Token: string
    User?: userCreateNestedOneWithoutTokenInput
  }

  export type userTokenUncheckedCreateInput = {
    Id?: number
    UserId: number
    Token: string
  }

  export type userTokenUpdateInput = {
    Token?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneWithoutTokenInput
  }

  export type userTokenUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    Token?: StringFieldUpdateOperationsInput | string
  }

  export type userTokenCreateManyInput = {
    Id?: number
    UserId: number
    Token: string
  }

  export type userTokenUpdateManyMutationInput = {
    Token?: StringFieldUpdateOperationsInput | string
  }

  export type userTokenUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    Token?: StringFieldUpdateOperationsInput | string
  }

  export type clientContactCreateInput = {
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    Client: clientCreateNestedOneWithoutContactInput
    User: userCreateNestedOneWithoutClientContactInput
  }

  export type clientContactUncheckedCreateInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
    ClientId: number
  }

  export type clientContactUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Client?: clientUpdateOneRequiredWithoutContactInput
    User?: userUpdateOneRequiredWithoutClientContactInput
  }

  export type clientContactUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type clientContactCreateManyInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
    ClientId: number
  }

  export type clientContactUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientContactUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type codeProjectCreateInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectCreateManyInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type codeProjectUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeProjectUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeProjectDocumentCreateInput = {
    Name: string
    Url: string
    CreatedDate?: Date | string
    User: userCreateNestedOneWithoutCodeProjectDocumentInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeProjectDocumentInput
  }

  export type codeProjectDocumentUncheckedCreateInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type codeProjectDocumentUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: userUpdateOneRequiredWithoutCodeProjectDocumentInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeProjectDocumentInput
  }

  export type codeProjectDocumentUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type codeProjectDocumentCreateManyInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type codeProjectDocumentUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type codeProjectDocumentUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type codeProjectUserCreateInput = {
    User: userCreateNestedOneWithoutCodeProjectUserInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeProjectUserInput
  }

  export type codeProjectUserUncheckedCreateInput = {
    Id?: number
    UserId: number
    CodeProjectId: number
  }

  export type codeProjectUserUpdateInput = {
    User?: userUpdateOneRequiredWithoutCodeProjectUserInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeProjectUserInput
  }

  export type codeProjectUserUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    CodeProjectId?: IntFieldUpdateOperationsInput | number
  }

  export type codeProjectUserCreateManyInput = {
    Id?: number
    UserId: number
    CodeProjectId: number
  }

  export type codeProjectUserUpdateManyMutationInput = {

  }

  export type codeProjectUserUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    CodeProjectId?: IntFieldUpdateOperationsInput | number
  }

  export type codeReportCreateInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUpdateInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportCreateManyInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
  }

  export type codeReportUpdateManyMutationInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type codeReportUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type codeReportApprovalCreateInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReport: codeReportCreateNestedOneWithoutCodeReportApprovalInput
    CodeReportComment: codeReportCreateNestedOneWithoutCodeReportApprovalCommentInput
    User: userCreateNestedOneWithoutCodeReportApprovalInput
  }

  export type codeReportApprovalUncheckedCreateInput = {
    Id?: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type codeReportApprovalUpdateInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: codeReportUpdateOneRequiredWithoutCodeReportApprovalInput
    CodeReportComment?: codeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput
    User?: userUpdateOneRequiredWithoutCodeReportApprovalInput
  }

  export type codeReportApprovalUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeReportApprovalCreateManyInput = {
    Id?: number
    CodeReportId: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type codeReportApprovalUpdateManyMutationInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeReportApprovalUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type dailyReportImageCreateInput = {
    ImageUrl: string
    Name: string
    Caption: string
    CodeReport: codeReportCreateNestedOneWithoutDailyReportImageInput
  }

  export type dailyReportImageUncheckedCreateInput = {
    Id?: number
    CodeReportId: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type dailyReportImageUpdateInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
    CodeReport?: codeReportUpdateOneRequiredWithoutDailyReportImageInput
  }

  export type dailyReportImageUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type dailyReportImageCreateManyInput = {
    Id?: number
    CodeReportId: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type dailyReportImageUpdateManyMutationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type dailyReportImageUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type dailyTaskCreateInput = {
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
    CodeReport: codeReportCreateNestedOneWithoutDailyTaskInput
  }

  export type dailyTaskUncheckedCreateInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: string
  }

  export type dailyTaskUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    CodeReport?: codeReportUpdateOneRequiredWithoutDailyTaskInput
  }

  export type dailyTaskUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type dailyTaskCreateManyInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    CodeReportId: number
    Note: string
  }

  export type dailyTaskUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type dailyTaskUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type materialCreateInput = {
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReport: codeReportCreateNestedOneWithoutMaterialInput
  }

  export type materialUncheckedCreateInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReportId: number
  }

  export type materialUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeReport?: codeReportUpdateOneRequiredWithoutMaterialInput
  }

  export type materialUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type materialCreateManyInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
    CodeReportId: number
  }

  export type materialUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type materialUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type projectCreateInput = {
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
    CodeProject: codeProjectCreateNestedOneWithoutProjectInput
  }

  export type projectUncheckedCreateInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type projectUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    CodeProject?: codeProjectUpdateOneRequiredWithoutProjectInput
  }

  export type projectUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type projectCreateManyInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    CodeProjectId: number
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type projectUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type projectUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type projectTaskCreateInput = {
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
    User: userCreateNestedOneWithoutProjectTaskInput
  }

  export type projectTaskUncheckedCreateInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type projectTaskUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: userUpdateOneRequiredWithoutProjectTaskInput
  }

  export type projectTaskUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projectTaskCreateManyInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type projectTaskUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projectTaskUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestForInformationCreateInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    CodeReport: codeReportCreateNestedOneWithoutRequestForInformationInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedCreateInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationUpdateInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: codeReportUpdateOneRequiredWithoutRequestForInformationInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentUpdateManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type requestForInformationCreateManyInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
  }

  export type requestForInformationUpdateManyMutationInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestForInformationUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestForInformationAnswerCreateInput = {
    Answer: string
    CreatedDate: Date | string
    IsDelete?: boolean
    User: userCreateNestedOneWithoutRequestForInformationAnswerInput
    RequestForInformation: requestForInformationCreateNestedOneWithoutRequestForInformationAnswerInput
  }

  export type requestForInformationAnswerUncheckedCreateInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type requestForInformationAnswerUpdateInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    User?: userUpdateOneRequiredWithoutRequestForInformationAnswerInput
    RequestForInformation?: requestForInformationUpdateOneRequiredWithoutRequestForInformationAnswerInput
  }

  export type requestForInformationAnswerUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestForInformationAnswerCreateManyInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type requestForInformationAnswerUpdateManyMutationInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestForInformationAnswerUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestForInformationDocumentCreateInput = {
    ImageUrl: string
    Name: string
    RequestForInformation: requestForInformationCreateNestedOneWithoutRequestForInformationDocumentInput
  }

  export type requestForInformationDocumentUncheckedCreateInput = {
    Id?: number
    RequestForInformationId: number
    ImageUrl: string
    Name: string
  }

  export type requestForInformationDocumentUpdateInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    RequestForInformation?: requestForInformationUpdateOneRequiredWithoutRequestForInformationDocumentInput
  }

  export type requestForInformationDocumentUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type requestForInformationDocumentCreateManyInput = {
    Id?: number
    RequestForInformationId: number
    ImageUrl: string
    Name: string
  }

  export type requestForInformationDocumentUpdateManyMutationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type requestForInformationDocumentUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type statusReportCreateInput = {
    Status: string
    CodeReport: codeReportCreateNestedOneWithoutStatusReportInput
    StatusReportImage?: statusReportImageCreateNestedManyWithoutStatusReportInput
  }

  export type statusReportUncheckedCreateInput = {
    Id?: number
    Status: string
    CodeReportId: number
    StatusReportImage?: statusReportImageUncheckedCreateNestedManyWithoutStatusReportInput
  }

  export type statusReportUpdateInput = {
    Status?: StringFieldUpdateOperationsInput | string
    CodeReport?: codeReportUpdateOneRequiredWithoutStatusReportInput
    StatusReportImage?: statusReportImageUpdateManyWithoutStatusReportInput
  }

  export type statusReportUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
    StatusReportImage?: statusReportImageUncheckedUpdateManyWithoutStatusReportInput
  }

  export type statusReportCreateManyInput = {
    Id?: number
    Status: string
    CodeReportId: number
  }

  export type statusReportUpdateManyMutationInput = {
    Status?: StringFieldUpdateOperationsInput | string
  }

  export type statusReportUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type statusReportImageCreateInput = {
    ImageUrl: string
    Name: string
    StatusReport: statusReportCreateNestedOneWithoutStatusReportImageInput
  }

  export type statusReportImageUncheckedCreateInput = {
    Id?: number
    StatusReportId: number
    ImageUrl: string
    Name: string
  }

  export type statusReportImageUpdateInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    StatusReport?: statusReportUpdateOneRequiredWithoutStatusReportImageInput
  }

  export type statusReportImageUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    StatusReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type statusReportImageCreateManyInput = {
    Id?: number
    StatusReportId: number
    ImageUrl: string
    Name: string
  }

  export type statusReportImageUpdateManyMutationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type statusReportImageUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    StatusReportId?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type toolCreateInput = {
    Name: string
    Description: string
    Quantity: number
    CodeReport: codeReportCreateNestedOneWithoutToolInput
  }

  export type toolUncheckedCreateInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
    CodeReportId: number
  }

  export type toolUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReport?: codeReportUpdateOneRequiredWithoutToolInput
  }

  export type toolUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type toolCreateManyInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
    CodeReportId: number
  }

  export type toolUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type toolUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type weatherCreateInput = {
    WeatherId: number
    CodeReport: codeReportCreateNestedOneWithoutWeatherInput
  }

  export type weatherUncheckedCreateInput = {
    Id?: number
    WeatherId: number
    CodeReportId: number
  }

  export type weatherUpdateInput = {
    WeatherId?: IntFieldUpdateOperationsInput | number
    CodeReport?: codeReportUpdateOneRequiredWithoutWeatherInput
  }

  export type weatherUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    WeatherId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type weatherCreateManyInput = {
    Id?: number
    WeatherId: number
    CodeReportId: number
  }

  export type weatherUpdateManyMutationInput = {
    WeatherId?: IntFieldUpdateOperationsInput | number
  }

  export type weatherUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    WeatherId?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type workerCreateInput = {
    Name: string
    Quantity: number
    CodeReport: codeReportCreateNestedOneWithoutWorkerInput
  }

  export type workerUncheckedCreateInput = {
    Id?: number
    Name: string
    CodeReportId: number
    Quantity: number
  }

  export type workerUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
    CodeReport?: codeReportUpdateOneRequiredWithoutWorkerInput
  }

  export type workerUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type workerCreateManyInput = {
    Id?: number
    Name: string
    CodeReportId: number
    Quantity: number
  }

  export type workerUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type workerUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type userContactCreateInput = {
    PhoneNumber: string
    WhatsappAvailable: boolean
    User: userCreateNestedOneWithoutUserContactInput
  }

  export type userContactUncheckedCreateInput = {
    Id?: number
    PhoneNumber: string
    UserId: number
    WhatsappAvailable: boolean
  }

  export type userContactUpdateInput = {
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
    User?: userUpdateOneRequiredWithoutUserContactInput
  }

  export type userContactUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    UserId?: IntFieldUpdateOperationsInput | number
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userContactCreateManyInput = {
    Id?: number
    PhoneNumber: string
    UserId: number
    WhatsappAvailable: boolean
  }

  export type userContactUpdateManyMutationInput = {
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userContactUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    UserId?: IntFieldUpdateOperationsInput | number
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userPositionCreateInput = {
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    User4: userCreateNestedOneWithoutCreateUserPositionInput
    User5: userCreateNestedOneWithoutUserPositionInput
  }

  export type userPositionUncheckedCreateInput = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
    UserId: number
  }

  export type userPositionUpdateInput = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User4?: userUpdateOneRequiredWithoutCreateUserPositionInput
    User5?: userUpdateOneRequiredWithoutUserPositionInput
  }

  export type userPositionUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type userPositionCreateManyInput = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
    UserId: number
  }

  export type userPositionUpdateManyMutationInput = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userPositionUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type userCreateManyInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
  }

  export type userUpdateManyMutationInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ClientContactListRelationFilter = {
    every?: clientContactWhereInput
    some?: clientContactWhereInput
    none?: clientContactWhereInput
  }

  export type CodeProjectListRelationFilter = {
    every?: codeProjectWhereInput
    some?: codeProjectWhereInput
    none?: codeProjectWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type ClientRelationFilter = {
    is?: clientWhereInput
    isNot?: clientWhereInput
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CodeProjectDocumentListRelationFilter = {
    every?: codeProjectDocumentWhereInput
    some?: codeProjectDocumentWhereInput
    none?: codeProjectDocumentWhereInput
  }

  export type CodeProjectUserListRelationFilter = {
    every?: codeProjectUserWhereInput
    some?: codeProjectUserWhereInput
    none?: codeProjectUserWhereInput
  }

  export type CodeReportListRelationFilter = {
    every?: codeReportWhereInput
    some?: codeReportWhereInput
    none?: codeReportWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: projectWhereInput
    some?: projectWhereInput
    none?: projectWhereInput
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type CodeProjectRelationFilter = {
    is?: codeProjectWhereInput
    isNot?: codeProjectWhereInput
  }

  export type CodeReportApprovalListRelationFilter = {
    every?: codeReportApprovalWhereInput
    some?: codeReportApprovalWhereInput
    none?: codeReportApprovalWhereInput
  }

  export type DailyReportImageListRelationFilter = {
    every?: dailyReportImageWhereInput
    some?: dailyReportImageWhereInput
    none?: dailyReportImageWhereInput
  }

  export type DailyTaskListRelationFilter = {
    every?: dailyTaskWhereInput
    some?: dailyTaskWhereInput
    none?: dailyTaskWhereInput
  }

  export type StatusReportRelationFilter = {
    is?: statusReportWhereInput
    isNot?: statusReportWhereInput
  }

  export type ToolListRelationFilter = {
    every?: toolWhereInput
    some?: toolWhereInput
    none?: toolWhereInput
  }

  export type WeatherRelationFilter = {
    is?: weatherWhereInput | null
    isNot?: weatherWhereInput | null
  }

  export type MaterialListRelationFilter = {
    every?: materialWhereInput
    some?: materialWhereInput
    none?: materialWhereInput
  }

  export type WorkerListRelationFilter = {
    every?: workerWhereInput
    some?: workerWhereInput
    none?: workerWhereInput
  }

  export type RequestForInformationRelationFilter = {
    is?: requestForInformationWhereInput
    isNot?: requestForInformationWhereInput
  }

  export type CodeReportRelationFilter = {
    is?: codeReportWhereInput
    isNot?: codeReportWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type RequestForInformationAnswerListRelationFilter = {
    every?: requestForInformationAnswerWhereInput
    some?: requestForInformationAnswerWhereInput
    none?: requestForInformationAnswerWhereInput
  }

  export type RequestForInformationDocumentListRelationFilter = {
    every?: requestForInformationDocumentWhereInput
    some?: requestForInformationDocumentWhereInput
    none?: requestForInformationDocumentWhereInput
  }

  export type StatusReportImageListRelationFilter = {
    every?: statusReportImageWhereInput
    some?: statusReportImageWhereInput
    none?: statusReportImageWhereInput
  }

  export type ClientListRelationFilter = {
    every?: clientWhereInput
    some?: clientWhereInput
    none?: clientWhereInput
  }

  export type ProjectTaskListRelationFilter = {
    every?: projectTaskWhereInput
    some?: projectTaskWhereInput
    none?: projectTaskWhereInput
  }

  export type UserPositionListRelationFilter = {
    every?: userPositionWhereInput
    some?: userPositionWhereInput
    none?: userPositionWhereInput
  }

  export type UserContactListRelationFilter = {
    every?: userContactWhereInput
    some?: userContactWhereInput
    none?: userContactWhereInput
  }

  export type UserTokenListRelationFilter = {
    every?: userTokenWhereInput
    some?: userTokenWhereInput
    none?: userTokenWhereInput
  }

  export type userCreateNestedOneWithoutClientInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
    connectOrCreate?: userCreateOrConnectWithoutClientInput
    connect?: userWhereUniqueInput
  }

  export type clientContactCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutClientInput>, Enumerable<clientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutClientInput>
    createMany?: clientContactCreateManyClientInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
  }

  export type codeProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<codeProjectCreateWithoutClientInput>, Enumerable<codeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutClientInput>
    createMany?: codeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type clientContactUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutClientInput>, Enumerable<clientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutClientInput>
    createMany?: clientContactCreateManyClientInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
  }

  export type codeProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<Enumerable<codeProjectCreateWithoutClientInput>, Enumerable<codeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutClientInput>
    createMany?: codeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type userUpdateOneRequiredWithoutClientInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
    connectOrCreate?: userCreateOrConnectWithoutClientInput
    upsert?: userUpsertWithoutClientInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutClientInput, userUncheckedUpdateWithoutClientInput>
  }

  export type clientContactUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutClientInput>, Enumerable<clientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<clientContactUpsertWithWhereUniqueWithoutClientInput>
    createMany?: clientContactCreateManyClientInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
    set?: Enumerable<clientContactWhereUniqueInput>
    disconnect?: Enumerable<clientContactWhereUniqueInput>
    delete?: Enumerable<clientContactWhereUniqueInput>
    update?: Enumerable<clientContactUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<clientContactUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<clientContactScalarWhereInput>
  }

  export type codeProjectUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<codeProjectCreateWithoutClientInput>, Enumerable<codeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutClientInput>
    createMany?: codeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type clientContactUncheckedUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutClientInput>, Enumerable<clientContactUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<clientContactUpsertWithWhereUniqueWithoutClientInput>
    createMany?: clientContactCreateManyClientInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
    set?: Enumerable<clientContactWhereUniqueInput>
    disconnect?: Enumerable<clientContactWhereUniqueInput>
    delete?: Enumerable<clientContactWhereUniqueInput>
    update?: Enumerable<clientContactUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<clientContactUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<clientContactScalarWhereInput>
  }

  export type codeProjectUncheckedUpdateManyWithoutClientInput = {
    create?: XOR<Enumerable<codeProjectCreateWithoutClientInput>, Enumerable<codeProjectUncheckedCreateWithoutClientInput>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutClientInput>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutClientInput>
    createMany?: codeProjectCreateManyClientInputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutClientInput>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutClientInput>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type userCreateNestedOneWithoutTokenInput = {
    create?: XOR<userCreateWithoutTokenInput, userUncheckedCreateWithoutTokenInput>
    connectOrCreate?: userCreateOrConnectWithoutTokenInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutTokenInput = {
    create?: XOR<userCreateWithoutTokenInput, userUncheckedCreateWithoutTokenInput>
    connectOrCreate?: userCreateOrConnectWithoutTokenInput
    upsert?: userUpsertWithoutTokenInput
    connect?: userWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<userUpdateWithoutTokenInput, userUncheckedUpdateWithoutTokenInput>
  }

  export type clientCreateNestedOneWithoutContactInput = {
    create?: XOR<clientCreateWithoutContactInput, clientUncheckedCreateWithoutContactInput>
    connectOrCreate?: clientCreateOrConnectWithoutContactInput
    connect?: clientWhereUniqueInput
  }

  export type userCreateNestedOneWithoutClientContactInput = {
    create?: XOR<userCreateWithoutClientContactInput, userUncheckedCreateWithoutClientContactInput>
    connectOrCreate?: userCreateOrConnectWithoutClientContactInput
    connect?: userWhereUniqueInput
  }

  export type clientUpdateOneRequiredWithoutContactInput = {
    create?: XOR<clientCreateWithoutContactInput, clientUncheckedCreateWithoutContactInput>
    connectOrCreate?: clientCreateOrConnectWithoutContactInput
    upsert?: clientUpsertWithoutContactInput
    connect?: clientWhereUniqueInput
    update?: XOR<clientUpdateWithoutContactInput, clientUncheckedUpdateWithoutContactInput>
  }

  export type userUpdateOneRequiredWithoutClientContactInput = {
    create?: XOR<userCreateWithoutClientContactInput, userUncheckedCreateWithoutClientContactInput>
    connectOrCreate?: userCreateOrConnectWithoutClientContactInput
    upsert?: userUpsertWithoutClientContactInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutClientContactInput, userUncheckedUpdateWithoutClientContactInput>
  }

  export type clientCreateNestedOneWithoutCodeProjectInput = {
    create?: XOR<clientCreateWithoutCodeProjectInput, clientUncheckedCreateWithoutCodeProjectInput>
    connectOrCreate?: clientCreateOrConnectWithoutCodeProjectInput
    connect?: clientWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCreateCodeProjectInput = {
    create?: XOR<userCreateWithoutCreateCodeProjectInput, userUncheckedCreateWithoutCreateCodeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateCodeProjectInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutConfirmedCodeProjectInput = {
    create?: XOR<userCreateWithoutConfirmedCodeProjectInput, userUncheckedCreateWithoutConfirmedCodeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutConfirmedCodeProjectInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCompletedCodeProjectInput = {
    create?: XOR<userCreateWithoutCompletedCodeProjectInput, userUncheckedCreateWithoutCompletedCodeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutCompletedCodeProjectInput
    connect?: userWhereUniqueInput
  }

  export type codeProjectDocumentCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    createMany?: codeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
  }

  export type codeProjectUserCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutCodeProjectInput>, Enumerable<codeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutCodeProjectInput>
    createMany?: codeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
  }

  export type codeReportCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutCodeProjectInput>, Enumerable<codeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutCodeProjectInput>
    createMany?: codeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
  }

  export type projectCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<projectCreateWithoutCodeProjectInput>, Enumerable<projectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<projectCreateOrConnectWithoutCodeProjectInput>
    createMany?: projectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<projectWhereUniqueInput>
  }

  export type codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    createMany?: codeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
  }

  export type codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutCodeProjectInput>, Enumerable<codeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutCodeProjectInput>
    createMany?: codeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
  }

  export type codeReportUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutCodeProjectInput>, Enumerable<codeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutCodeProjectInput>
    createMany?: codeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
  }

  export type projectUncheckedCreateNestedManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<projectCreateWithoutCodeProjectInput>, Enumerable<projectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<projectCreateOrConnectWithoutCodeProjectInput>
    createMany?: projectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<projectWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type clientUpdateOneRequiredWithoutCodeProjectInput = {
    create?: XOR<clientCreateWithoutCodeProjectInput, clientUncheckedCreateWithoutCodeProjectInput>
    connectOrCreate?: clientCreateOrConnectWithoutCodeProjectInput
    upsert?: clientUpsertWithoutCodeProjectInput
    connect?: clientWhereUniqueInput
    update?: XOR<clientUpdateWithoutCodeProjectInput, clientUncheckedUpdateWithoutCodeProjectInput>
  }

  export type userUpdateOneRequiredWithoutCreateCodeProjectInput = {
    create?: XOR<userCreateWithoutCreateCodeProjectInput, userUncheckedCreateWithoutCreateCodeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateCodeProjectInput
    upsert?: userUpsertWithoutCreateCodeProjectInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCreateCodeProjectInput, userUncheckedUpdateWithoutCreateCodeProjectInput>
  }

  export type userUpdateOneWithoutConfirmedCodeProjectInput = {
    create?: XOR<userCreateWithoutConfirmedCodeProjectInput, userUncheckedCreateWithoutConfirmedCodeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutConfirmedCodeProjectInput
    upsert?: userUpsertWithoutConfirmedCodeProjectInput
    connect?: userWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<userUpdateWithoutConfirmedCodeProjectInput, userUncheckedUpdateWithoutConfirmedCodeProjectInput>
  }

  export type userUpdateOneWithoutCompletedCodeProjectInput = {
    create?: XOR<userCreateWithoutCompletedCodeProjectInput, userUncheckedCreateWithoutCompletedCodeProjectInput>
    connectOrCreate?: userCreateOrConnectWithoutCompletedCodeProjectInput
    upsert?: userUpsertWithoutCompletedCodeProjectInput
    connect?: userWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<userUpdateWithoutCompletedCodeProjectInput, userUncheckedUpdateWithoutCompletedCodeProjectInput>
  }

  export type codeProjectDocumentUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<codeProjectDocumentUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: codeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    set?: Enumerable<codeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<codeProjectDocumentWhereUniqueInput>
    update?: Enumerable<codeProjectDocumentUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<codeProjectDocumentUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<codeProjectDocumentScalarWhereInput>
  }

  export type codeProjectUserUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutCodeProjectInput>, Enumerable<codeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<codeProjectUserUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: codeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
    set?: Enumerable<codeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<codeProjectUserWhereUniqueInput>
    delete?: Enumerable<codeProjectUserWhereUniqueInput>
    update?: Enumerable<codeProjectUserUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<codeProjectUserUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<codeProjectUserScalarWhereInput>
  }

  export type codeReportUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutCodeProjectInput>, Enumerable<codeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<codeReportUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: codeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
    set?: Enumerable<codeReportWhereUniqueInput>
    disconnect?: Enumerable<codeReportWhereUniqueInput>
    delete?: Enumerable<codeReportWhereUniqueInput>
    update?: Enumerable<codeReportUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<codeReportUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<codeReportScalarWhereInput>
  }

  export type projectUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<projectCreateWithoutCodeProjectInput>, Enumerable<projectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<projectCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<projectUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: projectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<projectWhereUniqueInput>
    set?: Enumerable<projectWhereUniqueInput>
    disconnect?: Enumerable<projectWhereUniqueInput>
    delete?: Enumerable<projectWhereUniqueInput>
    update?: Enumerable<projectUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<projectUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<projectScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutCodeProjectInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<codeProjectDocumentUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: codeProjectDocumentCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    set?: Enumerable<codeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<codeProjectDocumentWhereUniqueInput>
    update?: Enumerable<codeProjectDocumentUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<codeProjectDocumentUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<codeProjectDocumentScalarWhereInput>
  }

  export type codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutCodeProjectInput>, Enumerable<codeProjectUserUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<codeProjectUserUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: codeProjectUserCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
    set?: Enumerable<codeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<codeProjectUserWhereUniqueInput>
    delete?: Enumerable<codeProjectUserWhereUniqueInput>
    update?: Enumerable<codeProjectUserUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<codeProjectUserUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<codeProjectUserScalarWhereInput>
  }

  export type codeReportUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutCodeProjectInput>, Enumerable<codeReportUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<codeReportUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: codeReportCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
    set?: Enumerable<codeReportWhereUniqueInput>
    disconnect?: Enumerable<codeReportWhereUniqueInput>
    delete?: Enumerable<codeReportWhereUniqueInput>
    update?: Enumerable<codeReportUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<codeReportUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<codeReportScalarWhereInput>
  }

  export type projectUncheckedUpdateManyWithoutCodeProjectInput = {
    create?: XOR<Enumerable<projectCreateWithoutCodeProjectInput>, Enumerable<projectUncheckedCreateWithoutCodeProjectInput>>
    connectOrCreate?: Enumerable<projectCreateOrConnectWithoutCodeProjectInput>
    upsert?: Enumerable<projectUpsertWithWhereUniqueWithoutCodeProjectInput>
    createMany?: projectCreateManyCodeProjectInputEnvelope
    connect?: Enumerable<projectWhereUniqueInput>
    set?: Enumerable<projectWhereUniqueInput>
    disconnect?: Enumerable<projectWhereUniqueInput>
    delete?: Enumerable<projectWhereUniqueInput>
    update?: Enumerable<projectUpdateWithWhereUniqueWithoutCodeProjectInput>
    updateMany?: Enumerable<projectUpdateManyWithWhereWithoutCodeProjectInput>
    deleteMany?: Enumerable<projectScalarWhereInput>
  }

  export type userCreateNestedOneWithoutCodeProjectDocumentInput = {
    create?: XOR<userCreateWithoutCodeProjectDocumentInput, userUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeProjectDocumentInput
    connect?: userWhereUniqueInput
  }

  export type codeProjectCreateNestedOneWithoutCodeProjectDocumentInput = {
    create?: XOR<codeProjectCreateWithoutCodeProjectDocumentInput, codeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutCodeProjectDocumentInput
    connect?: codeProjectWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCodeProjectDocumentInput = {
    create?: XOR<userCreateWithoutCodeProjectDocumentInput, userUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeProjectDocumentInput
    upsert?: userUpsertWithoutCodeProjectDocumentInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCodeProjectDocumentInput, userUncheckedUpdateWithoutCodeProjectDocumentInput>
  }

  export type codeProjectUpdateOneRequiredWithoutCodeProjectDocumentInput = {
    create?: XOR<codeProjectCreateWithoutCodeProjectDocumentInput, codeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutCodeProjectDocumentInput
    upsert?: codeProjectUpsertWithoutCodeProjectDocumentInput
    connect?: codeProjectWhereUniqueInput
    update?: XOR<codeProjectUpdateWithoutCodeProjectDocumentInput, codeProjectUncheckedUpdateWithoutCodeProjectDocumentInput>
  }

  export type userCreateNestedOneWithoutCodeProjectUserInput = {
    create?: XOR<userCreateWithoutCodeProjectUserInput, userUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeProjectUserInput
    connect?: userWhereUniqueInput
  }

  export type codeProjectCreateNestedOneWithoutCodeProjectUserInput = {
    create?: XOR<codeProjectCreateWithoutCodeProjectUserInput, codeProjectUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutCodeProjectUserInput
    connect?: codeProjectWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCodeProjectUserInput = {
    create?: XOR<userCreateWithoutCodeProjectUserInput, userUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeProjectUserInput
    upsert?: userUpsertWithoutCodeProjectUserInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCodeProjectUserInput, userUncheckedUpdateWithoutCodeProjectUserInput>
  }

  export type codeProjectUpdateOneRequiredWithoutCodeProjectUserInput = {
    create?: XOR<codeProjectCreateWithoutCodeProjectUserInput, codeProjectUncheckedCreateWithoutCodeProjectUserInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutCodeProjectUserInput
    upsert?: codeProjectUpsertWithoutCodeProjectUserInput
    connect?: codeProjectWhereUniqueInput
    update?: XOR<codeProjectUpdateWithoutCodeProjectUserInput, codeProjectUncheckedUpdateWithoutCodeProjectUserInput>
  }

  export type userCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<userCreateWithoutCodeReportInput, userUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeReportInput
    connect?: userWhereUniqueInput
  }

  export type codeProjectCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<codeProjectCreateWithoutCodeReportInput, codeProjectUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutCodeReportInput
    connect?: codeProjectWhereUniqueInput
  }

  export type codeReportApprovalCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportInput>
    createMany?: codeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
  }

  export type codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    createMany?: codeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
  }

  export type dailyReportImageCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyReportImageCreateWithoutCodeReportInput>, Enumerable<dailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyReportImageCreateOrConnectWithoutCodeReportInput>
    createMany?: dailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyReportImageWhereUniqueInput>
  }

  export type dailyTaskCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyTaskCreateWithoutCodeReportInput>, Enumerable<dailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyTaskCreateOrConnectWithoutCodeReportInput>
    createMany?: dailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyTaskWhereUniqueInput>
  }

  export type statusReportCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<statusReportCreateWithoutCodeReportInput, statusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: statusReportCreateOrConnectWithoutCodeReportInput
    connect?: statusReportWhereUniqueInput
  }

  export type toolCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<toolCreateWithoutCodeReportInput>, Enumerable<toolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<toolCreateOrConnectWithoutCodeReportInput>
    createMany?: toolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<toolWhereUniqueInput>
  }

  export type weatherCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<weatherCreateWithoutCodeReportInput, weatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: weatherCreateOrConnectWithoutCodeReportInput
    connect?: weatherWhereUniqueInput
  }

  export type materialCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<materialCreateWithoutCodeReportInput>, Enumerable<materialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<materialCreateOrConnectWithoutCodeReportInput>
    createMany?: materialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<materialWhereUniqueInput>
  }

  export type workerCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<workerCreateWithoutCodeReportInput>, Enumerable<workerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<workerCreateOrConnectWithoutCodeReportInput>
    createMany?: workerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<workerWhereUniqueInput>
  }

  export type requestForInformationCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<requestForInformationCreateWithoutCodeReportInput, requestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutCodeReportInput
    connect?: requestForInformationWhereUniqueInput
  }

  export type codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportInput>
    createMany?: codeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
  }

  export type codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    createMany?: codeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
  }

  export type dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyReportImageCreateWithoutCodeReportInput>, Enumerable<dailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyReportImageCreateOrConnectWithoutCodeReportInput>
    createMany?: dailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyReportImageWhereUniqueInput>
  }

  export type dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyTaskCreateWithoutCodeReportInput>, Enumerable<dailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyTaskCreateOrConnectWithoutCodeReportInput>
    createMany?: dailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyTaskWhereUniqueInput>
  }

  export type statusReportUncheckedCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<statusReportCreateWithoutCodeReportInput, statusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: statusReportCreateOrConnectWithoutCodeReportInput
    connect?: statusReportWhereUniqueInput
  }

  export type toolUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<toolCreateWithoutCodeReportInput>, Enumerable<toolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<toolCreateOrConnectWithoutCodeReportInput>
    createMany?: toolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<toolWhereUniqueInput>
  }

  export type weatherUncheckedCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<weatherCreateWithoutCodeReportInput, weatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: weatherCreateOrConnectWithoutCodeReportInput
    connect?: weatherWhereUniqueInput
  }

  export type materialUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<materialCreateWithoutCodeReportInput>, Enumerable<materialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<materialCreateOrConnectWithoutCodeReportInput>
    createMany?: materialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<materialWhereUniqueInput>
  }

  export type workerUncheckedCreateNestedManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<workerCreateWithoutCodeReportInput>, Enumerable<workerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<workerCreateOrConnectWithoutCodeReportInput>
    createMany?: workerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<workerWhereUniqueInput>
  }

  export type requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput = {
    create?: XOR<requestForInformationCreateWithoutCodeReportInput, requestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutCodeReportInput
    connect?: requestForInformationWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCodeReportInput = {
    create?: XOR<userCreateWithoutCodeReportInput, userUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeReportInput
    upsert?: userUpsertWithoutCodeReportInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCodeReportInput, userUncheckedUpdateWithoutCodeReportInput>
  }

  export type codeProjectUpdateOneRequiredWithoutCodeReportInput = {
    create?: XOR<codeProjectCreateWithoutCodeReportInput, codeProjectUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutCodeReportInput
    upsert?: codeProjectUpsertWithoutCodeReportInput
    connect?: codeProjectWhereUniqueInput
    update?: XOR<codeProjectUpdateWithoutCodeReportInput, codeProjectUncheckedUpdateWithoutCodeReportInput>
  }

  export type codeReportApprovalUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<codeReportApprovalUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: codeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
    set?: Enumerable<codeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<codeReportApprovalWhereUniqueInput>
    delete?: Enumerable<codeReportApprovalWhereUniqueInput>
    update?: Enumerable<codeReportApprovalUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<codeReportApprovalUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<codeReportApprovalScalarWhereInput>
  }

  export type codeReportApprovalUpdateManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    upsert?: Enumerable<codeReportApprovalUpsertWithWhereUniqueWithoutCodeReportCommentInput>
    createMany?: codeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
    set?: Enumerable<codeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<codeReportApprovalWhereUniqueInput>
    delete?: Enumerable<codeReportApprovalWhereUniqueInput>
    update?: Enumerable<codeReportApprovalUpdateWithWhereUniqueWithoutCodeReportCommentInput>
    updateMany?: Enumerable<codeReportApprovalUpdateManyWithWhereWithoutCodeReportCommentInput>
    deleteMany?: Enumerable<codeReportApprovalScalarWhereInput>
  }

  export type dailyReportImageUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyReportImageCreateWithoutCodeReportInput>, Enumerable<dailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyReportImageCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<dailyReportImageUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: dailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyReportImageWhereUniqueInput>
    set?: Enumerable<dailyReportImageWhereUniqueInput>
    disconnect?: Enumerable<dailyReportImageWhereUniqueInput>
    delete?: Enumerable<dailyReportImageWhereUniqueInput>
    update?: Enumerable<dailyReportImageUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<dailyReportImageUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<dailyReportImageScalarWhereInput>
  }

  export type dailyTaskUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyTaskCreateWithoutCodeReportInput>, Enumerable<dailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyTaskCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<dailyTaskUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: dailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyTaskWhereUniqueInput>
    set?: Enumerable<dailyTaskWhereUniqueInput>
    disconnect?: Enumerable<dailyTaskWhereUniqueInput>
    delete?: Enumerable<dailyTaskWhereUniqueInput>
    update?: Enumerable<dailyTaskUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<dailyTaskUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<dailyTaskScalarWhereInput>
  }

  export type statusReportUpdateOneWithoutCodeReportInput = {
    create?: XOR<statusReportCreateWithoutCodeReportInput, statusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: statusReportCreateOrConnectWithoutCodeReportInput
    upsert?: statusReportUpsertWithoutCodeReportInput
    connect?: statusReportWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<statusReportUpdateWithoutCodeReportInput, statusReportUncheckedUpdateWithoutCodeReportInput>
  }

  export type toolUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<toolCreateWithoutCodeReportInput>, Enumerable<toolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<toolCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<toolUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: toolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<toolWhereUniqueInput>
    set?: Enumerable<toolWhereUniqueInput>
    disconnect?: Enumerable<toolWhereUniqueInput>
    delete?: Enumerable<toolWhereUniqueInput>
    update?: Enumerable<toolUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<toolUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<toolScalarWhereInput>
  }

  export type weatherUpdateOneWithoutCodeReportInput = {
    create?: XOR<weatherCreateWithoutCodeReportInput, weatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: weatherCreateOrConnectWithoutCodeReportInput
    upsert?: weatherUpsertWithoutCodeReportInput
    connect?: weatherWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<weatherUpdateWithoutCodeReportInput, weatherUncheckedUpdateWithoutCodeReportInput>
  }

  export type materialUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<materialCreateWithoutCodeReportInput>, Enumerable<materialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<materialCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<materialUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: materialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<materialWhereUniqueInput>
    set?: Enumerable<materialWhereUniqueInput>
    disconnect?: Enumerable<materialWhereUniqueInput>
    delete?: Enumerable<materialWhereUniqueInput>
    update?: Enumerable<materialUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<materialUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<materialScalarWhereInput>
  }

  export type workerUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<workerCreateWithoutCodeReportInput>, Enumerable<workerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<workerCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<workerUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: workerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<workerWhereUniqueInput>
    set?: Enumerable<workerWhereUniqueInput>
    disconnect?: Enumerable<workerWhereUniqueInput>
    delete?: Enumerable<workerWhereUniqueInput>
    update?: Enumerable<workerUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<workerUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<workerScalarWhereInput>
  }

  export type requestForInformationUpdateOneWithoutCodeReportInput = {
    create?: XOR<requestForInformationCreateWithoutCodeReportInput, requestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutCodeReportInput
    upsert?: requestForInformationUpsertWithoutCodeReportInput
    connect?: requestForInformationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<requestForInformationUpdateWithoutCodeReportInput, requestForInformationUncheckedUpdateWithoutCodeReportInput>
  }

  export type codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<codeReportApprovalUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: codeReportApprovalCreateManyCodeReportInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
    set?: Enumerable<codeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<codeReportApprovalWhereUniqueInput>
    delete?: Enumerable<codeReportApprovalWhereUniqueInput>
    update?: Enumerable<codeReportApprovalUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<codeReportApprovalUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<codeReportApprovalScalarWhereInput>
  }

  export type codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutCodeReportCommentInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutCodeReportCommentInput>
    upsert?: Enumerable<codeReportApprovalUpsertWithWhereUniqueWithoutCodeReportCommentInput>
    createMany?: codeReportApprovalCreateManyCodeReportCommentInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
    set?: Enumerable<codeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<codeReportApprovalWhereUniqueInput>
    delete?: Enumerable<codeReportApprovalWhereUniqueInput>
    update?: Enumerable<codeReportApprovalUpdateWithWhereUniqueWithoutCodeReportCommentInput>
    updateMany?: Enumerable<codeReportApprovalUpdateManyWithWhereWithoutCodeReportCommentInput>
    deleteMany?: Enumerable<codeReportApprovalScalarWhereInput>
  }

  export type dailyReportImageUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyReportImageCreateWithoutCodeReportInput>, Enumerable<dailyReportImageUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyReportImageCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<dailyReportImageUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: dailyReportImageCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyReportImageWhereUniqueInput>
    set?: Enumerable<dailyReportImageWhereUniqueInput>
    disconnect?: Enumerable<dailyReportImageWhereUniqueInput>
    delete?: Enumerable<dailyReportImageWhereUniqueInput>
    update?: Enumerable<dailyReportImageUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<dailyReportImageUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<dailyReportImageScalarWhereInput>
  }

  export type dailyTaskUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<dailyTaskCreateWithoutCodeReportInput>, Enumerable<dailyTaskUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<dailyTaskCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<dailyTaskUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: dailyTaskCreateManyCodeReportInputEnvelope
    connect?: Enumerable<dailyTaskWhereUniqueInput>
    set?: Enumerable<dailyTaskWhereUniqueInput>
    disconnect?: Enumerable<dailyTaskWhereUniqueInput>
    delete?: Enumerable<dailyTaskWhereUniqueInput>
    update?: Enumerable<dailyTaskUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<dailyTaskUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<dailyTaskScalarWhereInput>
  }

  export type statusReportUncheckedUpdateOneWithoutCodeReportInput = {
    create?: XOR<statusReportCreateWithoutCodeReportInput, statusReportUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: statusReportCreateOrConnectWithoutCodeReportInput
    upsert?: statusReportUpsertWithoutCodeReportInput
    connect?: statusReportWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<statusReportUpdateWithoutCodeReportInput, statusReportUncheckedUpdateWithoutCodeReportInput>
  }

  export type toolUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<toolCreateWithoutCodeReportInput>, Enumerable<toolUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<toolCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<toolUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: toolCreateManyCodeReportInputEnvelope
    connect?: Enumerable<toolWhereUniqueInput>
    set?: Enumerable<toolWhereUniqueInput>
    disconnect?: Enumerable<toolWhereUniqueInput>
    delete?: Enumerable<toolWhereUniqueInput>
    update?: Enumerable<toolUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<toolUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<toolScalarWhereInput>
  }

  export type weatherUncheckedUpdateOneWithoutCodeReportInput = {
    create?: XOR<weatherCreateWithoutCodeReportInput, weatherUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: weatherCreateOrConnectWithoutCodeReportInput
    upsert?: weatherUpsertWithoutCodeReportInput
    connect?: weatherWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<weatherUpdateWithoutCodeReportInput, weatherUncheckedUpdateWithoutCodeReportInput>
  }

  export type materialUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<materialCreateWithoutCodeReportInput>, Enumerable<materialUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<materialCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<materialUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: materialCreateManyCodeReportInputEnvelope
    connect?: Enumerable<materialWhereUniqueInput>
    set?: Enumerable<materialWhereUniqueInput>
    disconnect?: Enumerable<materialWhereUniqueInput>
    delete?: Enumerable<materialWhereUniqueInput>
    update?: Enumerable<materialUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<materialUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<materialScalarWhereInput>
  }

  export type workerUncheckedUpdateManyWithoutCodeReportInput = {
    create?: XOR<Enumerable<workerCreateWithoutCodeReportInput>, Enumerable<workerUncheckedCreateWithoutCodeReportInput>>
    connectOrCreate?: Enumerable<workerCreateOrConnectWithoutCodeReportInput>
    upsert?: Enumerable<workerUpsertWithWhereUniqueWithoutCodeReportInput>
    createMany?: workerCreateManyCodeReportInputEnvelope
    connect?: Enumerable<workerWhereUniqueInput>
    set?: Enumerable<workerWhereUniqueInput>
    disconnect?: Enumerable<workerWhereUniqueInput>
    delete?: Enumerable<workerWhereUniqueInput>
    update?: Enumerable<workerUpdateWithWhereUniqueWithoutCodeReportInput>
    updateMany?: Enumerable<workerUpdateManyWithWhereWithoutCodeReportInput>
    deleteMany?: Enumerable<workerScalarWhereInput>
  }

  export type requestForInformationUncheckedUpdateOneWithoutCodeReportInput = {
    create?: XOR<requestForInformationCreateWithoutCodeReportInput, requestForInformationUncheckedCreateWithoutCodeReportInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutCodeReportInput
    upsert?: requestForInformationUpsertWithoutCodeReportInput
    connect?: requestForInformationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<requestForInformationUpdateWithoutCodeReportInput, requestForInformationUncheckedUpdateWithoutCodeReportInput>
  }

  export type codeReportCreateNestedOneWithoutCodeReportApprovalInput = {
    create?: XOR<codeReportCreateWithoutCodeReportApprovalInput, codeReportUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutCodeReportApprovalInput
    connect?: codeReportWhereUniqueInput
  }

  export type codeReportCreateNestedOneWithoutCodeReportApprovalCommentInput = {
    create?: XOR<codeReportCreateWithoutCodeReportApprovalCommentInput, codeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutCodeReportApprovalCommentInput
    connect?: codeReportWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCodeReportApprovalInput = {
    create?: XOR<userCreateWithoutCodeReportApprovalInput, userUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeReportApprovalInput
    connect?: userWhereUniqueInput
  }

  export type codeReportUpdateOneRequiredWithoutCodeReportApprovalInput = {
    create?: XOR<codeReportCreateWithoutCodeReportApprovalInput, codeReportUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutCodeReportApprovalInput
    upsert?: codeReportUpsertWithoutCodeReportApprovalInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutCodeReportApprovalInput, codeReportUncheckedUpdateWithoutCodeReportApprovalInput>
  }

  export type codeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput = {
    create?: XOR<codeReportCreateWithoutCodeReportApprovalCommentInput, codeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutCodeReportApprovalCommentInput
    upsert?: codeReportUpsertWithoutCodeReportApprovalCommentInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutCodeReportApprovalCommentInput, codeReportUncheckedUpdateWithoutCodeReportApprovalCommentInput>
  }

  export type userUpdateOneRequiredWithoutCodeReportApprovalInput = {
    create?: XOR<userCreateWithoutCodeReportApprovalInput, userUncheckedCreateWithoutCodeReportApprovalInput>
    connectOrCreate?: userCreateOrConnectWithoutCodeReportApprovalInput
    upsert?: userUpsertWithoutCodeReportApprovalInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCodeReportApprovalInput, userUncheckedUpdateWithoutCodeReportApprovalInput>
  }

  export type codeReportCreateNestedOneWithoutDailyReportImageInput = {
    create?: XOR<codeReportCreateWithoutDailyReportImageInput, codeReportUncheckedCreateWithoutDailyReportImageInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutDailyReportImageInput
    connect?: codeReportWhereUniqueInput
  }

  export type codeReportUpdateOneRequiredWithoutDailyReportImageInput = {
    create?: XOR<codeReportCreateWithoutDailyReportImageInput, codeReportUncheckedCreateWithoutDailyReportImageInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutDailyReportImageInput
    upsert?: codeReportUpsertWithoutDailyReportImageInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutDailyReportImageInput, codeReportUncheckedUpdateWithoutDailyReportImageInput>
  }

  export type codeReportCreateNestedOneWithoutDailyTaskInput = {
    create?: XOR<codeReportCreateWithoutDailyTaskInput, codeReportUncheckedCreateWithoutDailyTaskInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutDailyTaskInput
    connect?: codeReportWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type codeReportUpdateOneRequiredWithoutDailyTaskInput = {
    create?: XOR<codeReportCreateWithoutDailyTaskInput, codeReportUncheckedCreateWithoutDailyTaskInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutDailyTaskInput
    upsert?: codeReportUpsertWithoutDailyTaskInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutDailyTaskInput, codeReportUncheckedUpdateWithoutDailyTaskInput>
  }

  export type codeReportCreateNestedOneWithoutMaterialInput = {
    create?: XOR<codeReportCreateWithoutMaterialInput, codeReportUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutMaterialInput
    connect?: codeReportWhereUniqueInput
  }

  export type codeReportUpdateOneRequiredWithoutMaterialInput = {
    create?: XOR<codeReportCreateWithoutMaterialInput, codeReportUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutMaterialInput
    upsert?: codeReportUpsertWithoutMaterialInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutMaterialInput, codeReportUncheckedUpdateWithoutMaterialInput>
  }

  export type codeProjectCreateNestedOneWithoutProjectInput = {
    create?: XOR<codeProjectCreateWithoutProjectInput, codeProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutProjectInput
    connect?: codeProjectWhereUniqueInput
  }

  export type codeProjectUpdateOneRequiredWithoutProjectInput = {
    create?: XOR<codeProjectCreateWithoutProjectInput, codeProjectUncheckedCreateWithoutProjectInput>
    connectOrCreate?: codeProjectCreateOrConnectWithoutProjectInput
    upsert?: codeProjectUpsertWithoutProjectInput
    connect?: codeProjectWhereUniqueInput
    update?: XOR<codeProjectUpdateWithoutProjectInput, codeProjectUncheckedUpdateWithoutProjectInput>
  }

  export type userCreateNestedOneWithoutProjectTaskInput = {
    create?: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: userCreateOrConnectWithoutProjectTaskInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutProjectTaskInput = {
    create?: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
    connectOrCreate?: userCreateOrConnectWithoutProjectTaskInput
    upsert?: userUpsertWithoutProjectTaskInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutProjectTaskInput, userUncheckedUpdateWithoutProjectTaskInput>
  }

  export type codeReportCreateNestedOneWithoutRequestForInformationInput = {
    create?: XOR<codeReportCreateWithoutRequestForInformationInput, codeReportUncheckedCreateWithoutRequestForInformationInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutRequestForInformationInput
    connect?: codeReportWhereUniqueInput
  }

  export type requestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    createMany?: requestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
  }

  export type requestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    createMany?: requestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationDocumentWhereUniqueInput>
  }

  export type requestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    createMany?: requestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
  }

  export type requestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    createMany?: requestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationDocumentWhereUniqueInput>
  }

  export type codeReportUpdateOneRequiredWithoutRequestForInformationInput = {
    create?: XOR<codeReportCreateWithoutRequestForInformationInput, codeReportUncheckedCreateWithoutRequestForInformationInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutRequestForInformationInput
    upsert?: codeReportUpsertWithoutRequestForInformationInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutRequestForInformationInput, codeReportUncheckedUpdateWithoutRequestForInformationInput>
  }

  export type requestForInformationAnswerUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<requestForInformationAnswerUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: requestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<requestForInformationAnswerUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<requestForInformationAnswerUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<requestForInformationAnswerScalarWhereInput>
  }

  export type requestForInformationDocumentUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<requestForInformationDocumentUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: requestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    set?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    disconnect?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    delete?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    update?: Enumerable<requestForInformationDocumentUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<requestForInformationDocumentUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<requestForInformationDocumentScalarWhereInput>
  }

  export type requestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<requestForInformationAnswerUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: requestForInformationAnswerCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<requestForInformationAnswerUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<requestForInformationAnswerUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<requestForInformationAnswerScalarWhereInput>
  }

  export type requestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput = {
    create?: XOR<Enumerable<requestForInformationDocumentCreateWithoutRequestForInformationInput>, Enumerable<requestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>>
    connectOrCreate?: Enumerable<requestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput>
    upsert?: Enumerable<requestForInformationDocumentUpsertWithWhereUniqueWithoutRequestForInformationInput>
    createMany?: requestForInformationDocumentCreateManyRequestForInformationInputEnvelope
    connect?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    set?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    disconnect?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    delete?: Enumerable<requestForInformationDocumentWhereUniqueInput>
    update?: Enumerable<requestForInformationDocumentUpdateWithWhereUniqueWithoutRequestForInformationInput>
    updateMany?: Enumerable<requestForInformationDocumentUpdateManyWithWhereWithoutRequestForInformationInput>
    deleteMany?: Enumerable<requestForInformationDocumentScalarWhereInput>
  }

  export type userCreateNestedOneWithoutRequestForInformationAnswerInput = {
    create?: XOR<userCreateWithoutRequestForInformationAnswerInput, userUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: userCreateOrConnectWithoutRequestForInformationAnswerInput
    connect?: userWhereUniqueInput
  }

  export type requestForInformationCreateNestedOneWithoutRequestForInformationAnswerInput = {
    create?: XOR<requestForInformationCreateWithoutRequestForInformationAnswerInput, requestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutRequestForInformationAnswerInput
    connect?: requestForInformationWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutRequestForInformationAnswerInput = {
    create?: XOR<userCreateWithoutRequestForInformationAnswerInput, userUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: userCreateOrConnectWithoutRequestForInformationAnswerInput
    upsert?: userUpsertWithoutRequestForInformationAnswerInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutRequestForInformationAnswerInput, userUncheckedUpdateWithoutRequestForInformationAnswerInput>
  }

  export type requestForInformationUpdateOneRequiredWithoutRequestForInformationAnswerInput = {
    create?: XOR<requestForInformationCreateWithoutRequestForInformationAnswerInput, requestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutRequestForInformationAnswerInput
    upsert?: requestForInformationUpsertWithoutRequestForInformationAnswerInput
    connect?: requestForInformationWhereUniqueInput
    update?: XOR<requestForInformationUpdateWithoutRequestForInformationAnswerInput, requestForInformationUncheckedUpdateWithoutRequestForInformationAnswerInput>
  }

  export type requestForInformationCreateNestedOneWithoutRequestForInformationDocumentInput = {
    create?: XOR<requestForInformationCreateWithoutRequestForInformationDocumentInput, requestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutRequestForInformationDocumentInput
    connect?: requestForInformationWhereUniqueInput
  }

  export type requestForInformationUpdateOneRequiredWithoutRequestForInformationDocumentInput = {
    create?: XOR<requestForInformationCreateWithoutRequestForInformationDocumentInput, requestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
    connectOrCreate?: requestForInformationCreateOrConnectWithoutRequestForInformationDocumentInput
    upsert?: requestForInformationUpsertWithoutRequestForInformationDocumentInput
    connect?: requestForInformationWhereUniqueInput
    update?: XOR<requestForInformationUpdateWithoutRequestForInformationDocumentInput, requestForInformationUncheckedUpdateWithoutRequestForInformationDocumentInput>
  }

  export type codeReportCreateNestedOneWithoutStatusReportInput = {
    create?: XOR<codeReportCreateWithoutStatusReportInput, codeReportUncheckedCreateWithoutStatusReportInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutStatusReportInput
    connect?: codeReportWhereUniqueInput
  }

  export type statusReportImageCreateNestedManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<statusReportImageCreateWithoutStatusReportInput>, Enumerable<statusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<statusReportImageCreateOrConnectWithoutStatusReportInput>
    createMany?: statusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<statusReportImageWhereUniqueInput>
  }

  export type statusReportImageUncheckedCreateNestedManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<statusReportImageCreateWithoutStatusReportInput>, Enumerable<statusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<statusReportImageCreateOrConnectWithoutStatusReportInput>
    createMany?: statusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<statusReportImageWhereUniqueInput>
  }

  export type codeReportUpdateOneRequiredWithoutStatusReportInput = {
    create?: XOR<codeReportCreateWithoutStatusReportInput, codeReportUncheckedCreateWithoutStatusReportInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutStatusReportInput
    upsert?: codeReportUpsertWithoutStatusReportInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutStatusReportInput, codeReportUncheckedUpdateWithoutStatusReportInput>
  }

  export type statusReportImageUpdateManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<statusReportImageCreateWithoutStatusReportInput>, Enumerable<statusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<statusReportImageCreateOrConnectWithoutStatusReportInput>
    upsert?: Enumerable<statusReportImageUpsertWithWhereUniqueWithoutStatusReportInput>
    createMany?: statusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<statusReportImageWhereUniqueInput>
    set?: Enumerable<statusReportImageWhereUniqueInput>
    disconnect?: Enumerable<statusReportImageWhereUniqueInput>
    delete?: Enumerable<statusReportImageWhereUniqueInput>
    update?: Enumerable<statusReportImageUpdateWithWhereUniqueWithoutStatusReportInput>
    updateMany?: Enumerable<statusReportImageUpdateManyWithWhereWithoutStatusReportInput>
    deleteMany?: Enumerable<statusReportImageScalarWhereInput>
  }

  export type statusReportImageUncheckedUpdateManyWithoutStatusReportInput = {
    create?: XOR<Enumerable<statusReportImageCreateWithoutStatusReportInput>, Enumerable<statusReportImageUncheckedCreateWithoutStatusReportInput>>
    connectOrCreate?: Enumerable<statusReportImageCreateOrConnectWithoutStatusReportInput>
    upsert?: Enumerable<statusReportImageUpsertWithWhereUniqueWithoutStatusReportInput>
    createMany?: statusReportImageCreateManyStatusReportInputEnvelope
    connect?: Enumerable<statusReportImageWhereUniqueInput>
    set?: Enumerable<statusReportImageWhereUniqueInput>
    disconnect?: Enumerable<statusReportImageWhereUniqueInput>
    delete?: Enumerable<statusReportImageWhereUniqueInput>
    update?: Enumerable<statusReportImageUpdateWithWhereUniqueWithoutStatusReportInput>
    updateMany?: Enumerable<statusReportImageUpdateManyWithWhereWithoutStatusReportInput>
    deleteMany?: Enumerable<statusReportImageScalarWhereInput>
  }

  export type statusReportCreateNestedOneWithoutStatusReportImageInput = {
    create?: XOR<statusReportCreateWithoutStatusReportImageInput, statusReportUncheckedCreateWithoutStatusReportImageInput>
    connectOrCreate?: statusReportCreateOrConnectWithoutStatusReportImageInput
    connect?: statusReportWhereUniqueInput
  }

  export type statusReportUpdateOneRequiredWithoutStatusReportImageInput = {
    create?: XOR<statusReportCreateWithoutStatusReportImageInput, statusReportUncheckedCreateWithoutStatusReportImageInput>
    connectOrCreate?: statusReportCreateOrConnectWithoutStatusReportImageInput
    upsert?: statusReportUpsertWithoutStatusReportImageInput
    connect?: statusReportWhereUniqueInput
    update?: XOR<statusReportUpdateWithoutStatusReportImageInput, statusReportUncheckedUpdateWithoutStatusReportImageInput>
  }

  export type codeReportCreateNestedOneWithoutToolInput = {
    create?: XOR<codeReportCreateWithoutToolInput, codeReportUncheckedCreateWithoutToolInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutToolInput
    connect?: codeReportWhereUniqueInput
  }

  export type codeReportUpdateOneRequiredWithoutToolInput = {
    create?: XOR<codeReportCreateWithoutToolInput, codeReportUncheckedCreateWithoutToolInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutToolInput
    upsert?: codeReportUpsertWithoutToolInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutToolInput, codeReportUncheckedUpdateWithoutToolInput>
  }

  export type codeReportCreateNestedOneWithoutWeatherInput = {
    create?: XOR<codeReportCreateWithoutWeatherInput, codeReportUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutWeatherInput
    connect?: codeReportWhereUniqueInput
  }

  export type codeReportUpdateOneRequiredWithoutWeatherInput = {
    create?: XOR<codeReportCreateWithoutWeatherInput, codeReportUncheckedCreateWithoutWeatherInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutWeatherInput
    upsert?: codeReportUpsertWithoutWeatherInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutWeatherInput, codeReportUncheckedUpdateWithoutWeatherInput>
  }

  export type codeReportCreateNestedOneWithoutWorkerInput = {
    create?: XOR<codeReportCreateWithoutWorkerInput, codeReportUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutWorkerInput
    connect?: codeReportWhereUniqueInput
  }

  export type codeReportUpdateOneRequiredWithoutWorkerInput = {
    create?: XOR<codeReportCreateWithoutWorkerInput, codeReportUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: codeReportCreateOrConnectWithoutWorkerInput
    upsert?: codeReportUpsertWithoutWorkerInput
    connect?: codeReportWhereUniqueInput
    update?: XOR<codeReportUpdateWithoutWorkerInput, codeReportUncheckedUpdateWithoutWorkerInput>
  }

  export type userCreateNestedOneWithoutUserContactInput = {
    create?: XOR<userCreateWithoutUserContactInput, userUncheckedCreateWithoutUserContactInput>
    connectOrCreate?: userCreateOrConnectWithoutUserContactInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserContactInput = {
    create?: XOR<userCreateWithoutUserContactInput, userUncheckedCreateWithoutUserContactInput>
    connectOrCreate?: userCreateOrConnectWithoutUserContactInput
    upsert?: userUpsertWithoutUserContactInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUserContactInput, userUncheckedUpdateWithoutUserContactInput>
  }

  export type userCreateNestedOneWithoutCreateUserPositionInput = {
    create?: XOR<userCreateWithoutCreateUserPositionInput, userUncheckedCreateWithoutCreateUserPositionInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateUserPositionInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserPositionInput = {
    create?: XOR<userCreateWithoutUserPositionInput, userUncheckedCreateWithoutUserPositionInput>
    connectOrCreate?: userCreateOrConnectWithoutUserPositionInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCreateUserPositionInput = {
    create?: XOR<userCreateWithoutCreateUserPositionInput, userUncheckedCreateWithoutCreateUserPositionInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateUserPositionInput
    upsert?: userUpsertWithoutCreateUserPositionInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCreateUserPositionInput, userUncheckedUpdateWithoutCreateUserPositionInput>
  }

  export type userUpdateOneRequiredWithoutUserPositionInput = {
    create?: XOR<userCreateWithoutUserPositionInput, userUncheckedCreateWithoutUserPositionInput>
    connectOrCreate?: userCreateOrConnectWithoutUserPositionInput
    upsert?: userUpsertWithoutUserPositionInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUserPositionInput, userUncheckedUpdateWithoutUserPositionInput>
  }

  export type clientCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<clientCreateWithoutUserInput>, Enumerable<clientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutUserInput>
    createMany?: clientCreateManyUserInputEnvelope
    connect?: Enumerable<clientWhereUniqueInput>
  }

  export type clientContactCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutUserInput>, Enumerable<clientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutUserInput>
    createMany?: clientContactCreateManyUserInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
  }

  export type codeProjectDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutUserInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutUserInput>
    createMany?: codeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
  }

  export type codeProjectCreateNestedManyWithoutUser1Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser1Input>, Enumerable<codeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser1Input>
    createMany?: codeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type codeProjectCreateNestedManyWithoutUser2Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser2Input>, Enumerable<codeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser2Input>
    createMany?: codeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type codeProjectCreateNestedManyWithoutUser3Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser3Input>, Enumerable<codeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser3Input>
    createMany?: codeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type codeProjectUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutUserInput>, Enumerable<codeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutUserInput>
    createMany?: codeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
  }

  export type codeReportCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutUserInput>, Enumerable<codeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutUserInput>
    createMany?: codeReportCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
  }

  export type codeReportApprovalCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutUserInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutUserInput>
    createMany?: codeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
  }

  export type projectTaskCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<projectTaskCreateWithoutUserInput>, Enumerable<projectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<projectTaskCreateOrConnectWithoutUserInput>
    createMany?: projectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<projectTaskWhereUniqueInput>
  }

  export type requestForInformationAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutUserInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutUserInput>
    createMany?: requestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
  }

  export type userPositionCreateNestedManyWithoutUser4Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser4Input>, Enumerable<userPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser4Input>
    createMany?: userPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
  }

  export type userPositionCreateNestedManyWithoutUser5Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser5Input>, Enumerable<userPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser5Input>
    createMany?: userPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
  }

  export type userContactCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userContactCreateWithoutUserInput>, Enumerable<userContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userContactCreateOrConnectWithoutUserInput>
    createMany?: userContactCreateManyUserInputEnvelope
    connect?: Enumerable<userContactWhereUniqueInput>
  }

  export type userTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userTokenCreateWithoutUserInput>, Enumerable<userTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokenCreateOrConnectWithoutUserInput>
    createMany?: userTokenCreateManyUserInputEnvelope
    connect?: Enumerable<userTokenWhereUniqueInput>
  }

  export type clientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<clientCreateWithoutUserInput>, Enumerable<clientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutUserInput>
    createMany?: clientCreateManyUserInputEnvelope
    connect?: Enumerable<clientWhereUniqueInput>
  }

  export type clientContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutUserInput>, Enumerable<clientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutUserInput>
    createMany?: clientContactCreateManyUserInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
  }

  export type codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutUserInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutUserInput>
    createMany?: codeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
  }

  export type codeProjectUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser1Input>, Enumerable<codeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser1Input>
    createMany?: codeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type codeProjectUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser2Input>, Enumerable<codeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser2Input>
    createMany?: codeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type codeProjectUncheckedCreateNestedManyWithoutUser3Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser3Input>, Enumerable<codeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser3Input>
    createMany?: codeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
  }

  export type codeProjectUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutUserInput>, Enumerable<codeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutUserInput>
    createMany?: codeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
  }

  export type codeReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutUserInput>, Enumerable<codeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutUserInput>
    createMany?: codeReportCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
  }

  export type codeReportApprovalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutUserInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutUserInput>
    createMany?: codeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
  }

  export type projectTaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<projectTaskCreateWithoutUserInput>, Enumerable<projectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<projectTaskCreateOrConnectWithoutUserInput>
    createMany?: projectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<projectTaskWhereUniqueInput>
  }

  export type requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutUserInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutUserInput>
    createMany?: requestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
  }

  export type userPositionUncheckedCreateNestedManyWithoutUser4Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser4Input>, Enumerable<userPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser4Input>
    createMany?: userPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
  }

  export type userPositionUncheckedCreateNestedManyWithoutUser5Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser5Input>, Enumerable<userPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser5Input>
    createMany?: userPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
  }

  export type userContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userContactCreateWithoutUserInput>, Enumerable<userContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userContactCreateOrConnectWithoutUserInput>
    createMany?: userContactCreateManyUserInputEnvelope
    connect?: Enumerable<userContactWhereUniqueInput>
  }

  export type userTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userTokenCreateWithoutUserInput>, Enumerable<userTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokenCreateOrConnectWithoutUserInput>
    createMany?: userTokenCreateManyUserInputEnvelope
    connect?: Enumerable<userTokenWhereUniqueInput>
  }

  export type clientUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<clientCreateWithoutUserInput>, Enumerable<clientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<clientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: clientCreateManyUserInputEnvelope
    connect?: Enumerable<clientWhereUniqueInput>
    set?: Enumerable<clientWhereUniqueInput>
    disconnect?: Enumerable<clientWhereUniqueInput>
    delete?: Enumerable<clientWhereUniqueInput>
    update?: Enumerable<clientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<clientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<clientScalarWhereInput>
  }

  export type clientContactUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutUserInput>, Enumerable<clientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<clientContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: clientContactCreateManyUserInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
    set?: Enumerable<clientContactWhereUniqueInput>
    disconnect?: Enumerable<clientContactWhereUniqueInput>
    delete?: Enumerable<clientContactWhereUniqueInput>
    update?: Enumerable<clientContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<clientContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<clientContactScalarWhereInput>
  }

  export type codeProjectDocumentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutUserInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeProjectDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    set?: Enumerable<codeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<codeProjectDocumentWhereUniqueInput>
    update?: Enumerable<codeProjectDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeProjectDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeProjectDocumentScalarWhereInput>
  }

  export type codeProjectUpdateManyWithoutUser1Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser1Input>, Enumerable<codeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser1Input>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutUser1Input>
    createMany?: codeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutUser1Input>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutUser1Input>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type codeProjectUpdateManyWithoutUser2Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser2Input>, Enumerable<codeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser2Input>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutUser2Input>
    createMany?: codeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutUser2Input>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutUser2Input>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type codeProjectUpdateManyWithoutUser3Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser3Input>, Enumerable<codeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser3Input>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutUser3Input>
    createMany?: codeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutUser3Input>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutUser3Input>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type codeProjectUserUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutUserInput>, Enumerable<codeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeProjectUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
    set?: Enumerable<codeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<codeProjectUserWhereUniqueInput>
    delete?: Enumerable<codeProjectUserWhereUniqueInput>
    update?: Enumerable<codeProjectUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeProjectUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeProjectUserScalarWhereInput>
  }

  export type codeReportUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutUserInput>, Enumerable<codeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeReportCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
    set?: Enumerable<codeReportWhereUniqueInput>
    disconnect?: Enumerable<codeReportWhereUniqueInput>
    delete?: Enumerable<codeReportWhereUniqueInput>
    update?: Enumerable<codeReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeReportScalarWhereInput>
  }

  export type codeReportApprovalUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutUserInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeReportApprovalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
    set?: Enumerable<codeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<codeReportApprovalWhereUniqueInput>
    delete?: Enumerable<codeReportApprovalWhereUniqueInput>
    update?: Enumerable<codeReportApprovalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeReportApprovalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeReportApprovalScalarWhereInput>
  }

  export type projectTaskUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<projectTaskCreateWithoutUserInput>, Enumerable<projectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<projectTaskCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<projectTaskUpsertWithWhereUniqueWithoutUserInput>
    createMany?: projectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<projectTaskWhereUniqueInput>
    set?: Enumerable<projectTaskWhereUniqueInput>
    disconnect?: Enumerable<projectTaskWhereUniqueInput>
    delete?: Enumerable<projectTaskWhereUniqueInput>
    update?: Enumerable<projectTaskUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<projectTaskUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<projectTaskScalarWhereInput>
  }

  export type requestForInformationAnswerUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutUserInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<requestForInformationAnswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: requestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<requestForInformationAnswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<requestForInformationAnswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<requestForInformationAnswerScalarWhereInput>
  }

  export type userPositionUpdateManyWithoutUser4Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser4Input>, Enumerable<userPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser4Input>
    upsert?: Enumerable<userPositionUpsertWithWhereUniqueWithoutUser4Input>
    createMany?: userPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
    set?: Enumerable<userPositionWhereUniqueInput>
    disconnect?: Enumerable<userPositionWhereUniqueInput>
    delete?: Enumerable<userPositionWhereUniqueInput>
    update?: Enumerable<userPositionUpdateWithWhereUniqueWithoutUser4Input>
    updateMany?: Enumerable<userPositionUpdateManyWithWhereWithoutUser4Input>
    deleteMany?: Enumerable<userPositionScalarWhereInput>
  }

  export type userPositionUpdateManyWithoutUser5Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser5Input>, Enumerable<userPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser5Input>
    upsert?: Enumerable<userPositionUpsertWithWhereUniqueWithoutUser5Input>
    createMany?: userPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
    set?: Enumerable<userPositionWhereUniqueInput>
    disconnect?: Enumerable<userPositionWhereUniqueInput>
    delete?: Enumerable<userPositionWhereUniqueInput>
    update?: Enumerable<userPositionUpdateWithWhereUniqueWithoutUser5Input>
    updateMany?: Enumerable<userPositionUpdateManyWithWhereWithoutUser5Input>
    deleteMany?: Enumerable<userPositionScalarWhereInput>
  }

  export type userContactUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<userContactCreateWithoutUserInput>, Enumerable<userContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userContactCreateManyUserInputEnvelope
    connect?: Enumerable<userContactWhereUniqueInput>
    set?: Enumerable<userContactWhereUniqueInput>
    disconnect?: Enumerable<userContactWhereUniqueInput>
    delete?: Enumerable<userContactWhereUniqueInput>
    update?: Enumerable<userContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userContactScalarWhereInput>
  }

  export type userTokenUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<userTokenCreateWithoutUserInput>, Enumerable<userTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userTokenCreateManyUserInputEnvelope
    connect?: Enumerable<userTokenWhereUniqueInput>
    set?: Enumerable<userTokenWhereUniqueInput>
    disconnect?: Enumerable<userTokenWhereUniqueInput>
    delete?: Enumerable<userTokenWhereUniqueInput>
    update?: Enumerable<userTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userTokenScalarWhereInput>
  }

  export type clientUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<clientCreateWithoutUserInput>, Enumerable<clientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<clientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: clientCreateManyUserInputEnvelope
    connect?: Enumerable<clientWhereUniqueInput>
    set?: Enumerable<clientWhereUniqueInput>
    disconnect?: Enumerable<clientWhereUniqueInput>
    delete?: Enumerable<clientWhereUniqueInput>
    update?: Enumerable<clientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<clientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<clientScalarWhereInput>
  }

  export type clientContactUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<clientContactCreateWithoutUserInput>, Enumerable<clientContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<clientContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<clientContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: clientContactCreateManyUserInputEnvelope
    connect?: Enumerable<clientContactWhereUniqueInput>
    set?: Enumerable<clientContactWhereUniqueInput>
    disconnect?: Enumerable<clientContactWhereUniqueInput>
    delete?: Enumerable<clientContactWhereUniqueInput>
    update?: Enumerable<clientContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<clientContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<clientContactScalarWhereInput>
  }

  export type codeProjectDocumentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectDocumentCreateWithoutUserInput>, Enumerable<codeProjectDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeProjectDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeProjectDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    set?: Enumerable<codeProjectDocumentWhereUniqueInput>
    disconnect?: Enumerable<codeProjectDocumentWhereUniqueInput>
    delete?: Enumerable<codeProjectDocumentWhereUniqueInput>
    update?: Enumerable<codeProjectDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeProjectDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeProjectDocumentScalarWhereInput>
  }

  export type codeProjectUncheckedUpdateManyWithoutUser1Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser1Input>, Enumerable<codeProjectUncheckedCreateWithoutUser1Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser1Input>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutUser1Input>
    createMany?: codeProjectCreateManyUser1InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutUser1Input>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutUser1Input>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type codeProjectUncheckedUpdateManyWithoutUser2Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser2Input>, Enumerable<codeProjectUncheckedCreateWithoutUser2Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser2Input>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutUser2Input>
    createMany?: codeProjectCreateManyUser2InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutUser2Input>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutUser2Input>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type codeProjectUncheckedUpdateManyWithoutUser3Input = {
    create?: XOR<Enumerable<codeProjectCreateWithoutUser3Input>, Enumerable<codeProjectUncheckedCreateWithoutUser3Input>>
    connectOrCreate?: Enumerable<codeProjectCreateOrConnectWithoutUser3Input>
    upsert?: Enumerable<codeProjectUpsertWithWhereUniqueWithoutUser3Input>
    createMany?: codeProjectCreateManyUser3InputEnvelope
    connect?: Enumerable<codeProjectWhereUniqueInput>
    set?: Enumerable<codeProjectWhereUniqueInput>
    disconnect?: Enumerable<codeProjectWhereUniqueInput>
    delete?: Enumerable<codeProjectWhereUniqueInput>
    update?: Enumerable<codeProjectUpdateWithWhereUniqueWithoutUser3Input>
    updateMany?: Enumerable<codeProjectUpdateManyWithWhereWithoutUser3Input>
    deleteMany?: Enumerable<codeProjectScalarWhereInput>
  }

  export type codeProjectUserUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeProjectUserCreateWithoutUserInput>, Enumerable<codeProjectUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeProjectUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeProjectUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeProjectUserCreateManyUserInputEnvelope
    connect?: Enumerable<codeProjectUserWhereUniqueInput>
    set?: Enumerable<codeProjectUserWhereUniqueInput>
    disconnect?: Enumerable<codeProjectUserWhereUniqueInput>
    delete?: Enumerable<codeProjectUserWhereUniqueInput>
    update?: Enumerable<codeProjectUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeProjectUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeProjectUserScalarWhereInput>
  }

  export type codeReportUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportCreateWithoutUserInput>, Enumerable<codeReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeReportCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportWhereUniqueInput>
    set?: Enumerable<codeReportWhereUniqueInput>
    disconnect?: Enumerable<codeReportWhereUniqueInput>
    delete?: Enumerable<codeReportWhereUniqueInput>
    update?: Enumerable<codeReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeReportScalarWhereInput>
  }

  export type codeReportApprovalUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<codeReportApprovalCreateWithoutUserInput>, Enumerable<codeReportApprovalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<codeReportApprovalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<codeReportApprovalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: codeReportApprovalCreateManyUserInputEnvelope
    connect?: Enumerable<codeReportApprovalWhereUniqueInput>
    set?: Enumerable<codeReportApprovalWhereUniqueInput>
    disconnect?: Enumerable<codeReportApprovalWhereUniqueInput>
    delete?: Enumerable<codeReportApprovalWhereUniqueInput>
    update?: Enumerable<codeReportApprovalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<codeReportApprovalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<codeReportApprovalScalarWhereInput>
  }

  export type projectTaskUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<projectTaskCreateWithoutUserInput>, Enumerable<projectTaskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<projectTaskCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<projectTaskUpsertWithWhereUniqueWithoutUserInput>
    createMany?: projectTaskCreateManyUserInputEnvelope
    connect?: Enumerable<projectTaskWhereUniqueInput>
    set?: Enumerable<projectTaskWhereUniqueInput>
    disconnect?: Enumerable<projectTaskWhereUniqueInput>
    delete?: Enumerable<projectTaskWhereUniqueInput>
    update?: Enumerable<projectTaskUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<projectTaskUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<projectTaskScalarWhereInput>
  }

  export type requestForInformationAnswerUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<requestForInformationAnswerCreateWithoutUserInput>, Enumerable<requestForInformationAnswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestForInformationAnswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<requestForInformationAnswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: requestForInformationAnswerCreateManyUserInputEnvelope
    connect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    set?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    disconnect?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    delete?: Enumerable<requestForInformationAnswerWhereUniqueInput>
    update?: Enumerable<requestForInformationAnswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<requestForInformationAnswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<requestForInformationAnswerScalarWhereInput>
  }

  export type userPositionUncheckedUpdateManyWithoutUser4Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser4Input>, Enumerable<userPositionUncheckedCreateWithoutUser4Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser4Input>
    upsert?: Enumerable<userPositionUpsertWithWhereUniqueWithoutUser4Input>
    createMany?: userPositionCreateManyUser4InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
    set?: Enumerable<userPositionWhereUniqueInput>
    disconnect?: Enumerable<userPositionWhereUniqueInput>
    delete?: Enumerable<userPositionWhereUniqueInput>
    update?: Enumerable<userPositionUpdateWithWhereUniqueWithoutUser4Input>
    updateMany?: Enumerable<userPositionUpdateManyWithWhereWithoutUser4Input>
    deleteMany?: Enumerable<userPositionScalarWhereInput>
  }

  export type userPositionUncheckedUpdateManyWithoutUser5Input = {
    create?: XOR<Enumerable<userPositionCreateWithoutUser5Input>, Enumerable<userPositionUncheckedCreateWithoutUser5Input>>
    connectOrCreate?: Enumerable<userPositionCreateOrConnectWithoutUser5Input>
    upsert?: Enumerable<userPositionUpsertWithWhereUniqueWithoutUser5Input>
    createMany?: userPositionCreateManyUser5InputEnvelope
    connect?: Enumerable<userPositionWhereUniqueInput>
    set?: Enumerable<userPositionWhereUniqueInput>
    disconnect?: Enumerable<userPositionWhereUniqueInput>
    delete?: Enumerable<userPositionWhereUniqueInput>
    update?: Enumerable<userPositionUpdateWithWhereUniqueWithoutUser5Input>
    updateMany?: Enumerable<userPositionUpdateManyWithWhereWithoutUser5Input>
    deleteMany?: Enumerable<userPositionScalarWhereInput>
  }

  export type userContactUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<userContactCreateWithoutUserInput>, Enumerable<userContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userContactCreateManyUserInputEnvelope
    connect?: Enumerable<userContactWhereUniqueInput>
    set?: Enumerable<userContactWhereUniqueInput>
    disconnect?: Enumerable<userContactWhereUniqueInput>
    delete?: Enumerable<userContactWhereUniqueInput>
    update?: Enumerable<userContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userContactScalarWhereInput>
  }

  export type userTokenUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<userTokenCreateWithoutUserInput>, Enumerable<userTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userTokenCreateManyUserInputEnvelope
    connect?: Enumerable<userTokenWhereUniqueInput>
    set?: Enumerable<userTokenWhereUniqueInput>
    disconnect?: Enumerable<userTokenWhereUniqueInput>
    delete?: Enumerable<userTokenWhereUniqueInput>
    update?: Enumerable<userTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userTokenScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type userCreateWithoutClientInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutClientInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutClientInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
  }

  export type clientContactCreateWithoutClientInput = {
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    User: userCreateNestedOneWithoutClientContactInput
  }

  export type clientContactUncheckedCreateWithoutClientInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type clientContactCreateOrConnectWithoutClientInput = {
    where: clientContactWhereUniqueInput
    create: XOR<clientContactCreateWithoutClientInput, clientContactUncheckedCreateWithoutClientInput>
  }

  export type clientContactCreateManyClientInputEnvelope = {
    data: Enumerable<clientContactCreateManyClientInput>
    skipDuplicates?: boolean
  }

  export type codeProjectCreateWithoutClientInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutClientInput = {
    Id?: number
    Name: string
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutClientInput = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutClientInput, codeProjectUncheckedCreateWithoutClientInput>
  }

  export type codeProjectCreateManyClientInputEnvelope = {
    data: Enumerable<codeProjectCreateManyClientInput>
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutClientInput = {
    update: XOR<userUpdateWithoutClientInput, userUncheckedUpdateWithoutClientInput>
    create: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
  }

  export type userUpdateWithoutClientInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type clientContactUpsertWithWhereUniqueWithoutClientInput = {
    where: clientContactWhereUniqueInput
    update: XOR<clientContactUpdateWithoutClientInput, clientContactUncheckedUpdateWithoutClientInput>
    create: XOR<clientContactCreateWithoutClientInput, clientContactUncheckedCreateWithoutClientInput>
  }

  export type clientContactUpdateWithWhereUniqueWithoutClientInput = {
    where: clientContactWhereUniqueInput
    data: XOR<clientContactUpdateWithoutClientInput, clientContactUncheckedUpdateWithoutClientInput>
  }

  export type clientContactUpdateManyWithWhereWithoutClientInput = {
    where: clientContactScalarWhereInput
    data: XOR<clientContactUpdateManyMutationInput, clientContactUncheckedUpdateManyWithoutContactInput>
  }

  export type clientContactScalarWhereInput = {
    AND?: Enumerable<clientContactScalarWhereInput>
    OR?: Enumerable<clientContactScalarWhereInput>
    NOT?: Enumerable<clientContactScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Position?: StringFilter | string
    PhoneNumber?: StringFilter | string
    Email?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    ClientId?: IntFilter | number
  }

  export type codeProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: codeProjectWhereUniqueInput
    update: XOR<codeProjectUpdateWithoutClientInput, codeProjectUncheckedUpdateWithoutClientInput>
    create: XOR<codeProjectCreateWithoutClientInput, codeProjectUncheckedCreateWithoutClientInput>
  }

  export type codeProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: codeProjectWhereUniqueInput
    data: XOR<codeProjectUpdateWithoutClientInput, codeProjectUncheckedUpdateWithoutClientInput>
  }

  export type codeProjectUpdateManyWithWhereWithoutClientInput = {
    where: codeProjectScalarWhereInput
    data: XOR<codeProjectUpdateManyMutationInput, codeProjectUncheckedUpdateManyWithoutCodeProjectInput>
  }

  export type codeProjectScalarWhereInput = {
    AND?: Enumerable<codeProjectScalarWhereInput>
    OR?: Enumerable<codeProjectScalarWhereInput>
    NOT?: Enumerable<codeProjectScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    ClientId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    ConfirmedDate?: DateTimeNullableFilter | Date | string | null
    ConfirmedBy?: IntNullableFilter | number | null
    Address?: StringFilter | string
    DocumentName?: StringFilter | string
    IsCompleted?: BoolFilter | boolean
    CompletedDate?: DateTimeNullableFilter | Date | string | null
    CompletedBy?: IntNullableFilter | number | null
    IsDelete?: BoolFilter | boolean
  }

  export type userCreateWithoutTokenInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTokenInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTokenInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTokenInput, userUncheckedCreateWithoutTokenInput>
  }

  export type userUpsertWithoutTokenInput = {
    update: XOR<userUpdateWithoutTokenInput, userUncheckedUpdateWithoutTokenInput>
    create: XOR<userCreateWithoutTokenInput, userUncheckedCreateWithoutTokenInput>
  }

  export type userUpdateWithoutTokenInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutTokenInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
  }

  export type clientCreateWithoutContactInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    User: userCreateNestedOneWithoutClientInput
    CodeProject?: codeProjectCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutContactInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
    CodeProject?: codeProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutContactInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutContactInput, clientUncheckedCreateWithoutContactInput>
  }

  export type userCreateWithoutClientContactInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutClientContactInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutClientContactInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutClientContactInput, userUncheckedCreateWithoutClientContactInput>
  }

  export type clientUpsertWithoutContactInput = {
    update: XOR<clientUpdateWithoutContactInput, clientUncheckedUpdateWithoutContactInput>
    create: XOR<clientCreateWithoutContactInput, clientUncheckedCreateWithoutContactInput>
  }

  export type clientUpdateWithoutContactInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: userUpdateOneRequiredWithoutClientInput
    CodeProject?: codeProjectUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateWithoutContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProject?: codeProjectUncheckedUpdateManyWithoutClientInput
  }

  export type userUpsertWithoutClientContactInput = {
    update: XOR<userUpdateWithoutClientContactInput, userUncheckedUpdateWithoutClientContactInput>
    create: XOR<userCreateWithoutClientContactInput, userUncheckedCreateWithoutClientContactInput>
  }

  export type userUpdateWithoutClientContactInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutClientContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type clientCreateWithoutCodeProjectInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    User: userCreateNestedOneWithoutClientInput
    Contact?: clientContactCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedBy: number
    CreatedDate?: Date | string
    Contact?: clientContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutCodeProjectInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutCodeProjectInput, clientUncheckedCreateWithoutCodeProjectInput>
  }

  export type userCreateWithoutCreateCodeProjectInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreateCodeProjectInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreateCodeProjectInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreateCodeProjectInput, userUncheckedCreateWithoutCreateCodeProjectInput>
  }

  export type userCreateWithoutConfirmedCodeProjectInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutConfirmedCodeProjectInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutConfirmedCodeProjectInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutConfirmedCodeProjectInput, userUncheckedCreateWithoutConfirmedCodeProjectInput>
  }

  export type userCreateWithoutCompletedCodeProjectInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCompletedCodeProjectInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCompletedCodeProjectInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCompletedCodeProjectInput, userUncheckedCreateWithoutCompletedCodeProjectInput>
  }

  export type codeProjectDocumentCreateWithoutCodeProjectInput = {
    Name: string
    Url: string
    CreatedDate?: Date | string
    User: userCreateNestedOneWithoutCodeProjectDocumentInput
  }

  export type codeProjectDocumentUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    Name: string
    Url: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type codeProjectDocumentCreateOrConnectWithoutCodeProjectInput = {
    where: codeProjectDocumentWhereUniqueInput
    create: XOR<codeProjectDocumentCreateWithoutCodeProjectInput, codeProjectDocumentUncheckedCreateWithoutCodeProjectInput>
  }

  export type codeProjectDocumentCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<codeProjectDocumentCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type codeProjectUserCreateWithoutCodeProjectInput = {
    User: userCreateNestedOneWithoutCodeProjectUserInput
  }

  export type codeProjectUserUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    UserId: number
  }

  export type codeProjectUserCreateOrConnectWithoutCodeProjectInput = {
    where: codeProjectUserWhereUniqueInput
    create: XOR<codeProjectUserCreateWithoutCodeProjectInput, codeProjectUserUncheckedCreateWithoutCodeProjectInput>
  }

  export type codeProjectUserCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<codeProjectUserCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type codeReportCreateWithoutCodeProjectInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutCodeProjectInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutCodeProjectInput, codeReportUncheckedCreateWithoutCodeProjectInput>
  }

  export type codeReportCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<codeReportCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type projectCreateWithoutCodeProjectInput = {
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type projectUncheckedCreateWithoutCodeProjectInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type projectCreateOrConnectWithoutCodeProjectInput = {
    where: projectWhereUniqueInput
    create: XOR<projectCreateWithoutCodeProjectInput, projectUncheckedCreateWithoutCodeProjectInput>
  }

  export type projectCreateManyCodeProjectInputEnvelope = {
    data: Enumerable<projectCreateManyCodeProjectInput>
    skipDuplicates?: boolean
  }

  export type clientUpsertWithoutCodeProjectInput = {
    update: XOR<clientUpdateWithoutCodeProjectInput, clientUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<clientCreateWithoutCodeProjectInput, clientUncheckedCreateWithoutCodeProjectInput>
  }

  export type clientUpdateWithoutCodeProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: userUpdateOneRequiredWithoutClientInput
    Contact?: clientContactUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: clientContactUncheckedUpdateManyWithoutClientInput
  }

  export type userUpsertWithoutCreateCodeProjectInput = {
    update: XOR<userUpdateWithoutCreateCodeProjectInput, userUncheckedUpdateWithoutCreateCodeProjectInput>
    create: XOR<userCreateWithoutCreateCodeProjectInput, userUncheckedCreateWithoutCreateCodeProjectInput>
  }

  export type userUpdateWithoutCreateCodeProjectInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutCreateCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutConfirmedCodeProjectInput = {
    update: XOR<userUpdateWithoutConfirmedCodeProjectInput, userUncheckedUpdateWithoutConfirmedCodeProjectInput>
    create: XOR<userCreateWithoutConfirmedCodeProjectInput, userUncheckedCreateWithoutConfirmedCodeProjectInput>
  }

  export type userUpdateWithoutConfirmedCodeProjectInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutConfirmedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutCompletedCodeProjectInput = {
    update: XOR<userUpdateWithoutCompletedCodeProjectInput, userUncheckedUpdateWithoutCompletedCodeProjectInput>
    create: XOR<userCreateWithoutCompletedCodeProjectInput, userUncheckedCreateWithoutCompletedCodeProjectInput>
  }

  export type userUpdateWithoutCompletedCodeProjectInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutCompletedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type codeProjectDocumentUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: codeProjectDocumentWhereUniqueInput
    update: XOR<codeProjectDocumentUpdateWithoutCodeProjectInput, codeProjectDocumentUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<codeProjectDocumentCreateWithoutCodeProjectInput, codeProjectDocumentUncheckedCreateWithoutCodeProjectInput>
  }

  export type codeProjectDocumentUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: codeProjectDocumentWhereUniqueInput
    data: XOR<codeProjectDocumentUpdateWithoutCodeProjectInput, codeProjectDocumentUncheckedUpdateWithoutCodeProjectInput>
  }

  export type codeProjectDocumentUpdateManyWithWhereWithoutCodeProjectInput = {
    where: codeProjectDocumentScalarWhereInput
    data: XOR<codeProjectDocumentUpdateManyMutationInput, codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectDocumentInput>
  }

  export type codeProjectDocumentScalarWhereInput = {
    AND?: Enumerable<codeProjectDocumentScalarWhereInput>
    OR?: Enumerable<codeProjectDocumentScalarWhereInput>
    NOT?: Enumerable<codeProjectDocumentScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Url?: StringFilter | string
    CodeProjectId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
  }

  export type codeProjectUserUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: codeProjectUserWhereUniqueInput
    update: XOR<codeProjectUserUpdateWithoutCodeProjectInput, codeProjectUserUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<codeProjectUserCreateWithoutCodeProjectInput, codeProjectUserUncheckedCreateWithoutCodeProjectInput>
  }

  export type codeProjectUserUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: codeProjectUserWhereUniqueInput
    data: XOR<codeProjectUserUpdateWithoutCodeProjectInput, codeProjectUserUncheckedUpdateWithoutCodeProjectInput>
  }

  export type codeProjectUserUpdateManyWithWhereWithoutCodeProjectInput = {
    where: codeProjectUserScalarWhereInput
    data: XOR<codeProjectUserUpdateManyMutationInput, codeProjectUserUncheckedUpdateManyWithoutCodeProjectUserInput>
  }

  export type codeProjectUserScalarWhereInput = {
    AND?: Enumerable<codeProjectUserScalarWhereInput>
    OR?: Enumerable<codeProjectUserScalarWhereInput>
    NOT?: Enumerable<codeProjectUserScalarWhereInput>
    Id?: IntFilter | number
    UserId?: IntFilter | number
    CodeProjectId?: IntFilter | number
  }

  export type codeReportUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: codeReportWhereUniqueInput
    update: XOR<codeReportUpdateWithoutCodeProjectInput, codeReportUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<codeReportCreateWithoutCodeProjectInput, codeReportUncheckedCreateWithoutCodeProjectInput>
  }

  export type codeReportUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: codeReportWhereUniqueInput
    data: XOR<codeReportUpdateWithoutCodeProjectInput, codeReportUncheckedUpdateWithoutCodeProjectInput>
  }

  export type codeReportUpdateManyWithWhereWithoutCodeProjectInput = {
    where: codeReportScalarWhereInput
    data: XOR<codeReportUpdateManyMutationInput, codeReportUncheckedUpdateManyWithoutCodeReportInput>
  }

  export type codeReportScalarWhereInput = {
    AND?: Enumerable<codeReportScalarWhereInput>
    OR?: Enumerable<codeReportScalarWhereInput>
    NOT?: Enumerable<codeReportScalarWhereInput>
    Id?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Date?: DateTimeFilter | Date | string
    CodeProjectId?: IntFilter | number
    Type?: IntFilter | number
    IsDelete?: BoolFilter | boolean
    Note?: StringFilter | string
  }

  export type projectUpsertWithWhereUniqueWithoutCodeProjectInput = {
    where: projectWhereUniqueInput
    update: XOR<projectUpdateWithoutCodeProjectInput, projectUncheckedUpdateWithoutCodeProjectInput>
    create: XOR<projectCreateWithoutCodeProjectInput, projectUncheckedCreateWithoutCodeProjectInput>
  }

  export type projectUpdateWithWhereUniqueWithoutCodeProjectInput = {
    where: projectWhereUniqueInput
    data: XOR<projectUpdateWithoutCodeProjectInput, projectUncheckedUpdateWithoutCodeProjectInput>
  }

  export type projectUpdateManyWithWhereWithoutCodeProjectInput = {
    where: projectScalarWhereInput
    data: XOR<projectUpdateManyMutationInput, projectUncheckedUpdateManyWithoutProjectInput>
  }

  export type projectScalarWhereInput = {
    AND?: Enumerable<projectScalarWhereInput>
    OR?: Enumerable<projectScalarWhereInput>
    NOT?: Enumerable<projectScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    BudgetPrice?: FloatFilter | number
    Quantity?: FloatFilter | number
    Done?: FloatFilter | number
    IsDelete?: BoolFilter | boolean
    CodeProjectId?: IntFilter | number
    ParentId?: IntFilter | number
    EstimatedDuration?: FloatFilter | number
    Timeline?: IntFilter | number
    Price?: FloatFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
  }

  export type userCreateWithoutCodeProjectDocumentInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCodeProjectDocumentInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCodeProjectDocumentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCodeProjectDocumentInput, userUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type codeProjectCreateWithoutCodeProjectDocumentInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutCodeProjectDocumentInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutCodeProjectDocumentInput = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutCodeProjectDocumentInput, codeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type userUpsertWithoutCodeProjectDocumentInput = {
    update: XOR<userUpdateWithoutCodeProjectDocumentInput, userUncheckedUpdateWithoutCodeProjectDocumentInput>
    create: XOR<userCreateWithoutCodeProjectDocumentInput, userUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type userUpdateWithoutCodeProjectDocumentInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutCodeProjectDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type codeProjectUpsertWithoutCodeProjectDocumentInput = {
    update: XOR<codeProjectUpdateWithoutCodeProjectDocumentInput, codeProjectUncheckedUpdateWithoutCodeProjectDocumentInput>
    create: XOR<codeProjectCreateWithoutCodeProjectDocumentInput, codeProjectUncheckedCreateWithoutCodeProjectDocumentInput>
  }

  export type codeProjectUpdateWithoutCodeProjectDocumentInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutCodeProjectDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type userCreateWithoutCodeProjectUserInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCodeProjectUserInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCodeProjectUserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCodeProjectUserInput, userUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type codeProjectCreateWithoutCodeProjectUserInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutCodeProjectUserInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutCodeProjectUserInput = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutCodeProjectUserInput, codeProjectUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type userUpsertWithoutCodeProjectUserInput = {
    update: XOR<userUpdateWithoutCodeProjectUserInput, userUncheckedUpdateWithoutCodeProjectUserInput>
    create: XOR<userCreateWithoutCodeProjectUserInput, userUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type userUpdateWithoutCodeProjectUserInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutCodeProjectUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type codeProjectUpsertWithoutCodeProjectUserInput = {
    update: XOR<codeProjectUpdateWithoutCodeProjectUserInput, codeProjectUncheckedUpdateWithoutCodeProjectUserInput>
    create: XOR<codeProjectCreateWithoutCodeProjectUserInput, codeProjectUncheckedCreateWithoutCodeProjectUserInput>
  }

  export type codeProjectUpdateWithoutCodeProjectUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutCodeProjectUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type userCreateWithoutCodeReportInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCodeReportInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCodeReportInput, userUncheckedCreateWithoutCodeReportInput>
  }

  export type codeProjectCreateWithoutCodeReportInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutCodeReportInput = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutCodeReportInput, codeProjectUncheckedCreateWithoutCodeReportInput>
  }

  export type codeReportApprovalCreateWithoutCodeReportInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReportComment: codeReportCreateNestedOneWithoutCodeReportApprovalCommentInput
    User: userCreateNestedOneWithoutCodeReportApprovalInput
  }

  export type codeReportApprovalUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type codeReportApprovalCreateOrConnectWithoutCodeReportInput = {
    where: codeReportApprovalWhereUniqueInput
    create: XOR<codeReportApprovalCreateWithoutCodeReportInput, codeReportApprovalUncheckedCreateWithoutCodeReportInput>
  }

  export type codeReportApprovalCreateManyCodeReportInputEnvelope = {
    data: Enumerable<codeReportApprovalCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type codeReportApprovalCreateWithoutCodeReportCommentInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReport: codeReportCreateNestedOneWithoutCodeReportApprovalInput
    User: userCreateNestedOneWithoutCodeReportApprovalInput
  }

  export type codeReportApprovalUncheckedCreateWithoutCodeReportCommentInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type codeReportApprovalCreateOrConnectWithoutCodeReportCommentInput = {
    where: codeReportApprovalWhereUniqueInput
    create: XOR<codeReportApprovalCreateWithoutCodeReportCommentInput, codeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>
  }

  export type codeReportApprovalCreateManyCodeReportCommentInputEnvelope = {
    data: Enumerable<codeReportApprovalCreateManyCodeReportCommentInput>
    skipDuplicates?: boolean
  }

  export type dailyReportImageCreateWithoutCodeReportInput = {
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type dailyReportImageUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type dailyReportImageCreateOrConnectWithoutCodeReportInput = {
    where: dailyReportImageWhereUniqueInput
    create: XOR<dailyReportImageCreateWithoutCodeReportInput, dailyReportImageUncheckedCreateWithoutCodeReportInput>
  }

  export type dailyReportImageCreateManyCodeReportInputEnvelope = {
    data: Enumerable<dailyReportImageCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type dailyTaskCreateWithoutCodeReportInput = {
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
  }

  export type dailyTaskUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
  }

  export type dailyTaskCreateOrConnectWithoutCodeReportInput = {
    where: dailyTaskWhereUniqueInput
    create: XOR<dailyTaskCreateWithoutCodeReportInput, dailyTaskUncheckedCreateWithoutCodeReportInput>
  }

  export type dailyTaskCreateManyCodeReportInputEnvelope = {
    data: Enumerable<dailyTaskCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type statusReportCreateWithoutCodeReportInput = {
    Status: string
    StatusReportImage?: statusReportImageCreateNestedManyWithoutStatusReportInput
  }

  export type statusReportUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Status: string
    StatusReportImage?: statusReportImageUncheckedCreateNestedManyWithoutStatusReportInput
  }

  export type statusReportCreateOrConnectWithoutCodeReportInput = {
    where: statusReportWhereUniqueInput
    create: XOR<statusReportCreateWithoutCodeReportInput, statusReportUncheckedCreateWithoutCodeReportInput>
  }

  export type toolCreateWithoutCodeReportInput = {
    Name: string
    Description: string
    Quantity: number
  }

  export type toolUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
  }

  export type toolCreateOrConnectWithoutCodeReportInput = {
    where: toolWhereUniqueInput
    create: XOR<toolCreateWithoutCodeReportInput, toolUncheckedCreateWithoutCodeReportInput>
  }

  export type toolCreateManyCodeReportInputEnvelope = {
    data: Enumerable<toolCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type weatherCreateWithoutCodeReportInput = {
    WeatherId: number
  }

  export type weatherUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    WeatherId: number
  }

  export type weatherCreateOrConnectWithoutCodeReportInput = {
    where: weatherWhereUniqueInput
    create: XOR<weatherCreateWithoutCodeReportInput, weatherUncheckedCreateWithoutCodeReportInput>
  }

  export type materialCreateWithoutCodeReportInput = {
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
  }

  export type materialUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
  }

  export type materialCreateOrConnectWithoutCodeReportInput = {
    where: materialWhereUniqueInput
    create: XOR<materialCreateWithoutCodeReportInput, materialUncheckedCreateWithoutCodeReportInput>
  }

  export type materialCreateManyCodeReportInputEnvelope = {
    data: Enumerable<materialCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type workerCreateWithoutCodeReportInput = {
    Name: string
    Quantity: number
  }

  export type workerUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
  }

  export type workerCreateOrConnectWithoutCodeReportInput = {
    where: workerWhereUniqueInput
    create: XOR<workerCreateWithoutCodeReportInput, workerUncheckedCreateWithoutCodeReportInput>
  }

  export type workerCreateManyCodeReportInputEnvelope = {
    data: Enumerable<workerCreateManyCodeReportInput>
    skipDuplicates?: boolean
  }

  export type requestForInformationCreateWithoutCodeReportInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedCreateWithoutCodeReportInput = {
    Id?: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationCreateOrConnectWithoutCodeReportInput = {
    where: requestForInformationWhereUniqueInput
    create: XOR<requestForInformationCreateWithoutCodeReportInput, requestForInformationUncheckedCreateWithoutCodeReportInput>
  }

  export type userUpsertWithoutCodeReportInput = {
    update: XOR<userUpdateWithoutCodeReportInput, userUncheckedUpdateWithoutCodeReportInput>
    create: XOR<userCreateWithoutCodeReportInput, userUncheckedCreateWithoutCodeReportInput>
  }

  export type userUpdateWithoutCodeReportInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type codeProjectUpsertWithoutCodeReportInput = {
    update: XOR<codeProjectUpdateWithoutCodeReportInput, codeProjectUncheckedUpdateWithoutCodeReportInput>
    create: XOR<codeProjectCreateWithoutCodeReportInput, codeProjectUncheckedCreateWithoutCodeReportInput>
  }

  export type codeProjectUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type codeReportApprovalUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: codeReportApprovalWhereUniqueInput
    update: XOR<codeReportApprovalUpdateWithoutCodeReportInput, codeReportApprovalUncheckedUpdateWithoutCodeReportInput>
    create: XOR<codeReportApprovalCreateWithoutCodeReportInput, codeReportApprovalUncheckedCreateWithoutCodeReportInput>
  }

  export type codeReportApprovalUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: codeReportApprovalWhereUniqueInput
    data: XOR<codeReportApprovalUpdateWithoutCodeReportInput, codeReportApprovalUncheckedUpdateWithoutCodeReportInput>
  }

  export type codeReportApprovalUpdateManyWithWhereWithoutCodeReportInput = {
    where: codeReportApprovalScalarWhereInput
    data: XOR<codeReportApprovalUpdateManyMutationInput, codeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalInput>
  }

  export type codeReportApprovalScalarWhereInput = {
    AND?: Enumerable<codeReportApprovalScalarWhereInput>
    OR?: Enumerable<codeReportApprovalScalarWhereInput>
    NOT?: Enumerable<codeReportApprovalScalarWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    Comment?: StringFilter | string
    Approval?: IntFilter | number
    IsDelete?: BoolFilter | boolean
  }

  export type codeReportApprovalUpsertWithWhereUniqueWithoutCodeReportCommentInput = {
    where: codeReportApprovalWhereUniqueInput
    update: XOR<codeReportApprovalUpdateWithoutCodeReportCommentInput, codeReportApprovalUncheckedUpdateWithoutCodeReportCommentInput>
    create: XOR<codeReportApprovalCreateWithoutCodeReportCommentInput, codeReportApprovalUncheckedCreateWithoutCodeReportCommentInput>
  }

  export type codeReportApprovalUpdateWithWhereUniqueWithoutCodeReportCommentInput = {
    where: codeReportApprovalWhereUniqueInput
    data: XOR<codeReportApprovalUpdateWithoutCodeReportCommentInput, codeReportApprovalUncheckedUpdateWithoutCodeReportCommentInput>
  }

  export type codeReportApprovalUpdateManyWithWhereWithoutCodeReportCommentInput = {
    where: codeReportApprovalScalarWhereInput
    data: XOR<codeReportApprovalUpdateManyMutationInput, codeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalCommentInput>
  }

  export type dailyReportImageUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: dailyReportImageWhereUniqueInput
    update: XOR<dailyReportImageUpdateWithoutCodeReportInput, dailyReportImageUncheckedUpdateWithoutCodeReportInput>
    create: XOR<dailyReportImageCreateWithoutCodeReportInput, dailyReportImageUncheckedCreateWithoutCodeReportInput>
  }

  export type dailyReportImageUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: dailyReportImageWhereUniqueInput
    data: XOR<dailyReportImageUpdateWithoutCodeReportInput, dailyReportImageUncheckedUpdateWithoutCodeReportInput>
  }

  export type dailyReportImageUpdateManyWithWhereWithoutCodeReportInput = {
    where: dailyReportImageScalarWhereInput
    data: XOR<dailyReportImageUpdateManyMutationInput, dailyReportImageUncheckedUpdateManyWithoutDailyReportImageInput>
  }

  export type dailyReportImageScalarWhereInput = {
    AND?: Enumerable<dailyReportImageScalarWhereInput>
    OR?: Enumerable<dailyReportImageScalarWhereInput>
    NOT?: Enumerable<dailyReportImageScalarWhereInput>
    Id?: IntFilter | number
    CodeReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
    Caption?: StringFilter | string
  }

  export type dailyTaskUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: dailyTaskWhereUniqueInput
    update: XOR<dailyTaskUpdateWithoutCodeReportInput, dailyTaskUncheckedUpdateWithoutCodeReportInput>
    create: XOR<dailyTaskCreateWithoutCodeReportInput, dailyTaskUncheckedCreateWithoutCodeReportInput>
  }

  export type dailyTaskUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: dailyTaskWhereUniqueInput
    data: XOR<dailyTaskUpdateWithoutCodeReportInput, dailyTaskUncheckedUpdateWithoutCodeReportInput>
  }

  export type dailyTaskUpdateManyWithWhereWithoutCodeReportInput = {
    where: dailyTaskScalarWhereInput
    data: XOR<dailyTaskUpdateManyMutationInput, dailyTaskUncheckedUpdateManyWithoutDailyTaskInput>
  }

  export type dailyTaskScalarWhereInput = {
    AND?: Enumerable<dailyTaskScalarWhereInput>
    OR?: Enumerable<dailyTaskScalarWhereInput>
    NOT?: Enumerable<dailyTaskScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Unit?: StringFilter | string
    Quantity?: FloatFilter | number
    ParentId?: IntFilter | number
    CodeReportId?: IntFilter | number
    Note?: StringFilter | string
  }

  export type statusReportUpsertWithoutCodeReportInput = {
    update: XOR<statusReportUpdateWithoutCodeReportInput, statusReportUncheckedUpdateWithoutCodeReportInput>
    create: XOR<statusReportCreateWithoutCodeReportInput, statusReportUncheckedCreateWithoutCodeReportInput>
  }

  export type statusReportUpdateWithoutCodeReportInput = {
    Status?: StringFieldUpdateOperationsInput | string
    StatusReportImage?: statusReportImageUpdateManyWithoutStatusReportInput
  }

  export type statusReportUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    StatusReportImage?: statusReportImageUncheckedUpdateManyWithoutStatusReportInput
  }

  export type toolUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: toolWhereUniqueInput
    update: XOR<toolUpdateWithoutCodeReportInput, toolUncheckedUpdateWithoutCodeReportInput>
    create: XOR<toolCreateWithoutCodeReportInput, toolUncheckedCreateWithoutCodeReportInput>
  }

  export type toolUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: toolWhereUniqueInput
    data: XOR<toolUpdateWithoutCodeReportInput, toolUncheckedUpdateWithoutCodeReportInput>
  }

  export type toolUpdateManyWithWhereWithoutCodeReportInput = {
    where: toolScalarWhereInput
    data: XOR<toolUpdateManyMutationInput, toolUncheckedUpdateManyWithoutToolInput>
  }

  export type toolScalarWhereInput = {
    AND?: Enumerable<toolScalarWhereInput>
    OR?: Enumerable<toolScalarWhereInput>
    NOT?: Enumerable<toolScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    Quantity?: IntFilter | number
    CodeReportId?: IntFilter | number
  }

  export type weatherUpsertWithoutCodeReportInput = {
    update: XOR<weatherUpdateWithoutCodeReportInput, weatherUncheckedUpdateWithoutCodeReportInput>
    create: XOR<weatherCreateWithoutCodeReportInput, weatherUncheckedCreateWithoutCodeReportInput>
  }

  export type weatherUpdateWithoutCodeReportInput = {
    WeatherId?: IntFieldUpdateOperationsInput | number
  }

  export type weatherUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    WeatherId?: IntFieldUpdateOperationsInput | number
  }

  export type materialUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: materialWhereUniqueInput
    update: XOR<materialUpdateWithoutCodeReportInput, materialUncheckedUpdateWithoutCodeReportInput>
    create: XOR<materialCreateWithoutCodeReportInput, materialUncheckedCreateWithoutCodeReportInput>
  }

  export type materialUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: materialWhereUniqueInput
    data: XOR<materialUpdateWithoutCodeReportInput, materialUncheckedUpdateWithoutCodeReportInput>
  }

  export type materialUpdateManyWithWhereWithoutCodeReportInput = {
    where: materialScalarWhereInput
    data: XOR<materialUpdateManyMutationInput, materialUncheckedUpdateManyWithoutMaterialInput>
  }

  export type materialScalarWhereInput = {
    AND?: Enumerable<materialScalarWhereInput>
    OR?: Enumerable<materialScalarWhereInput>
    NOT?: Enumerable<materialScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Quantity?: FloatFilter | number
    Status?: IntFilter | number
    Description?: StringFilter | string
    Unit?: StringFilter | string
    CodeReportId?: IntFilter | number
  }

  export type workerUpsertWithWhereUniqueWithoutCodeReportInput = {
    where: workerWhereUniqueInput
    update: XOR<workerUpdateWithoutCodeReportInput, workerUncheckedUpdateWithoutCodeReportInput>
    create: XOR<workerCreateWithoutCodeReportInput, workerUncheckedCreateWithoutCodeReportInput>
  }

  export type workerUpdateWithWhereUniqueWithoutCodeReportInput = {
    where: workerWhereUniqueInput
    data: XOR<workerUpdateWithoutCodeReportInput, workerUncheckedUpdateWithoutCodeReportInput>
  }

  export type workerUpdateManyWithWhereWithoutCodeReportInput = {
    where: workerScalarWhereInput
    data: XOR<workerUpdateManyMutationInput, workerUncheckedUpdateManyWithoutWorkerInput>
  }

  export type workerScalarWhereInput = {
    AND?: Enumerable<workerScalarWhereInput>
    OR?: Enumerable<workerScalarWhereInput>
    NOT?: Enumerable<workerScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    CodeReportId?: IntFilter | number
    Quantity?: IntFilter | number
  }

  export type requestForInformationUpsertWithoutCodeReportInput = {
    update: XOR<requestForInformationUpdateWithoutCodeReportInput, requestForInformationUncheckedUpdateWithoutCodeReportInput>
    create: XOR<requestForInformationCreateWithoutCodeReportInput, requestForInformationUncheckedCreateWithoutCodeReportInput>
  }

  export type requestForInformationUpdateWithoutCodeReportInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentUpdateManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type codeReportCreateWithoutCodeReportApprovalInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutCodeReportApprovalInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutCodeReportApprovalInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutCodeReportApprovalInput, codeReportUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type codeReportCreateWithoutCodeReportApprovalCommentInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutCodeReportApprovalCommentInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutCodeReportApprovalCommentInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutCodeReportApprovalCommentInput, codeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
  }

  export type userCreateWithoutCodeReportApprovalInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCodeReportApprovalInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCodeReportApprovalInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCodeReportApprovalInput, userUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type codeReportUpsertWithoutCodeReportApprovalInput = {
    update: XOR<codeReportUpdateWithoutCodeReportApprovalInput, codeReportUncheckedUpdateWithoutCodeReportApprovalInput>
    create: XOR<codeReportCreateWithoutCodeReportApprovalInput, codeReportUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type codeReportUpdateWithoutCodeReportApprovalInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutCodeReportApprovalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportUpsertWithoutCodeReportApprovalCommentInput = {
    update: XOR<codeReportUpdateWithoutCodeReportApprovalCommentInput, codeReportUncheckedUpdateWithoutCodeReportApprovalCommentInput>
    create: XOR<codeReportCreateWithoutCodeReportApprovalCommentInput, codeReportUncheckedCreateWithoutCodeReportApprovalCommentInput>
  }

  export type codeReportUpdateWithoutCodeReportApprovalCommentInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutCodeReportApprovalCommentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type userUpsertWithoutCodeReportApprovalInput = {
    update: XOR<userUpdateWithoutCodeReportApprovalInput, userUncheckedUpdateWithoutCodeReportApprovalInput>
    create: XOR<userCreateWithoutCodeReportApprovalInput, userUncheckedCreateWithoutCodeReportApprovalInput>
  }

  export type userUpdateWithoutCodeReportApprovalInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutCodeReportApprovalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type codeReportCreateWithoutDailyReportImageInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutDailyReportImageInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutDailyReportImageInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutDailyReportImageInput, codeReportUncheckedCreateWithoutDailyReportImageInput>
  }

  export type codeReportUpsertWithoutDailyReportImageInput = {
    update: XOR<codeReportUpdateWithoutDailyReportImageInput, codeReportUncheckedUpdateWithoutDailyReportImageInput>
    create: XOR<codeReportCreateWithoutDailyReportImageInput, codeReportUncheckedCreateWithoutDailyReportImageInput>
  }

  export type codeReportUpdateWithoutDailyReportImageInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutDailyReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportCreateWithoutDailyTaskInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutDailyTaskInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutDailyTaskInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutDailyTaskInput, codeReportUncheckedCreateWithoutDailyTaskInput>
  }

  export type codeReportUpsertWithoutDailyTaskInput = {
    update: XOR<codeReportUpdateWithoutDailyTaskInput, codeReportUncheckedUpdateWithoutDailyTaskInput>
    create: XOR<codeReportCreateWithoutDailyTaskInput, codeReportUncheckedCreateWithoutDailyTaskInput>
  }

  export type codeReportUpdateWithoutDailyTaskInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutDailyTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportCreateWithoutMaterialInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutMaterialInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutMaterialInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutMaterialInput, codeReportUncheckedCreateWithoutMaterialInput>
  }

  export type codeReportUpsertWithoutMaterialInput = {
    update: XOR<codeReportUpdateWithoutMaterialInput, codeReportUncheckedUpdateWithoutMaterialInput>
    create: XOR<codeReportCreateWithoutMaterialInput, codeReportUncheckedCreateWithoutMaterialInput>
  }

  export type codeReportUpdateWithoutMaterialInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutMaterialInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeProjectCreateWithoutProjectInput = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutProjectInput = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutProjectInput = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutProjectInput, codeProjectUncheckedCreateWithoutProjectInput>
  }

  export type codeProjectUpsertWithoutProjectInput = {
    update: XOR<codeProjectUpdateWithoutProjectInput, codeProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<codeProjectCreateWithoutProjectInput, codeProjectUncheckedCreateWithoutProjectInput>
  }

  export type codeProjectUpdateWithoutProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type userCreateWithoutProjectTaskInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProjectTaskInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProjectTaskInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
  }

  export type userUpsertWithoutProjectTaskInput = {
    update: XOR<userUpdateWithoutProjectTaskInput, userUncheckedUpdateWithoutProjectTaskInput>
    create: XOR<userCreateWithoutProjectTaskInput, userUncheckedCreateWithoutProjectTaskInput>
  }

  export type userUpdateWithoutProjectTaskInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutProjectTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type codeReportCreateWithoutRequestForInformationInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutRequestForInformationInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutRequestForInformationInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutRequestForInformationInput, codeReportUncheckedCreateWithoutRequestForInformationInput>
  }

  export type requestForInformationAnswerCreateWithoutRequestForInformationInput = {
    Answer: string
    CreatedDate: Date | string
    IsDelete?: boolean
    User: userCreateNestedOneWithoutRequestForInformationAnswerInput
  }

  export type requestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    IsDelete?: boolean
  }

  export type requestForInformationAnswerCreateOrConnectWithoutRequestForInformationInput = {
    where: requestForInformationAnswerWhereUniqueInput
    create: XOR<requestForInformationAnswerCreateWithoutRequestForInformationInput, requestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>
  }

  export type requestForInformationAnswerCreateManyRequestForInformationInputEnvelope = {
    data: Enumerable<requestForInformationAnswerCreateManyRequestForInformationInput>
    skipDuplicates?: boolean
  }

  export type requestForInformationDocumentCreateWithoutRequestForInformationInput = {
    ImageUrl: string
    Name: string
  }

  export type requestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type requestForInformationDocumentCreateOrConnectWithoutRequestForInformationInput = {
    where: requestForInformationDocumentWhereUniqueInput
    create: XOR<requestForInformationDocumentCreateWithoutRequestForInformationInput, requestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>
  }

  export type requestForInformationDocumentCreateManyRequestForInformationInputEnvelope = {
    data: Enumerable<requestForInformationDocumentCreateManyRequestForInformationInput>
    skipDuplicates?: boolean
  }

  export type codeReportUpsertWithoutRequestForInformationInput = {
    update: XOR<codeReportUpdateWithoutRequestForInformationInput, codeReportUncheckedUpdateWithoutRequestForInformationInput>
    create: XOR<codeReportCreateWithoutRequestForInformationInput, codeReportUncheckedCreateWithoutRequestForInformationInput>
  }

  export type codeReportUpdateWithoutRequestForInformationInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutRequestForInformationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
  }

  export type requestForInformationAnswerUpsertWithWhereUniqueWithoutRequestForInformationInput = {
    where: requestForInformationAnswerWhereUniqueInput
    update: XOR<requestForInformationAnswerUpdateWithoutRequestForInformationInput, requestForInformationAnswerUncheckedUpdateWithoutRequestForInformationInput>
    create: XOR<requestForInformationAnswerCreateWithoutRequestForInformationInput, requestForInformationAnswerUncheckedCreateWithoutRequestForInformationInput>
  }

  export type requestForInformationAnswerUpdateWithWhereUniqueWithoutRequestForInformationInput = {
    where: requestForInformationAnswerWhereUniqueInput
    data: XOR<requestForInformationAnswerUpdateWithoutRequestForInformationInput, requestForInformationAnswerUncheckedUpdateWithoutRequestForInformationInput>
  }

  export type requestForInformationAnswerUpdateManyWithWhereWithoutRequestForInformationInput = {
    where: requestForInformationAnswerScalarWhereInput
    data: XOR<requestForInformationAnswerUpdateManyMutationInput, requestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationAnswerInput>
  }

  export type requestForInformationAnswerScalarWhereInput = {
    AND?: Enumerable<requestForInformationAnswerScalarWhereInput>
    OR?: Enumerable<requestForInformationAnswerScalarWhereInput>
    NOT?: Enumerable<requestForInformationAnswerScalarWhereInput>
    Id?: IntFilter | number
    Answer?: StringFilter | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    RequestForInformationId?: IntFilter | number
    IsDelete?: BoolFilter | boolean
  }

  export type requestForInformationDocumentUpsertWithWhereUniqueWithoutRequestForInformationInput = {
    where: requestForInformationDocumentWhereUniqueInput
    update: XOR<requestForInformationDocumentUpdateWithoutRequestForInformationInput, requestForInformationDocumentUncheckedUpdateWithoutRequestForInformationInput>
    create: XOR<requestForInformationDocumentCreateWithoutRequestForInformationInput, requestForInformationDocumentUncheckedCreateWithoutRequestForInformationInput>
  }

  export type requestForInformationDocumentUpdateWithWhereUniqueWithoutRequestForInformationInput = {
    where: requestForInformationDocumentWhereUniqueInput
    data: XOR<requestForInformationDocumentUpdateWithoutRequestForInformationInput, requestForInformationDocumentUncheckedUpdateWithoutRequestForInformationInput>
  }

  export type requestForInformationDocumentUpdateManyWithWhereWithoutRequestForInformationInput = {
    where: requestForInformationDocumentScalarWhereInput
    data: XOR<requestForInformationDocumentUpdateManyMutationInput, requestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationDocumentInput>
  }

  export type requestForInformationDocumentScalarWhereInput = {
    AND?: Enumerable<requestForInformationDocumentScalarWhereInput>
    OR?: Enumerable<requestForInformationDocumentScalarWhereInput>
    NOT?: Enumerable<requestForInformationDocumentScalarWhereInput>
    Id?: IntFilter | number
    RequestForInformationId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
  }

  export type userCreateWithoutRequestForInformationAnswerInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRequestForInformationAnswerInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRequestForInformationAnswerInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRequestForInformationAnswerInput, userUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type requestForInformationCreateWithoutRequestForInformationAnswerInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    CodeReport: codeReportCreateNestedOneWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationDocument?: requestForInformationDocumentUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationCreateOrConnectWithoutRequestForInformationAnswerInput = {
    where: requestForInformationWhereUniqueInput
    create: XOR<requestForInformationCreateWithoutRequestForInformationAnswerInput, requestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type userUpsertWithoutRequestForInformationAnswerInput = {
    update: XOR<userUpdateWithoutRequestForInformationAnswerInput, userUncheckedUpdateWithoutRequestForInformationAnswerInput>
    create: XOR<userCreateWithoutRequestForInformationAnswerInput, userUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type userUpdateWithoutRequestForInformationAnswerInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutRequestForInformationAnswerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type requestForInformationUpsertWithoutRequestForInformationAnswerInput = {
    update: XOR<requestForInformationUpdateWithoutRequestForInformationAnswerInput, requestForInformationUncheckedUpdateWithoutRequestForInformationAnswerInput>
    create: XOR<requestForInformationCreateWithoutRequestForInformationAnswerInput, requestForInformationUncheckedCreateWithoutRequestForInformationAnswerInput>
  }

  export type requestForInformationUpdateWithoutRequestForInformationAnswerInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: codeReportUpdateOneRequiredWithoutRequestForInformationInput
    RequestForInformationDocument?: requestForInformationDocumentUpdateManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedUpdateWithoutRequestForInformationAnswerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationDocument?: requestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type requestForInformationCreateWithoutRequestForInformationDocumentInput = {
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    CodeReport: codeReportCreateNestedOneWithoutRequestForInformationInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput = {
    Id?: number
    CodeReportId: number
    Description: string
    Header: string
    AddressedFor: string
    IsDelete?: boolean
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutRequestForInformationInput
  }

  export type requestForInformationCreateOrConnectWithoutRequestForInformationDocumentInput = {
    where: requestForInformationWhereUniqueInput
    create: XOR<requestForInformationCreateWithoutRequestForInformationDocumentInput, requestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
  }

  export type requestForInformationUpsertWithoutRequestForInformationDocumentInput = {
    update: XOR<requestForInformationUpdateWithoutRequestForInformationDocumentInput, requestForInformationUncheckedUpdateWithoutRequestForInformationDocumentInput>
    create: XOR<requestForInformationCreateWithoutRequestForInformationDocumentInput, requestForInformationUncheckedCreateWithoutRequestForInformationDocumentInput>
  }

  export type requestForInformationUpdateWithoutRequestForInformationDocumentInput = {
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: codeReportUpdateOneRequiredWithoutRequestForInformationInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutRequestForInformationInput
  }

  export type requestForInformationUncheckedUpdateWithoutRequestForInformationDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Header?: StringFieldUpdateOperationsInput | string
    AddressedFor?: StringFieldUpdateOperationsInput | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationInput
  }

  export type codeReportCreateWithoutStatusReportInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutStatusReportInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutStatusReportInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutStatusReportInput, codeReportUncheckedCreateWithoutStatusReportInput>
  }

  export type statusReportImageCreateWithoutStatusReportInput = {
    ImageUrl: string
    Name: string
  }

  export type statusReportImageUncheckedCreateWithoutStatusReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type statusReportImageCreateOrConnectWithoutStatusReportInput = {
    where: statusReportImageWhereUniqueInput
    create: XOR<statusReportImageCreateWithoutStatusReportInput, statusReportImageUncheckedCreateWithoutStatusReportInput>
  }

  export type statusReportImageCreateManyStatusReportInputEnvelope = {
    data: Enumerable<statusReportImageCreateManyStatusReportInput>
    skipDuplicates?: boolean
  }

  export type codeReportUpsertWithoutStatusReportInput = {
    update: XOR<codeReportUpdateWithoutStatusReportInput, codeReportUncheckedUpdateWithoutStatusReportInput>
    create: XOR<codeReportCreateWithoutStatusReportInput, codeReportUncheckedCreateWithoutStatusReportInput>
  }

  export type codeReportUpdateWithoutStatusReportInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutStatusReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type statusReportImageUpsertWithWhereUniqueWithoutStatusReportInput = {
    where: statusReportImageWhereUniqueInput
    update: XOR<statusReportImageUpdateWithoutStatusReportInput, statusReportImageUncheckedUpdateWithoutStatusReportInput>
    create: XOR<statusReportImageCreateWithoutStatusReportInput, statusReportImageUncheckedCreateWithoutStatusReportInput>
  }

  export type statusReportImageUpdateWithWhereUniqueWithoutStatusReportInput = {
    where: statusReportImageWhereUniqueInput
    data: XOR<statusReportImageUpdateWithoutStatusReportInput, statusReportImageUncheckedUpdateWithoutStatusReportInput>
  }

  export type statusReportImageUpdateManyWithWhereWithoutStatusReportInput = {
    where: statusReportImageScalarWhereInput
    data: XOR<statusReportImageUpdateManyMutationInput, statusReportImageUncheckedUpdateManyWithoutStatusReportImageInput>
  }

  export type statusReportImageScalarWhereInput = {
    AND?: Enumerable<statusReportImageScalarWhereInput>
    OR?: Enumerable<statusReportImageScalarWhereInput>
    NOT?: Enumerable<statusReportImageScalarWhereInput>
    Id?: IntFilter | number
    StatusReportId?: IntFilter | number
    ImageUrl?: StringFilter | string
    Name?: StringFilter | string
  }

  export type statusReportCreateWithoutStatusReportImageInput = {
    Status: string
    CodeReport: codeReportCreateNestedOneWithoutStatusReportInput
  }

  export type statusReportUncheckedCreateWithoutStatusReportImageInput = {
    Id?: number
    Status: string
    CodeReportId: number
  }

  export type statusReportCreateOrConnectWithoutStatusReportImageInput = {
    where: statusReportWhereUniqueInput
    create: XOR<statusReportCreateWithoutStatusReportImageInput, statusReportUncheckedCreateWithoutStatusReportImageInput>
  }

  export type statusReportUpsertWithoutStatusReportImageInput = {
    update: XOR<statusReportUpdateWithoutStatusReportImageInput, statusReportUncheckedUpdateWithoutStatusReportImageInput>
    create: XOR<statusReportCreateWithoutStatusReportImageInput, statusReportUncheckedCreateWithoutStatusReportImageInput>
  }

  export type statusReportUpdateWithoutStatusReportImageInput = {
    Status?: StringFieldUpdateOperationsInput | string
    CodeReport?: codeReportUpdateOneRequiredWithoutStatusReportInput
  }

  export type statusReportUncheckedUpdateWithoutStatusReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    CodeReportId?: IntFieldUpdateOperationsInput | number
  }

  export type codeReportCreateWithoutToolInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutToolInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutToolInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutToolInput, codeReportUncheckedCreateWithoutToolInput>
  }

  export type codeReportUpsertWithoutToolInput = {
    update: XOR<codeReportUpdateWithoutToolInput, codeReportUncheckedUpdateWithoutToolInput>
    create: XOR<codeReportCreateWithoutToolInput, codeReportUncheckedCreateWithoutToolInput>
  }

  export type codeReportUpdateWithoutToolInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutToolInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportCreateWithoutWeatherInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutWeatherInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutWeatherInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutWeatherInput, codeReportUncheckedCreateWithoutWeatherInput>
  }

  export type codeReportUpsertWithoutWeatherInput = {
    update: XOR<codeReportUpdateWithoutWeatherInput, codeReportUncheckedUpdateWithoutWeatherInput>
    create: XOR<codeReportCreateWithoutWeatherInput, codeReportUncheckedCreateWithoutWeatherInput>
  }

  export type codeReportUpdateWithoutWeatherInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutWeatherInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportCreateWithoutWorkerInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    User: userCreateNestedOneWithoutCodeReportInput
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutWorkerInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutWorkerInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutWorkerInput, codeReportUncheckedCreateWithoutWorkerInput>
  }

  export type codeReportUpsertWithoutWorkerInput = {
    update: XOR<codeReportUpdateWithoutWorkerInput, codeReportUncheckedUpdateWithoutWorkerInput>
    create: XOR<codeReportCreateWithoutWorkerInput, codeReportUncheckedCreateWithoutWorkerInput>
  }

  export type codeReportUpdateWithoutWorkerInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutWorkerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type userCreateWithoutUserContactInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserContactInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserContactInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserContactInput, userUncheckedCreateWithoutUserContactInput>
  }

  export type userUpsertWithoutUserContactInput = {
    update: XOR<userUpdateWithoutUserContactInput, userUncheckedUpdateWithoutUserContactInput>
    create: XOR<userCreateWithoutUserContactInput, userUncheckedCreateWithoutUserContactInput>
  }

  export type userUpdateWithoutUserContactInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutUserContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type userCreateWithoutCreateUserPositionInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    UserPosition?: userPositionCreateNestedManyWithoutUser5Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreateUserPositionInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    UserPosition?: userPositionUncheckedCreateNestedManyWithoutUser5Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreateUserPositionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreateUserPositionInput, userUncheckedCreateWithoutCreateUserPositionInput>
  }

  export type userCreateWithoutUserPositionInput = {
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientCreateNestedManyWithoutUserInput
    ClientContact?: clientContactCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutUserInput
    CodeReport?: codeReportCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionCreateNestedManyWithoutUser4Input
    UserContact?: userContactCreateNestedManyWithoutUserInput
    Token?: userTokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserPositionInput = {
    Id?: number
    Email: string
    FirstName: string
    LastName: string
    IsActive?: boolean
    Password?: string | null
    ImageUrl?: string | null
    ThumbnailUrl?: string | null
    Client?: clientUncheckedCreateNestedManyWithoutUserInput
    ClientContact?: clientContactUncheckedCreateNestedManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedCreateNestedManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutUserInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedCreateNestedManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedCreateNestedManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedCreateNestedManyWithoutUser4Input
    UserContact?: userContactUncheckedCreateNestedManyWithoutUserInput
    Token?: userTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserPositionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserPositionInput, userUncheckedCreateWithoutUserPositionInput>
  }

  export type userUpsertWithoutCreateUserPositionInput = {
    update: XOR<userUpdateWithoutCreateUserPositionInput, userUncheckedUpdateWithoutCreateUserPositionInput>
    create: XOR<userCreateWithoutCreateUserPositionInput, userUncheckedCreateWithoutCreateUserPositionInput>
  }

  export type userUpdateWithoutCreateUserPositionInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    UserPosition?: userPositionUpdateManyWithoutUser5Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutCreateUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    UserPosition?: userPositionUncheckedUpdateManyWithoutUser5Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutUserPositionInput = {
    update: XOR<userUpdateWithoutUserPositionInput, userUncheckedUpdateWithoutUserPositionInput>
    create: XOR<userCreateWithoutUserPositionInput, userUncheckedCreateWithoutUserPositionInput>
  }

  export type userUpdateWithoutUserPositionInput = {
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUpdateManyWithoutUserInput
    ClientContact?: clientContactUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUpdateManyWithoutUserInput
    CodeReport?: codeReportUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUpdateManyWithoutUser4Input
    UserContact?: userContactUpdateManyWithoutUserInput
    Token?: userTokenUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    FirstName?: StringFieldUpdateOperationsInput | string
    LastName?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ThumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Client?: clientUncheckedUpdateManyWithoutUserInput
    ClientContact?: clientContactUncheckedUpdateManyWithoutUserInput
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutUserInput
    CreateCodeProject?: codeProjectUncheckedUpdateManyWithoutUser1Input
    ConfirmedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser2Input
    CompletedCodeProject?: codeProjectUncheckedUpdateManyWithoutUser3Input
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutUserInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutUserInput
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutUserInput
    ProjectTask?: projectTaskUncheckedUpdateManyWithoutUserInput
    RequestForInformationAnswer?: requestForInformationAnswerUncheckedUpdateManyWithoutUserInput
    CreateUserPosition?: userPositionUncheckedUpdateManyWithoutUser4Input
    UserContact?: userContactUncheckedUpdateManyWithoutUserInput
    Token?: userTokenUncheckedUpdateManyWithoutUserInput
  }

  export type clientCreateWithoutUserInput = {
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    Contact?: clientContactCreateNestedManyWithoutClientInput
    CodeProject?: codeProjectCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
    Contact?: clientContactUncheckedCreateNestedManyWithoutClientInput
    CodeProject?: codeProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutUserInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
  }

  export type clientCreateManyUserInputEnvelope = {
    data: Enumerable<clientCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type clientContactCreateWithoutUserInput = {
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    Client: clientCreateNestedOneWithoutContactInput
  }

  export type clientContactUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    ClientId: number
  }

  export type clientContactCreateOrConnectWithoutUserInput = {
    where: clientContactWhereUniqueInput
    create: XOR<clientContactCreateWithoutUserInput, clientContactUncheckedCreateWithoutUserInput>
  }

  export type clientContactCreateManyUserInputEnvelope = {
    data: Enumerable<clientContactCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type codeProjectDocumentCreateWithoutUserInput = {
    Name: string
    Url: string
    CreatedDate?: Date | string
    CodeProject: codeProjectCreateNestedOneWithoutCodeProjectDocumentInput
  }

  export type codeProjectDocumentUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedDate?: Date | string
  }

  export type codeProjectDocumentCreateOrConnectWithoutUserInput = {
    where: codeProjectDocumentWhereUniqueInput
    create: XOR<codeProjectDocumentCreateWithoutUserInput, codeProjectDocumentUncheckedCreateWithoutUserInput>
  }

  export type codeProjectDocumentCreateManyUserInputEnvelope = {
    data: Enumerable<codeProjectDocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type codeProjectCreateWithoutUser1Input = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutUser1Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutUser1Input = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutUser1Input, codeProjectUncheckedCreateWithoutUser1Input>
  }

  export type codeProjectCreateManyUser1InputEnvelope = {
    data: Enumerable<codeProjectCreateManyUser1Input>
    skipDuplicates?: boolean
  }

  export type codeProjectCreateWithoutUser2Input = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User3?: userCreateNestedOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutUser2Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutUser2Input = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutUser2Input, codeProjectUncheckedCreateWithoutUser2Input>
  }

  export type codeProjectCreateManyUser2InputEnvelope = {
    data: Enumerable<codeProjectCreateManyUser2Input>
    skipDuplicates?: boolean
  }

  export type codeProjectCreateWithoutUser3Input = {
    Name: string
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    Client: clientCreateNestedOneWithoutCodeProjectInput
    User1: userCreateNestedOneWithoutCreateCodeProjectInput
    User2?: userCreateNestedOneWithoutConfirmedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportCreateNestedManyWithoutCodeProjectInput
    Project?: projectCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedCreateWithoutUser3Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedCreateNestedManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedCreateNestedManyWithoutCodeProjectInput
    Project?: projectUncheckedCreateNestedManyWithoutCodeProjectInput
  }

  export type codeProjectCreateOrConnectWithoutUser3Input = {
    where: codeProjectWhereUniqueInput
    create: XOR<codeProjectCreateWithoutUser3Input, codeProjectUncheckedCreateWithoutUser3Input>
  }

  export type codeProjectCreateManyUser3InputEnvelope = {
    data: Enumerable<codeProjectCreateManyUser3Input>
    skipDuplicates?: boolean
  }

  export type codeProjectUserCreateWithoutUserInput = {
    CodeProject: codeProjectCreateNestedOneWithoutCodeProjectUserInput
  }

  export type codeProjectUserUncheckedCreateWithoutUserInput = {
    Id?: number
    CodeProjectId: number
  }

  export type codeProjectUserCreateOrConnectWithoutUserInput = {
    where: codeProjectUserWhereUniqueInput
    create: XOR<codeProjectUserCreateWithoutUserInput, codeProjectUserUncheckedCreateWithoutUserInput>
  }

  export type codeProjectUserCreateManyUserInputEnvelope = {
    data: Enumerable<codeProjectUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type codeReportCreateWithoutUserInput = {
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
    CodeProject: codeProjectCreateNestedOneWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportCreateNestedOneWithoutCodeReportInput
    Tool?: toolCreateNestedManyWithoutCodeReportInput
    Weather?: weatherCreateNestedOneWithoutCodeReportInput
    Material?: materialCreateNestedManyWithoutCodeReportInput
    Worker?: workerCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportUncheckedCreateWithoutUserInput = {
    Id?: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
    CodeReportApproval?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedCreateNestedManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedCreateNestedManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedCreateNestedManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedCreateNestedOneWithoutCodeReportInput
    Tool?: toolUncheckedCreateNestedManyWithoutCodeReportInput
    Weather?: weatherUncheckedCreateNestedOneWithoutCodeReportInput
    Material?: materialUncheckedCreateNestedManyWithoutCodeReportInput
    Worker?: workerUncheckedCreateNestedManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedCreateNestedOneWithoutCodeReportInput
  }

  export type codeReportCreateOrConnectWithoutUserInput = {
    where: codeReportWhereUniqueInput
    create: XOR<codeReportCreateWithoutUserInput, codeReportUncheckedCreateWithoutUserInput>
  }

  export type codeReportCreateManyUserInputEnvelope = {
    data: Enumerable<codeReportCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type codeReportApprovalCreateWithoutUserInput = {
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
    CodeReport: codeReportCreateNestedOneWithoutCodeReportApprovalInput
    CodeReportComment: codeReportCreateNestedOneWithoutCodeReportApprovalCommentInput
  }

  export type codeReportApprovalUncheckedCreateWithoutUserInput = {
    Id?: number
    CodeReportId: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type codeReportApprovalCreateOrConnectWithoutUserInput = {
    where: codeReportApprovalWhereUniqueInput
    create: XOR<codeReportApprovalCreateWithoutUserInput, codeReportApprovalUncheckedCreateWithoutUserInput>
  }

  export type codeReportApprovalCreateManyUserInputEnvelope = {
    data: Enumerable<codeReportApprovalCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type projectTaskCreateWithoutUserInput = {
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
  }

  export type projectTaskUncheckedCreateWithoutUserInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
  }

  export type projectTaskCreateOrConnectWithoutUserInput = {
    where: projectTaskWhereUniqueInput
    create: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput>
  }

  export type projectTaskCreateManyUserInputEnvelope = {
    data: Enumerable<projectTaskCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type requestForInformationAnswerCreateWithoutUserInput = {
    Answer: string
    CreatedDate: Date | string
    IsDelete?: boolean
    RequestForInformation: requestForInformationCreateNestedOneWithoutRequestForInformationAnswerInput
  }

  export type requestForInformationAnswerUncheckedCreateWithoutUserInput = {
    Id?: number
    Answer: string
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type requestForInformationAnswerCreateOrConnectWithoutUserInput = {
    where: requestForInformationAnswerWhereUniqueInput
    create: XOR<requestForInformationAnswerCreateWithoutUserInput, requestForInformationAnswerUncheckedCreateWithoutUserInput>
  }

  export type requestForInformationAnswerCreateManyUserInputEnvelope = {
    data: Enumerable<requestForInformationAnswerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type userPositionCreateWithoutUser4Input = {
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    User5: userCreateNestedOneWithoutUserPositionInput
  }

  export type userPositionUncheckedCreateWithoutUser4Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    UserId: number
  }

  export type userPositionCreateOrConnectWithoutUser4Input = {
    where: userPositionWhereUniqueInput
    create: XOR<userPositionCreateWithoutUser4Input, userPositionUncheckedCreateWithoutUser4Input>
  }

  export type userPositionCreateManyUser4InputEnvelope = {
    data: Enumerable<userPositionCreateManyUser4Input>
    skipDuplicates?: boolean
  }

  export type userPositionCreateWithoutUser5Input = {
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    User4: userCreateNestedOneWithoutCreateUserPositionInput
  }

  export type userPositionUncheckedCreateWithoutUser5Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type userPositionCreateOrConnectWithoutUser5Input = {
    where: userPositionWhereUniqueInput
    create: XOR<userPositionCreateWithoutUser5Input, userPositionUncheckedCreateWithoutUser5Input>
  }

  export type userPositionCreateManyUser5InputEnvelope = {
    data: Enumerable<userPositionCreateManyUser5Input>
    skipDuplicates?: boolean
  }

  export type userContactCreateWithoutUserInput = {
    PhoneNumber: string
    WhatsappAvailable: boolean
  }

  export type userContactUncheckedCreateWithoutUserInput = {
    Id?: number
    PhoneNumber: string
    WhatsappAvailable: boolean
  }

  export type userContactCreateOrConnectWithoutUserInput = {
    where: userContactWhereUniqueInput
    create: XOR<userContactCreateWithoutUserInput, userContactUncheckedCreateWithoutUserInput>
  }

  export type userContactCreateManyUserInputEnvelope = {
    data: Enumerable<userContactCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type userTokenCreateWithoutUserInput = {
    Token: string
  }

  export type userTokenUncheckedCreateWithoutUserInput = {
    Id?: number
    Token: string
  }

  export type userTokenCreateOrConnectWithoutUserInput = {
    where: userTokenWhereUniqueInput
    create: XOR<userTokenCreateWithoutUserInput, userTokenUncheckedCreateWithoutUserInput>
  }

  export type userTokenCreateManyUserInputEnvelope = {
    data: Enumerable<userTokenCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type clientUpsertWithWhereUniqueWithoutUserInput = {
    where: clientWhereUniqueInput
    update: XOR<clientUpdateWithoutUserInput, clientUncheckedUpdateWithoutUserInput>
    create: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
  }

  export type clientUpdateWithWhereUniqueWithoutUserInput = {
    where: clientWhereUniqueInput
    data: XOR<clientUpdateWithoutUserInput, clientUncheckedUpdateWithoutUserInput>
  }

  export type clientUpdateManyWithWhereWithoutUserInput = {
    where: clientScalarWhereInput
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyWithoutClientInput>
  }

  export type clientScalarWhereInput = {
    AND?: Enumerable<clientScalarWhereInput>
    OR?: Enumerable<clientScalarWhereInput>
    NOT?: Enumerable<clientScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Address?: StringNullableFilter | string | null
    City?: StringNullableFilter | string | null
    PhoneNumber?: StringNullableFilter | string | null
    TaxIdentificationNumber?: StringNullableFilter | string | null
    IsDelete?: BoolFilter | boolean
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
  }

  export type clientContactUpsertWithWhereUniqueWithoutUserInput = {
    where: clientContactWhereUniqueInput
    update: XOR<clientContactUpdateWithoutUserInput, clientContactUncheckedUpdateWithoutUserInput>
    create: XOR<clientContactCreateWithoutUserInput, clientContactUncheckedCreateWithoutUserInput>
  }

  export type clientContactUpdateWithWhereUniqueWithoutUserInput = {
    where: clientContactWhereUniqueInput
    data: XOR<clientContactUpdateWithoutUserInput, clientContactUncheckedUpdateWithoutUserInput>
  }

  export type clientContactUpdateManyWithWhereWithoutUserInput = {
    where: clientContactScalarWhereInput
    data: XOR<clientContactUpdateManyMutationInput, clientContactUncheckedUpdateManyWithoutClientContactInput>
  }

  export type codeProjectDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: codeProjectDocumentWhereUniqueInput
    update: XOR<codeProjectDocumentUpdateWithoutUserInput, codeProjectDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<codeProjectDocumentCreateWithoutUserInput, codeProjectDocumentUncheckedCreateWithoutUserInput>
  }

  export type codeProjectDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: codeProjectDocumentWhereUniqueInput
    data: XOR<codeProjectDocumentUpdateWithoutUserInput, codeProjectDocumentUncheckedUpdateWithoutUserInput>
  }

  export type codeProjectDocumentUpdateManyWithWhereWithoutUserInput = {
    where: codeProjectDocumentScalarWhereInput
    data: XOR<codeProjectDocumentUpdateManyMutationInput, codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectDocumentInput>
  }

  export type codeProjectUpsertWithWhereUniqueWithoutUser1Input = {
    where: codeProjectWhereUniqueInput
    update: XOR<codeProjectUpdateWithoutUser1Input, codeProjectUncheckedUpdateWithoutUser1Input>
    create: XOR<codeProjectCreateWithoutUser1Input, codeProjectUncheckedCreateWithoutUser1Input>
  }

  export type codeProjectUpdateWithWhereUniqueWithoutUser1Input = {
    where: codeProjectWhereUniqueInput
    data: XOR<codeProjectUpdateWithoutUser1Input, codeProjectUncheckedUpdateWithoutUser1Input>
  }

  export type codeProjectUpdateManyWithWhereWithoutUser1Input = {
    where: codeProjectScalarWhereInput
    data: XOR<codeProjectUpdateManyMutationInput, codeProjectUncheckedUpdateManyWithoutCreateCodeProjectInput>
  }

  export type codeProjectUpsertWithWhereUniqueWithoutUser2Input = {
    where: codeProjectWhereUniqueInput
    update: XOR<codeProjectUpdateWithoutUser2Input, codeProjectUncheckedUpdateWithoutUser2Input>
    create: XOR<codeProjectCreateWithoutUser2Input, codeProjectUncheckedCreateWithoutUser2Input>
  }

  export type codeProjectUpdateWithWhereUniqueWithoutUser2Input = {
    where: codeProjectWhereUniqueInput
    data: XOR<codeProjectUpdateWithoutUser2Input, codeProjectUncheckedUpdateWithoutUser2Input>
  }

  export type codeProjectUpdateManyWithWhereWithoutUser2Input = {
    where: codeProjectScalarWhereInput
    data: XOR<codeProjectUpdateManyMutationInput, codeProjectUncheckedUpdateManyWithoutConfirmedCodeProjectInput>
  }

  export type codeProjectUpsertWithWhereUniqueWithoutUser3Input = {
    where: codeProjectWhereUniqueInput
    update: XOR<codeProjectUpdateWithoutUser3Input, codeProjectUncheckedUpdateWithoutUser3Input>
    create: XOR<codeProjectCreateWithoutUser3Input, codeProjectUncheckedCreateWithoutUser3Input>
  }

  export type codeProjectUpdateWithWhereUniqueWithoutUser3Input = {
    where: codeProjectWhereUniqueInput
    data: XOR<codeProjectUpdateWithoutUser3Input, codeProjectUncheckedUpdateWithoutUser3Input>
  }

  export type codeProjectUpdateManyWithWhereWithoutUser3Input = {
    where: codeProjectScalarWhereInput
    data: XOR<codeProjectUpdateManyMutationInput, codeProjectUncheckedUpdateManyWithoutCompletedCodeProjectInput>
  }

  export type codeProjectUserUpsertWithWhereUniqueWithoutUserInput = {
    where: codeProjectUserWhereUniqueInput
    update: XOR<codeProjectUserUpdateWithoutUserInput, codeProjectUserUncheckedUpdateWithoutUserInput>
    create: XOR<codeProjectUserCreateWithoutUserInput, codeProjectUserUncheckedCreateWithoutUserInput>
  }

  export type codeProjectUserUpdateWithWhereUniqueWithoutUserInput = {
    where: codeProjectUserWhereUniqueInput
    data: XOR<codeProjectUserUpdateWithoutUserInput, codeProjectUserUncheckedUpdateWithoutUserInput>
  }

  export type codeProjectUserUpdateManyWithWhereWithoutUserInput = {
    where: codeProjectUserScalarWhereInput
    data: XOR<codeProjectUserUpdateManyMutationInput, codeProjectUserUncheckedUpdateManyWithoutCodeProjectUserInput>
  }

  export type codeReportUpsertWithWhereUniqueWithoutUserInput = {
    where: codeReportWhereUniqueInput
    update: XOR<codeReportUpdateWithoutUserInput, codeReportUncheckedUpdateWithoutUserInput>
    create: XOR<codeReportCreateWithoutUserInput, codeReportUncheckedCreateWithoutUserInput>
  }

  export type codeReportUpdateWithWhereUniqueWithoutUserInput = {
    where: codeReportWhereUniqueInput
    data: XOR<codeReportUpdateWithoutUserInput, codeReportUncheckedUpdateWithoutUserInput>
  }

  export type codeReportUpdateManyWithWhereWithoutUserInput = {
    where: codeReportScalarWhereInput
    data: XOR<codeReportUpdateManyMutationInput, codeReportUncheckedUpdateManyWithoutCodeReportInput>
  }

  export type codeReportApprovalUpsertWithWhereUniqueWithoutUserInput = {
    where: codeReportApprovalWhereUniqueInput
    update: XOR<codeReportApprovalUpdateWithoutUserInput, codeReportApprovalUncheckedUpdateWithoutUserInput>
    create: XOR<codeReportApprovalCreateWithoutUserInput, codeReportApprovalUncheckedCreateWithoutUserInput>
  }

  export type codeReportApprovalUpdateWithWhereUniqueWithoutUserInput = {
    where: codeReportApprovalWhereUniqueInput
    data: XOR<codeReportApprovalUpdateWithoutUserInput, codeReportApprovalUncheckedUpdateWithoutUserInput>
  }

  export type codeReportApprovalUpdateManyWithWhereWithoutUserInput = {
    where: codeReportApprovalScalarWhereInput
    data: XOR<codeReportApprovalUpdateManyMutationInput, codeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalInput>
  }

  export type projectTaskUpsertWithWhereUniqueWithoutUserInput = {
    where: projectTaskWhereUniqueInput
    update: XOR<projectTaskUpdateWithoutUserInput, projectTaskUncheckedUpdateWithoutUserInput>
    create: XOR<projectTaskCreateWithoutUserInput, projectTaskUncheckedCreateWithoutUserInput>
  }

  export type projectTaskUpdateWithWhereUniqueWithoutUserInput = {
    where: projectTaskWhereUniqueInput
    data: XOR<projectTaskUpdateWithoutUserInput, projectTaskUncheckedUpdateWithoutUserInput>
  }

  export type projectTaskUpdateManyWithWhereWithoutUserInput = {
    where: projectTaskScalarWhereInput
    data: XOR<projectTaskUpdateManyMutationInput, projectTaskUncheckedUpdateManyWithoutProjectTaskInput>
  }

  export type projectTaskScalarWhereInput = {
    AND?: Enumerable<projectTaskScalarWhereInput>
    OR?: Enumerable<projectTaskScalarWhereInput>
    NOT?: Enumerable<projectTaskScalarWhereInput>
    Id?: IntFilter | number
    Name?: StringFilter | string
    Description?: StringFilter | string
    ParentId?: IntFilter | number
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
  }

  export type requestForInformationAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: requestForInformationAnswerWhereUniqueInput
    update: XOR<requestForInformationAnswerUpdateWithoutUserInput, requestForInformationAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<requestForInformationAnswerCreateWithoutUserInput, requestForInformationAnswerUncheckedCreateWithoutUserInput>
  }

  export type requestForInformationAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: requestForInformationAnswerWhereUniqueInput
    data: XOR<requestForInformationAnswerUpdateWithoutUserInput, requestForInformationAnswerUncheckedUpdateWithoutUserInput>
  }

  export type requestForInformationAnswerUpdateManyWithWhereWithoutUserInput = {
    where: requestForInformationAnswerScalarWhereInput
    data: XOR<requestForInformationAnswerUpdateManyMutationInput, requestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationAnswerInput>
  }

  export type userPositionUpsertWithWhereUniqueWithoutUser4Input = {
    where: userPositionWhereUniqueInput
    update: XOR<userPositionUpdateWithoutUser4Input, userPositionUncheckedUpdateWithoutUser4Input>
    create: XOR<userPositionCreateWithoutUser4Input, userPositionUncheckedCreateWithoutUser4Input>
  }

  export type userPositionUpdateWithWhereUniqueWithoutUser4Input = {
    where: userPositionWhereUniqueInput
    data: XOR<userPositionUpdateWithoutUser4Input, userPositionUncheckedUpdateWithoutUser4Input>
  }

  export type userPositionUpdateManyWithWhereWithoutUser4Input = {
    where: userPositionScalarWhereInput
    data: XOR<userPositionUpdateManyMutationInput, userPositionUncheckedUpdateManyWithoutCreateUserPositionInput>
  }

  export type userPositionScalarWhereInput = {
    AND?: Enumerable<userPositionScalarWhereInput>
    OR?: Enumerable<userPositionScalarWhereInput>
    NOT?: Enumerable<userPositionScalarWhereInput>
    Id?: IntFilter | number
    Position?: IntFilter | number
    EffectiveDate?: DateTimeFilter | Date | string
    CreatedBy?: IntFilter | number
    CreatedDate?: DateTimeFilter | Date | string
    UserId?: IntFilter | number
  }

  export type userPositionUpsertWithWhereUniqueWithoutUser5Input = {
    where: userPositionWhereUniqueInput
    update: XOR<userPositionUpdateWithoutUser5Input, userPositionUncheckedUpdateWithoutUser5Input>
    create: XOR<userPositionCreateWithoutUser5Input, userPositionUncheckedCreateWithoutUser5Input>
  }

  export type userPositionUpdateWithWhereUniqueWithoutUser5Input = {
    where: userPositionWhereUniqueInput
    data: XOR<userPositionUpdateWithoutUser5Input, userPositionUncheckedUpdateWithoutUser5Input>
  }

  export type userPositionUpdateManyWithWhereWithoutUser5Input = {
    where: userPositionScalarWhereInput
    data: XOR<userPositionUpdateManyMutationInput, userPositionUncheckedUpdateManyWithoutUserPositionInput>
  }

  export type userContactUpsertWithWhereUniqueWithoutUserInput = {
    where: userContactWhereUniqueInput
    update: XOR<userContactUpdateWithoutUserInput, userContactUncheckedUpdateWithoutUserInput>
    create: XOR<userContactCreateWithoutUserInput, userContactUncheckedCreateWithoutUserInput>
  }

  export type userContactUpdateWithWhereUniqueWithoutUserInput = {
    where: userContactWhereUniqueInput
    data: XOR<userContactUpdateWithoutUserInput, userContactUncheckedUpdateWithoutUserInput>
  }

  export type userContactUpdateManyWithWhereWithoutUserInput = {
    where: userContactScalarWhereInput
    data: XOR<userContactUpdateManyMutationInput, userContactUncheckedUpdateManyWithoutUserContactInput>
  }

  export type userContactScalarWhereInput = {
    AND?: Enumerable<userContactScalarWhereInput>
    OR?: Enumerable<userContactScalarWhereInput>
    NOT?: Enumerable<userContactScalarWhereInput>
    Id?: IntFilter | number
    PhoneNumber?: StringFilter | string
    UserId?: IntFilter | number
    WhatsappAvailable?: BoolFilter | boolean
  }

  export type userTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: userTokenWhereUniqueInput
    update: XOR<userTokenUpdateWithoutUserInput, userTokenUncheckedUpdateWithoutUserInput>
    create: XOR<userTokenCreateWithoutUserInput, userTokenUncheckedCreateWithoutUserInput>
  }

  export type userTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: userTokenWhereUniqueInput
    data: XOR<userTokenUpdateWithoutUserInput, userTokenUncheckedUpdateWithoutUserInput>
  }

  export type userTokenUpdateManyWithWhereWithoutUserInput = {
    where: userTokenScalarWhereInput
    data: XOR<userTokenUpdateManyMutationInput, userTokenUncheckedUpdateManyWithoutTokenInput>
  }

  export type userTokenScalarWhereInput = {
    AND?: Enumerable<userTokenScalarWhereInput>
    OR?: Enumerable<userTokenScalarWhereInput>
    NOT?: Enumerable<userTokenScalarWhereInput>
    Id?: IntFilter | number
    UserId?: IntFilter | number
    Token?: StringFilter | string
  }

  export type clientContactCreateManyClientInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type codeProjectCreateManyClientInput = {
    Id?: number
    Name: string
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type clientContactUpdateWithoutClientInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: userUpdateOneRequiredWithoutClientContactInput
  }

  export type clientContactUncheckedUpdateWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientContactUncheckedUpdateManyWithoutContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type codeProjectUpdateWithoutClientInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateManyWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeProjectDocumentCreateManyCodeProjectInput = {
    Id?: number
    Name: string
    Url: string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type codeProjectUserCreateManyCodeProjectInput = {
    Id?: number
    UserId: number
  }

  export type codeReportCreateManyCodeProjectInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Date: Date | string
    Type: number
    IsDelete?: boolean
    Note: string
  }

  export type projectCreateManyCodeProjectInput = {
    Id?: number
    Name: string
    BudgetPrice: number
    Quantity: number
    Done: number
    IsDelete?: boolean
    ParentId: number
    EstimatedDuration: number
    Timeline: number
    Price: number
    Description: string
    Unit: string
  }

  export type codeProjectDocumentUpdateWithoutCodeProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: userUpdateOneRequiredWithoutCodeProjectDocumentInput
  }

  export type codeProjectDocumentUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type codeProjectUserUpdateWithoutCodeProjectInput = {
    User?: userUpdateOneRequiredWithoutCodeProjectUserInput
  }

  export type codeProjectUserUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type codeProjectUserUncheckedUpdateManyWithoutCodeProjectUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type codeReportUpdateWithoutCodeProjectInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    User?: userUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateManyWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type projectUpdateWithoutCodeProjectInput = {
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type projectUncheckedUpdateWithoutCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type projectUncheckedUpdateManyWithoutProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    BudgetPrice?: FloatFieldUpdateOperationsInput | number
    Quantity?: FloatFieldUpdateOperationsInput | number
    Done?: FloatFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    ParentId?: IntFieldUpdateOperationsInput | number
    EstimatedDuration?: FloatFieldUpdateOperationsInput | number
    Timeline?: IntFieldUpdateOperationsInput | number
    Price?: FloatFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type codeReportApprovalCreateManyCodeReportInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type codeReportApprovalCreateManyCodeReportCommentInput = {
    Id?: number
    CreatedBy: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type dailyReportImageCreateManyCodeReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
    Caption: string
  }

  export type dailyTaskCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Unit: string
    Quantity: number
    ParentId: number
    Note: string
  }

  export type toolCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Description: string
    Quantity: number
  }

  export type materialCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
    Status: number
    Description: string
    Unit: string
  }

  export type workerCreateManyCodeReportInput = {
    Id?: number
    Name: string
    Quantity: number
  }

  export type codeReportApprovalUpdateWithoutCodeReportInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReportComment?: codeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput
    User?: userUpdateOneRequiredWithoutCodeReportApprovalInput
  }

  export type codeReportApprovalUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeReportApprovalUpdateWithoutCodeReportCommentInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: codeReportUpdateOneRequiredWithoutCodeReportApprovalInput
    User?: userUpdateOneRequiredWithoutCodeReportApprovalInput
  }

  export type codeReportApprovalUncheckedUpdateWithoutCodeReportCommentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeReportApprovalUncheckedUpdateManyWithoutCodeReportApprovalCommentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type dailyReportImageUpdateWithoutCodeReportInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type dailyReportImageUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type dailyReportImageUncheckedUpdateManyWithoutDailyReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Caption?: StringFieldUpdateOperationsInput | string
  }

  export type dailyTaskUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type dailyTaskUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type dailyTaskUncheckedUpdateManyWithoutDailyTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    ParentId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
  }

  export type toolUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type toolUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type toolUncheckedUpdateManyWithoutToolInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type materialUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type materialUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type materialUncheckedUpdateManyWithoutMaterialInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: FloatFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    Unit?: StringFieldUpdateOperationsInput | string
  }

  export type workerUpdateWithoutCodeReportInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type workerUncheckedUpdateWithoutCodeReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type workerUncheckedUpdateManyWithoutWorkerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type requestForInformationAnswerCreateManyRequestForInformationInput = {
    Id?: number
    Answer: string
    CreatedBy: number
    CreatedDate: Date | string
    IsDelete?: boolean
  }

  export type requestForInformationDocumentCreateManyRequestForInformationInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type requestForInformationAnswerUpdateWithoutRequestForInformationInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    User?: userUpdateOneRequiredWithoutRequestForInformationAnswerInput
  }

  export type requestForInformationAnswerUncheckedUpdateWithoutRequestForInformationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestForInformationAnswerUncheckedUpdateManyWithoutRequestForInformationAnswerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestForInformationDocumentUpdateWithoutRequestForInformationInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type requestForInformationDocumentUncheckedUpdateWithoutRequestForInformationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type requestForInformationDocumentUncheckedUpdateManyWithoutRequestForInformationDocumentInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type statusReportImageCreateManyStatusReportInput = {
    Id?: number
    ImageUrl: string
    Name: string
  }

  export type statusReportImageUpdateWithoutStatusReportInput = {
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type statusReportImageUncheckedUpdateWithoutStatusReportInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type statusReportImageUncheckedUpdateManyWithoutStatusReportImageInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ImageUrl?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type clientCreateManyUserInput = {
    Id?: number
    Name: string
    Address?: string | null
    City?: string | null
    PhoneNumber?: string | null
    TaxIdentificationNumber?: string | null
    IsDelete?: boolean
    CreatedDate?: Date | string
  }

  export type clientContactCreateManyUserInput = {
    Id?: number
    Name: string
    Position: string
    PhoneNumber: string
    Email: string
    CreatedDate?: Date | string
    ClientId: number
  }

  export type codeProjectDocumentCreateManyUserInput = {
    Id?: number
    Name: string
    Url: string
    CodeProjectId: number
    CreatedDate?: Date | string
  }

  export type codeProjectCreateManyUser1Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type codeProjectCreateManyUser2Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    CompletedBy?: number | null
    IsDelete?: boolean
  }

  export type codeProjectCreateManyUser3Input = {
    Id?: number
    Name: string
    ClientId: number
    CreatedBy: number
    CreatedDate?: Date | string
    ConfirmedDate?: Date | string | null
    ConfirmedBy?: number | null
    Address: string
    DocumentName: string
    IsCompleted?: boolean
    CompletedDate?: Date | string | null
    IsDelete?: boolean
  }

  export type codeProjectUserCreateManyUserInput = {
    Id?: number
    CodeProjectId: number
  }

  export type codeReportCreateManyUserInput = {
    Id?: number
    CreatedDate?: Date | string
    Date: Date | string
    CodeProjectId: number
    Type: number
    IsDelete?: boolean
    Note: string
  }

  export type codeReportApprovalCreateManyUserInput = {
    Id?: number
    CodeReportId: number
    CreatedDate?: Date | string
    Comment: string
    Approval: number
    IsDelete?: boolean
  }

  export type projectTaskCreateManyUserInput = {
    Id?: number
    Name: string
    Description: string
    ParentId: number
    CreatedDate?: Date | string
  }

  export type requestForInformationAnswerCreateManyUserInput = {
    Id?: number
    Answer: string
    CreatedDate: Date | string
    RequestForInformationId: number
    IsDelete?: boolean
  }

  export type userPositionCreateManyUser4Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedDate?: Date | string
    UserId: number
  }

  export type userPositionCreateManyUser5Input = {
    Id?: number
    Position: number
    EffectiveDate: Date | string
    CreatedBy: number
    CreatedDate?: Date | string
  }

  export type userContactCreateManyUserInput = {
    Id?: number
    PhoneNumber: string
    WhatsappAvailable: boolean
  }

  export type userTokenCreateManyUserInput = {
    Id?: number
    Token: string
  }

  export type clientUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: clientContactUpdateManyWithoutClientInput
    CodeProject?: codeProjectUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: clientContactUncheckedUpdateManyWithoutClientInput
    CodeProject?: codeProjectUncheckedUpdateManyWithoutClientInput
  }

  export type clientUncheckedUpdateManyWithoutClientInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TaxIdentificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientContactUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Client?: clientUpdateOneRequiredWithoutContactInput
  }

  export type clientContactUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type clientContactUncheckedUpdateManyWithoutClientContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Position?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ClientId?: IntFieldUpdateOperationsInput | number
  }

  export type codeProjectDocumentUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeProjectDocumentInput
  }

  export type codeProjectDocumentUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Url?: StringFieldUpdateOperationsInput | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type codeProjectUpdateWithoutUser1Input = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutUser1Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateManyWithoutCreateCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeProjectUpdateWithoutUser2Input = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User3?: userUpdateOneWithoutCompletedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutUser2Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateManyWithoutConfirmedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CompletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeProjectUpdateWithoutUser3Input = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Client?: clientUpdateOneRequiredWithoutCodeProjectInput
    User1?: userUpdateOneRequiredWithoutCreateCodeProjectInput
    User2?: userUpdateOneWithoutConfirmedCodeProjectInput
    CodeProjectDocument?: codeProjectDocumentUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUpdateManyWithoutCodeProjectInput
    Project?: projectUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateWithoutUser3Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeProjectDocument?: codeProjectDocumentUncheckedUpdateManyWithoutCodeProjectInput
    CodeProjectUser?: codeProjectUserUncheckedUpdateManyWithoutCodeProjectInput
    CodeReport?: codeReportUncheckedUpdateManyWithoutCodeProjectInput
    Project?: projectUncheckedUpdateManyWithoutCodeProjectInput
  }

  export type codeProjectUncheckedUpdateManyWithoutCompletedCodeProjectInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    ClientId?: IntFieldUpdateOperationsInput | number
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ConfirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ConfirmedBy?: NullableIntFieldUpdateOperationsInput | number | null
    Address?: StringFieldUpdateOperationsInput | string
    DocumentName?: StringFieldUpdateOperationsInput | string
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    CompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type codeProjectUserUpdateWithoutUserInput = {
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeProjectUserInput
  }

  export type codeProjectUserUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeProjectId?: IntFieldUpdateOperationsInput | number
  }

  export type codeReportUpdateWithoutUserInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeProject?: codeProjectUpdateOneRequiredWithoutCodeReportInput
    CodeReportApproval?: codeReportApprovalUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUpdateOneWithoutCodeReportInput
    Tool?: toolUpdateManyWithoutCodeReportInput
    Weather?: weatherUpdateOneWithoutCodeReportInput
    Material?: materialUpdateManyWithoutCodeReportInput
    Worker?: workerUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUpdateOneWithoutCodeReportInput
  }

  export type codeReportUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    CodeProjectId?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    Note?: StringFieldUpdateOperationsInput | string
    CodeReportApproval?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportInput
    CodeReportApprovalComment?: codeReportApprovalUncheckedUpdateManyWithoutCodeReportCommentInput
    DailyReportImage?: dailyReportImageUncheckedUpdateManyWithoutCodeReportInput
    DailyTask?: dailyTaskUncheckedUpdateManyWithoutCodeReportInput
    StatusReport?: statusReportUncheckedUpdateOneWithoutCodeReportInput
    Tool?: toolUncheckedUpdateManyWithoutCodeReportInput
    Weather?: weatherUncheckedUpdateOneWithoutCodeReportInput
    Material?: materialUncheckedUpdateManyWithoutCodeReportInput
    Worker?: workerUncheckedUpdateManyWithoutCodeReportInput
    RequestForInformation?: requestForInformationUncheckedUpdateOneWithoutCodeReportInput
  }

  export type codeReportApprovalUpdateWithoutUserInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    CodeReport?: codeReportUpdateOneRequiredWithoutCodeReportApprovalInput
    CodeReportComment?: codeReportUpdateOneRequiredWithoutCodeReportApprovalCommentInput
  }

  export type codeReportApprovalUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CodeReportId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: StringFieldUpdateOperationsInput | string
    Approval?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type projectTaskUpdateWithoutUserInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projectTaskUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projectTaskUncheckedUpdateManyWithoutProjectTaskInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
    ParentId?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestForInformationAnswerUpdateWithoutUserInput = {
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
    RequestForInformation?: requestForInformationUpdateOneRequiredWithoutRequestForInformationAnswerInput
  }

  export type requestForInformationAnswerUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Answer?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestForInformationId?: IntFieldUpdateOperationsInput | number
    IsDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userPositionUpdateWithoutUser4Input = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User5?: userUpdateOneRequiredWithoutUserPositionInput
  }

  export type userPositionUncheckedUpdateWithoutUser4Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type userPositionUncheckedUpdateManyWithoutCreateUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type userPositionUpdateWithoutUser5Input = {
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    User4?: userUpdateOneRequiredWithoutCreateUserPositionInput
  }

  export type userPositionUncheckedUpdateWithoutUser5Input = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userPositionUncheckedUpdateManyWithoutUserPositionInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Position?: IntFieldUpdateOperationsInput | number
    EffectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userContactUpdateWithoutUserInput = {
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userContactUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userContactUncheckedUpdateManyWithoutUserContactInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    WhatsappAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userTokenUpdateWithoutUserInput = {
    Token?: StringFieldUpdateOperationsInput | string
  }

  export type userTokenUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Token?: StringFieldUpdateOperationsInput | string
  }

  export type userTokenUncheckedUpdateManyWithoutTokenInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Token?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}